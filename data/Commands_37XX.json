{
    "commands": [
        {
            "name": "slot[slot].endchannel.amps",
            "webhelpfile": "13721.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the selected slot supports a feature and if so, which channels support the feature.Channel supports amperage measurements",
            "details": "This attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the ending channel.If only one channel in the card supports the feature, the ending channel matches the starting channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the ending channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].endchannel.amps",
                "value = slot[slot].endchannel.analogoutput",
                "value = slot[slot].endchannel.digitalio",
                "value = slot[slot].endchannel.isolated",
                "value = slot[slot].endchannel.totalizer",
                "value = slot[slot].endchannel.voltage"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" .. slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..               slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" .. slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end    ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" .. slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" .. slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end     ;      if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end      ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "Slot",
                "slot[slot].startchannel.*"
            ]
        },
        {
            "name": "slot[slot].endchannel.analogoutput",
            "webhelpfile": "13721.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the selected slot supports a feature and if so, which channels support the feature.Channel supports a digital analog output (DAC)",
            "details": "This attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the ending channel.If only one channel in the card supports the feature, the ending channel matches the starting channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the ending channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].endchannel.amps",
                "value = slot[slot].endchannel.analogoutput",
                "value = slot[slot].endchannel.digitalio",
                "value = slot[slot].endchannel.isolated",
                "value = slot[slot].endchannel.totalizer",
                "value = slot[slot].endchannel.voltage"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" .. slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..               slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" .. slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end    ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" .. slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" .. slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end     ;      if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end      ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "Slot",
                "slot[slot].startchannel.*"
            ]
        },
        {
            "name": "slot[slot].endchannel.digitalio",
            "webhelpfile": "13721.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the selected slot supports a feature and if so, which channels support the feature.Channel supports digital inputs and outputs",
            "details": "This attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the ending channel.If only one channel in the card supports the feature, the ending channel matches the starting channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the ending channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].endchannel.amps",
                "value = slot[slot].endchannel.analogoutput",
                "value = slot[slot].endchannel.digitalio",
                "value = slot[slot].endchannel.isolated",
                "value = slot[slot].endchannel.totalizer",
                "value = slot[slot].endchannel.voltage"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" .. slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..               slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" .. slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end    ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" .. slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" .. slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end     ;      if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end      ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "Slot",
                "slot[slot].startchannel.*"
            ]
        },
        {
            "name": "slot[slot].endchannel.isolated",
            "webhelpfile": "13721.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the selected slot supports a feature and if so, which channels support the feature.Channel supports isolated channels",
            "details": "This attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the ending channel.If only one channel in the card supports the feature, the ending channel matches the starting channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the ending channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].endchannel.amps",
                "value = slot[slot].endchannel.analogoutput",
                "value = slot[slot].endchannel.digitalio",
                "value = slot[slot].endchannel.isolated",
                "value = slot[slot].endchannel.totalizer",
                "value = slot[slot].endchannel.voltage"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" .. slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..               slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" .. slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end    ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" .. slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" .. slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end     ;      if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end      ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "Slot",
                "slot[slot].startchannel.*"
            ]
        },
        {
            "name": "slot[slot].endchannel.totalizer",
            "webhelpfile": "13721.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the selected slot supports a feature and if so, which channels support the feature.Channel supports totalizer channels",
            "details": "This attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the ending channel.If only one channel in the card supports the feature, the ending channel matches the starting channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the ending channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].endchannel.amps",
                "value = slot[slot].endchannel.analogoutput",
                "value = slot[slot].endchannel.digitalio",
                "value = slot[slot].endchannel.isolated",
                "value = slot[slot].endchannel.totalizer",
                "value = slot[slot].endchannel.voltage"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" .. slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..               slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" .. slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end    ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" .. slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" .. slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end     ;      if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end      ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "Slot",
                "slot[slot].startchannel.*"
            ]
        },
        {
            "name": "slot[slot].endchannel.voltage",
            "webhelpfile": "13721.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the selected slot supports a feature and if so, which channels support the feature.Channel supports voltage or two-wire measurements",
            "details": "This attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the ending channel.If only one channel in the card supports the feature, the ending channel matches the starting channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the ending channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].endchannel.amps",
                "value = slot[slot].endchannel.analogoutput",
                "value = slot[slot].endchannel.digitalio",
                "value = slot[slot].endchannel.isolated",
                "value = slot[slot].endchannel.totalizer",
                "value = slot[slot].endchannel.voltage"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" .. slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..               slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" .. slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end    ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" .. slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" .. slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end     ;      if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end      ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "Slot",
                "slot[slot].startchannel.*"
            ]
        },
        {
            "name": "slot[slot].startchannel.amps",
            "webhelpfile": "13723.htm",
            "signature": "",
            "command_return": "",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the specified slot supports a feature and if so, which channels support the feature.Channel supports amperage measurements",
            "details": "value = slot[slot].startchannel.ampsvalue = slot[slot].startchannel.analogoutputvalue = slot[slot].startchannel.digitaliovalue = slot[slot].startchannel.isolatedvalue = slot[slot].startchannel.totalizervalue = slot[slot].startchannel.voltageThis attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped on the cards by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the starting channel.If only one channel in the card supports the feature, the starting channel will match the ending channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the starting channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" ..             slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..             slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" ..             slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end      ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" ..             slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" ..             slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end   ;         if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end     ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "slot[slot].endchannel.*"
            ]
        },
        {
            "name": "slot[slot].startchannel.analogoutput",
            "webhelpfile": "13723.htm",
            "signature": "",
            "command_return": "",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the specified slot supports a feature and if so, which channels support the feature.Channel supports a digital analog output (DAC)",
            "details": "value = slot[slot].startchannel.ampsvalue = slot[slot].startchannel.analogoutputvalue = slot[slot].startchannel.digitaliovalue = slot[slot].startchannel.isolatedvalue = slot[slot].startchannel.totalizervalue = slot[slot].startchannel.voltageThis attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped on the cards by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the starting channel.If only one channel in the card supports the feature, the starting channel will match the ending channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the starting channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" ..             slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..             slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" ..             slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end      ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" ..             slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" ..             slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end   ;         if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end     ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "slot[slot].endchannel.*"
            ]
        },
        {
            "name": "slot[slot].startchannel.digitalio",
            "webhelpfile": "13723.htm",
            "signature": "",
            "command_return": "",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the specified slot supports a feature and if so, which channels support the feature.Channel supports digital inputs and outputs",
            "details": "value = slot[slot].startchannel.ampsvalue = slot[slot].startchannel.analogoutputvalue = slot[slot].startchannel.digitaliovalue = slot[slot].startchannel.isolatedvalue = slot[slot].startchannel.totalizervalue = slot[slot].startchannel.voltageThis attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped on the cards by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the starting channel.If only one channel in the card supports the feature, the starting channel will match the ending channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the starting channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" ..             slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..             slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" ..             slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end      ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" ..             slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" ..             slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end   ;         if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end     ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "slot[slot].endchannel.*"
            ]
        },
        {
            "name": "slot[slot].startchannel.isolated",
            "webhelpfile": "13723.htm",
            "signature": "",
            "command_return": "",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the specified slot supports a feature and if so, which channels support the feature.Channel supports isolated channels",
            "details": "value = slot[slot].startchannel.ampsvalue = slot[slot].startchannel.analogoutputvalue = slot[slot].startchannel.digitaliovalue = slot[slot].startchannel.isolatedvalue = slot[slot].startchannel.totalizervalue = slot[slot].startchannel.voltageThis attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped on the cards by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the starting channel.If only one channel in the card supports the feature, the starting channel will match the ending channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the starting channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" ..             slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..             slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" ..             slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end      ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" ..             slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" ..             slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end   ;         if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end     ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "slot[slot].endchannel.*"
            ]
        },
        {
            "name": "slot[slot].startchannel.totalizer",
            "webhelpfile": "13723.htm",
            "signature": "",
            "command_return": "",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the specified slot supports a feature and if so, which channels support the feature.Channel supports totalizer channels",
            "details": "value = slot[slot].startchannel.ampsvalue = slot[slot].startchannel.analogoutputvalue = slot[slot].startchannel.digitaliovalue = slot[slot].startchannel.isolatedvalue = slot[slot].startchannel.totalizervalue = slot[slot].startchannel.voltageThis attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped on the cards by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the starting channel.If only one channel in the card supports the feature, the starting channel will match the ending channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the starting channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" ..             slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..             slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" ..             slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end      ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" ..             slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" ..             slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end   ;         if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end     ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "slot[slot].endchannel.*"
            ]
        },
        {
            "name": "slot[slot].startchannel.voltage",
            "webhelpfile": "13723.htm",
            "signature": "",
            "command_return": "",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "These attributes indicates whether or not the channel in the specified slot supports a feature and if so, which channels support the feature.Channel supports voltage or two-wire measurements",
            "details": "value = slot[slot].startchannel.ampsvalue = slot[slot].startchannel.analogoutputvalue = slot[slot].startchannel.digitaliovalue = slot[slot].startchannel.isolatedvalue = slot[slot].startchannel.totalizervalue = slot[slot].startchannel.voltageThis attribute is only available for a slot if the installed card supports the selected feature. If the attribute is not available, the return value is nil.Channels are grouped on the cards by feature sets, so you can use the start and ending channel numbers to identify a group of channels that supports a particular feature. If the card supports the feature, the returned value is the number of the starting channel.If only one channel in the card supports the feature, the starting channel will match the ending channel number.The commands support different types of channels:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The channel number of the starting channel of the group of channels that supports the feature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [],
            "overloads": [],
            "examples": [
                {
                    "example": "CardChannels = function(SlotNumber)   ;   if slot[SlotNumber].idn == \"Empty Slot\" then   ;      print(\"   Slot is Empty\")   ;   else   ;      if (slot[SlotNumber].startchannel.voltage == nil) and            (slot[SlotNumber].endchannel.voltage == nil) then   ;         print(\"   no voltage channels\")   ;      else    ;         print(\"   Start voltage channel is \" ..             slot[SlotNumber].startchannel.voltage)    ;         print(\"   End voltage channel is \" .. slot[SlotNumber].endchannel.voltage)    ;      end     ;      if (slot[SlotNumber].startchannel.amps == nil) and             (slot[SlotNumber].endchannel.amps == nil) then   ;         print(\"   no amp channels\")   ;      else    ;         print(\"   Start amp channel is \" .. slot[SlotNumber].startchannel.amps)    ;         print(\"   End amp channel is \" .. slot[SlotNumber].endchannel.amps)    ;      end     ;      if (slot[SlotNumber].digio == 1) then    ;         print(\"   Start digital i/o channel is \" ..             slot[SlotNumber].startchannel.digitalio)    ;         print(\"   End digital i/o channel is \" ..             slot[SlotNumber].endchannel.digitalio)    ;      else   ;         print(\"   no digio channels\")   ;      end      ;      if (slot[SlotNumber].totalizer == 1) then    ;         print(\"   Start totalizer channel is \" ..             slot[SlotNumber].startchannel.totalizer)    ;         print(\"   End totalizer channel is \" ..             slot[SlotNumber].endchannel.totalizer)   ;      else   ;         print(\"   no totalizer channels\")    ;      end   ;         if (slot[SlotNumber].startchannel.analogoutput == nil) and             (slot[SlotNumber].endchannel.analogoutput == nil) then   ;         print(\"   no analog output channels\")   ;      else    ;         print(\"   Start analog output channel is \" ..             slot[SlotNumber].startchannel.analogoutput)    ;         print(\"   End analog output channel is \" ..             slot[SlotNumber].endchannel.analogoutput)    ;      end     ;      if (slot[SlotNumber].matrix == 1) then   ;         print(\"   Channels on card are matrix type\")   ;      end   ;   end   ;end    ;for x = 1,6 do   ;   print(\"Checking card channels in slot \" .. x)   ;   CardChannels(x)   ;end  ;",
                    "description": "If the Series 3700A contains the following cards:\n--- --Slot 1: 3732Slot 2: 3720Slot 3: 3750Slot 4: EmptySlot 5: 3721Slot 6: EmptyThe output of this example is similar to:\n--- --Checking card channels in slot 1\n--- --   no voltage channels\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --   Channels on card are matrix type\n--- --Checking card channels in slot 2\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 60\n--- --   no amp channels\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 3\n--- --   no voltage channels\n--- --   no amp channels\n--- --   Start digital i/o channel is 1\n--- --   End digital i/o channel is 5\n--- --   Start totalizer channel is 6\n--- --   End totalizer channel is 9\n--- --   Start analog output channel is 10\n--- --   End analog output channel is 11\n--- --Checking card channels in slot 4\n--- --   Slot is Empty\n--- --Checking card channels in slot 5\n--- --   Start voltage channel is 1\n--- --   End voltage channel is 40\n--- --   Start amp channel is 41\n--- --   End amp channel is 42\n--- --   no digio channels\n--- --   no totalizer channels\n--- --   no analog output channels\n--- --Checking card channels in slot 6\n--- --   Slot is Empty\n"
                }
            ],
            "related_commands": [
                "slot[slot].endchannel.*"
            ]
        },
        {
            "name": "reset()",
            "webhelpfile": "13933.htm",
            "signature": "reset(system)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function resets commands to their default settings.",
            "details": "The reset() command in its simplest form resets the entire TSP\u2011enabled system, including the controlling node and all subordinate nodes.If you want to reset a specific instrument, use either the localnode.reset() or node[X].reset() command. Use the localnode.reset() command for the local instrument. Use the node[X].reset() command to reset an instrument on a subordinate node.You can only reset the entire system using reset(true) if the node is the master. If the node is not the master node, executing this command generates an error.",
            "param_info": [
                {
                    "name": "system",
                    "description": "What to reset",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                }
            ],
            "usage": [
                "reset()",
                "reset(system)"
            ],
            "overloads": [
                "reset()"
            ],
            "examples": [
                {
                    "example": "reset(true);",
                    "description": "If the node is the master node, the entire system is reset; if the node is not the master node, an error is generated.\n"
                }
            ],
            "related_commands": [
                "localnode.reset()"
            ]
        },
        {
            "name": "settime()",
            "webhelpfile": "13943.htm",
            "signature": "settime(time)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the real-time clock (sets present time of the system).",
            "details": "This function sets the date and time of the instrument based on the time parameter (specified in UTC time). UTC time is specified as the number of seconds since Jan 1, 1970, UTC. You can use UTC time from a local time specification, or you can use UTC time from another source (for example, your computer).",
            "param_info": [
                {
                    "name": "time",
                    "description": "The time in seconds since January 1, 1970 UTC",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "settime(time)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "systemTime = os.time({year = 2020,;       month = 3,;       day = 31,;       hour = 14,;       min = 25});settime(systemTime);",
                    "description": "Sets the date and time to Mar 31, 2020 at\u00a02:25\u00a0pm.\n"
                }
            ],
            "related_commands": [
                "gettimezone()",
                "os.time()",
                "settimezone()"
            ]
        },
        {
            "name": "delay()",
            "webhelpfile": "13949.htm",
            "signature": "delay(seconds)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function delays the execution of the commands that follow it.",
            "details": "The instrument delays execution of the commands for at least the specified number of seconds and fractional seconds. However, the processing time may cause the instrument to delay 5\u00a0\u03bcs to 10\u00a0\u03bcs (typical) more than the requested delay.",
            "param_info": [
                {
                    "name": "seconds",
                    "description": "The number of seconds to delay (0\u00a0s to 100 ks)",
                    "enum": "",
                    "type": "number",
                    "range": "(0\u00a0s to 100 ks)"
                }
            ],
            "usage": [
                "delay(seconds)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "beeper.beep(0.5, 2400);delay(0.250);beeper.beep(0.5, 2400);",
                    "description": "Emit a double\u2011beep at 2400 Hz. The sequence is 0.5\u00a0s on, 0.25\u00a0s off, 0.5\u00a0s on.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "slot[slot].pseudocard",
            "webhelpfile": "13964.htm",
            "signature": "",
            "command_return": "pseudoCard",
            "type": "Attribute (RW)\n",
            "default_value": "slot.PSEUDO_NONE\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies a pseudocard to implement.",
            "details": "Pseudocards allow you to configure your system without having an actual plug-in card installed in your system. You can perform open, close, and scan operations and configure your system with pseudocards.This command is only applicable to a slot that does not have a plug-in card or pseudocard installed. If a pseudocard is presently assigned to the slot, you must set the slot to no pseudocard before assigning the new pseudocard.After assigning a pseudocard, you can use valid commands for the plug-in card for that slot.Changing the pseudocard assignment from a pseudocard to no pseudocard invalidates scan lists that include that slot.If a module is installed in the slot, this command returns nil. If the slot is empty and no pseudocard is installed, the return is 0.",
            "param_info": [
                {
                    "name": "pseudoCard",
                    "description": "Set pseudocard to one of the following values",
                    "enum": "slot.PSEUDO_NONE 0",
                    "type": "slotpseudocardpseudoCard",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "pseudoCard = slot[slot].pseudocard",
                "slot[slot].pseudocard = pseudoCard"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "slot[6].pseudocard = 3720;",
                    "description": "Sets the pseudocard of slot 6 for 3720 plug-in card simulation.\n"
                }
            ],
            "related_commands": [
                "slot[slot].idn"
            ]
        },
        {
            "name": "channel.calibration.adjustcount()",
            "webhelpfile": "13975.htm",
            "signature": "channel.calibration.adjustcount(slotX)",
            "command_return": "count",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function gets the number of times that a card has been adjusted.",
            "details": "This command can be used with channels that are locked or unlocked. If no channelList is provided, the currently unlocked channels are assumed.There is only one adjustment count per card. Therefore, with no channel unlocked, the only acceptable values for channelList are \"slot1\", \"slot2\", and so on. An error is generated if any other values are used.",
            "param_info": [
                {
                    "name": "count",
                    "description": "Return value representing the number of times the instrument has been adjusted",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "The slot number ( 1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "( 1 to 6)"
                }
            ],
            "usage": [
                "count = channel.calibration.adjustcount(slotX)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "Count = channel.calibration.adjustcount(\"slot1\");print(Count);",
                    "description": "Assign the number of times the card in slot 1 has been adjusted to a user variable named Count.\n--- --Output the value.\n--- --3\n--- --This shows that the instrument has been adjusted 3 times.\n"
                }
            ],
            "related_commands": [
                "channel.calibration.adjustdate()"
            ]
        },
        {
            "name": "channel.calibration.adjustdate()",
            "webhelpfile": "13979.htm",
            "signature": "channel.calibration.adjustdate(slotX, date)",
            "command_return": "returnDate",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets or gets the adjustment date in UTC format (number of seconds since January 1, 1970) on the unlocked channel.",
            "details": "This command can get the adjust date whether calibration is currently locked or unlocked. If the channelList parameter is not specified, it uses the currently unlocked card. This command can only set the adjustment date on a previously unlocked card. The date is not permanently saved until the channel.calibration.save() command is sent.There is only one adjustment date per card. Therefore, the only acceptable values for channelList are slotX. An error is generated if any other values are used.",
            "param_info": [
                {
                    "name": "returnDate",
                    "description": "The adjustment date in UTC format",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "The slot number ( 1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "( 1 to 6)"
                },
                {
                    "name": "date",
                    "description": "The date of the adjustment (UTC formatted)",
                    "enum": "",
                    "type": "any",
                    "range": "(UTC formatted)"
                }
            ],
            "usage": [
                "returnDate = channel.calibration.adjustdate(slotX)",
                "returnDate = channel.calibration.adjustdate(slotX, date)"
            ],
            "overloads": [
                "returnDate = channel.calibration.adjustdate(slotX)"
            ],
            "examples": [
                {
                    "example": "adjustmentDate = channel.calibration.adjustdate(\"slot2\");",
                    "description": "Gets the adjustment date for the card in slot 2.\n"
                },
                {
                    "example": "NewAdjustDate = os.time{year=2010, month=12, day=28, hour=17, min=35, sec=0};channel.calibration.unlock(\"slot5\", \"KI3706\");myDate = channel.calibration.adjustdate(\"slot5\", NewAdjustDate);channel.calibration.save();channel.calibration.lock();print(os.date(\"%c\", myDate));",
                    "description": "Assign the UTC time for December 28, 2010 at 17:35:00 GMT to NewAdjustDate.\n--- --Unlock the calibration for the card in slot 5, assuming the default password.\n--- --Set the adjustment date using NewAdjustDate for the card in slot 5.\n--- --Save the adjustment date on the card on slot 5.\n--- --Lock the calibration for the card in slot 5.\n--- --View the date for myDate.\n"
                }
            ],
            "related_commands": [
                "Lua date and time",
                "UTC Calculator",
                "channel.calibration.adjustcount()",
                "channel.calibration.save()",
                "channel.calibration.verifydate()"
            ]
        },
        {
            "name": "channel.calibration.save()",
            "webhelpfile": "13980.htm",
            "signature": "channel.calibration.save()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function saves the calibration data to the card.",
            "details": "Only one card can be calibrated at a time. Therefore, channel.calibration.save() works only on the presently unlocked card. An error is generated if this command is issued when calibration is already locked. The system must receive this command before the channel.calibration.lock() command or the calibration data will be lost. This command saves the present values of the calibration constants and calibration date, and increases the calibration count by one, regardless of errors in the data. You should not issue channel.calibration.save() unless the calibration procedure was performed with no errors.If no calibration date was specified using either channel.calibration.adjustdate() or channel.calibration.verifydate(), the date is automatically assigned based on the system date.",
            "param_info": [],
            "usage": [
                "channel.calibration.save()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.calibration.unlock(\"slot1\",\"KI3706\");-- Perform operations to generate the calibration data;channel.calibration.save();channel.calibration.lock();",
                    "description": "Unlock the card calibration for slot 1 using the default password.\n--- --Use the channel.calibration.step command to generate the calibration data.\n--- --Save the calibration data for the card in slot 1, if no errors occurred while generating the calibration data.\n--- --Lock the calibration data for the card in slot 1.\n"
                }
            ],
            "related_commands": [
                "channel.calibration.adjustcount()",
                "channel.calibration.adjustdate()",
                "channel.calibration.lock()",
                "channel.calibration.unlock()",
                "channel.calibration.verifydate()"
            ]
        },
        {
            "name": "channel.read()",
            "webhelpfile": "13984.htm",
            "signature": "channel.read(channelList, width, readingBuffer)",
            "command_return": "value",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads a value from a totalizer, DAC, or digital I/O channel.",
            "details": "For digital I/O channels, only a width of 1, 2, 3, or 4 is supported. Any information (bits) greater than the specified width is returned as zero. For example, if channels 1 and 2 are both 255, a reading with a width of 1 returns 255 and a width of 2 with channel 1 returns 65535. Values read from outputs reflect their current setting. If the read channel is in the overload state, the read value is indeterminate.For widths greater than 1, the specified channel occupies the least significant byte. For example, reading the value 4293844224 (hex ffeedd00) from channel 1 with a width of 4 indicates channel 1 is 0 (hex 0), channel 2 is 221 (hex dd), channel 3 is 238 (hex ee), and channel 4 is 255 (hex ff). Reading the value of 0 (hex 0) from channel 1 with a width of 1 indicates channel 1 is 0 (hex 0) and other channels are not included. Totalizer and DAC channels do not support a width other than 1 and result in an error if specified.Switch and backplane channels are not supported.For a channel with a power state of OFF, the returned value is DISABLED.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Return string that lists the comma-delimited read values for the selected channels",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "The channels to set, using standard channel naming",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "width",
                    "description": "Specifies reading over multiple consecutive channels (default 1)",
                    "enum": "",
                    "type": "number",
                    "range": "(default 1)"
                },
                {
                    "name": "readingBuffer",
                    "description": "Reading buffer to store read values",
                    "enum": "",
                    "type": "bufferMethods",
                    "range": ""
                }
            ],
            "usage": [
                "value = channel.read(channelList)",
                "value = channel.read(channelList, width)",
                "value = channel.read(channelList, width, readingBuffer)"
            ],
            "overloads": [
                "value = channel.read(channelList)",
                "value = channel.read(channelList, width)"
            ],
            "examples": [
                {
                    "example": "count = channel.read(\"1006\");",
                    "description": "Read the count from the first totalizer channel (channel 6) in slot 1, assuming a 3750.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "waitcomplete()",
            "webhelpfile": "13986.htm",
            "signature": "waitcomplete(group)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function waits for all previously started overlapped commands to complete.",
            "details": "There are two types of instrument commands:The waitcomplete() command suspends the execution of commands until the instrument operations of all previous overlapped commands are finished. This command is not needed for sequential commands.Presently, the Series 3700A has no overlapped commands implemented. However, other TSP\u2011enabled products, such as the Series 2600B System SourceMeter\u00ae Instruments, have overlapped commands. Therefore, when the Series 3700A is a TSP master to a subordinate device with overlapped commands, use this function to wait until all overlapped operations are completed.A group number may only be specified when this node is the master node.If no group is specified, the local group is used.If zero (0) is specified for the group, this function waits for all nodes in the system.",
            "param_info": [
                {
                    "name": "group",
                    "description": "Specifies which TSP-Link group on which to wait",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "waitcomplete()",
                "waitcomplete(group)"
            ],
            "overloads": [
                "waitcomplete()"
            ],
            "examples": [
                {
                    "example": "waitcomplete();",
                    "description": "Waits for all nodes in the local group.\n"
                },
                {
                    "example": "waitcomplete(G);",
                    "description": "Waits for all nodes in group G.\n"
                },
                {
                    "example": "waitcomplete(0);",
                    "description": "Waits for all nodes on the TSP-Link network.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "userstring.add()",
            "webhelpfile": "13987.htm",
            "signature": "userstring.add(name, value)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function adds a user-defined string to nonvolatile memory.",
            "details": "This function associates the string value with the string name and stores this key-value pair in nonvolatile memory.Use the userstring.get() function to retrieve the value associated with the specified name.You can use the userstring functions to store custom, instrument-specific information in the instrument, such as department number, asset number, or manufacturing plant location.",
            "param_info": [
                {
                    "name": "name",
                    "description": "The name of the string; the key of the key-value pair",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "The string to associate with name; the value of the key-value pair",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "userstring.add(name, value)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "userstring.add(\"assetnumber\", \"236\");userstring.add(\"product\", \"Widgets\");userstring.add(\"contact\", \"John Doe\");for name in userstring.catalog() do;   print(name .. \" = \" ..;      userstring.get(name));end;",
                    "description": "Stores user-defined strings in nonvolatile memory and recalls them from the instrument using a for loop.\n--- --Example output:\n--- --assetnumber = 236\n--- --contact = John Doe\n--- --product = Widgets\n"
                }
            ],
            "related_commands": [
                "userstring.catalog()",
                "userstring.delete()",
                "userstring.get()"
            ]
        },
        {
            "name": "userstring.catalog()",
            "webhelpfile": "13988.htm",
            "signature": "for name in userstring.catalog() do body end",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates an iterator for the user\u2011defined string catalog.",
            "details": "The catalog provides access for user\u2011defined string pairs, allowing you to manipulate all the key-value pairs in nonvolatile memory. The entries are enumerated in no particular order.",
            "param_info": [
                {
                    "name": "name",
                    "description": "The name of the string; the key of the key-value pair",
                    "enum": "",
                    "type": "stirng",
                    "range": ""
                },
                {
                    "name": "body",
                    "description": "Code to execute in the body of the for loop",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "for name in userstring.catalog() do body end"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "for name in userstring.catalog() do;   userstring.delete(name);end;",
                    "description": "Deletes all user\u2011defined strings in nonvolatile memory.\n"
                },
                {
                    "example": "userstring.add(\"assetnumber\", \"236\");userstring.add(\"product\", \"Widgets\");userstring.add(\"contact\", \"John Doe\");for name in userstring.catalog() do;   print(name .. \" = \" ..;      userstring.get(name));end;",
                    "description": "Prints all userstring key\u2011value pairs.\n--- --Output:\n--- --product = Widgets\n--- --assetnumber = 236\n--- --contact = John Doe\n--- --Notice the key-value pairs are not listed in the order they were added.\n"
                }
            ],
            "related_commands": [
                "userstring.add()",
                "userstring.delete()",
                "userstring.get()"
            ]
        },
        {
            "name": "userstring.delete()",
            "webhelpfile": "13989.htm",
            "signature": "userstring.delete(name)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function deletes a user-defined string from nonvolatile memory.",
            "details": "This function deletes the string that is associated with name from nonvolatile memory.",
            "param_info": [
                {
                    "name": "name",
                    "description": "The name (key) of the key-value pair of the user\u2011defined string to delete",
                    "enum": "",
                    "type": "string",
                    "range": "(key)"
                }
            ],
            "usage": [
                "userstring.delete(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "userstring.delete(\"assetnumber\");userstring.delete(\"product\");userstring.delete(\"contact\");",
                    "description": "Deletes the user-defined strings associated with the assetnumber, product, and contact names.\n"
                }
            ],
            "related_commands": [
                "userstring.add()",
                "userstring.catalog()",
                "userstring.get()"
            ]
        },
        {
            "name": "userstring.get()",
            "webhelpfile": "13990.htm",
            "signature": "userstring.get(name)",
            "command_return": "value",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function retrieves a user-defined string from nonvolatile memory.",
            "details": "This function retrieves the string that is associated with name from nonvolatile memory.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The value of the user\u2011defined string key-value pair",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "The name (key) of the user\u2011defined string",
                    "enum": "",
                    "type": "string",
                    "range": "(key)"
                }
            ],
            "usage": [
                "value = userstring.get(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "userstring.add(\"assetnumber\", \"236\");value = userstring.get(\"assetnumber\");print(value);",
                    "description": "Create the user-defined string assetnumber, set to a value of 236.\n--- --Read the value associated with the user-defined string named assetnumber.\n--- --Store it in a variable called value, then print the variable value.\n--- --Output:\n--- --236\n"
                }
            ],
            "related_commands": [
                "userstring.add()",
                "userstring.catalog()",
                "userstring.delete()"
            ]
        },
        {
            "name": "upgrade.previous()",
            "webhelpfile": "14062.htm",
            "signature": "upgrade.previous()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function returns to a previous version of the Series 3700A firmware.",
            "details": "This function allows you to revert to an earlier version of the firmware.When you send this function, the instrument searches the USB flash drive in the front\u2011panel USB port for an upgrade file. If the file is found, the instrument performs the upgrade. An error is returned if an upgrade file is not found.",
            "param_info": [],
            "usage": [
                "upgrade.previous()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "Upgrading the firmware",
                "upgrade.unit()"
            ]
        },
        {
            "name": "upgrade.unit()",
            "webhelpfile": "14063.htm",
            "signature": "upgrade.unit()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function upgrades the Series 3700A firmware.",
            "details": "When upgrade.unit() is used, the firmware is only loaded if the version of the firmware is newer than the existing version. If the version is older or at the same revision level, it is not upgraded.When you send this function, the instrument searches the USB flash drive in the front\u2011panel USB port for an upgrade file. If the file is found, the instrument verifies that the file is a newer version. If the version is older or at the same revision level, it is not upgraded, although it does request a reboot. If it is a newer version, the instrument performs the upgrade. An error is returned if no upgrade file is found.",
            "param_info": [],
            "usage": [
                "upgrade.unit()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "upgrade.previous()",
                "Upgrading the firmware"
            ]
        },
        {
            "name": "tspnet.clear()",
            "webhelpfile": "14073.htm",
            "signature": "tspnet.clear(connectionID)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function clears any pending output data from the instrument.",
            "details": "This function clears any pending output data from the device. No data is returned to the caller and no data is processed.",
            "param_info": [
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                }
            ],
            "usage": [
                "tspnet.clear(connectionID)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tspnet.write(testdevice, \"print([[hello]])\");print(tspnet.readavailable(testdevice));tspnet.clear(testdevice);print(tspnet.readavailable(testdevice));",
                    "description": "Write data to a device, then print how much is available.\n--- --Output:\n--- --6.00000e+00\n--- --\u00a0\n--- --Clear data and print how much data is available again.\n--- --Output:\n--- --0.00000e+00\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()",
                "tspnet.readavailable()",
                "tspnet.write()"
            ]
        },
        {
            "name": "tspnet.connect()",
            "webhelpfile": "14074.htm",
            "signature": "tspnet.connect(ipAddress, portNumber, initString)",
            "command_return": "connectionID",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function establishes a network connection with another LAN instrument or device through the LAN interface.",
            "details": "This command connects a device to another device through the LAN interface. If the portNumber is 23, the interface uses the Telnet protocol and sets appropriate termination characters to communicate with the device.If a portNumber and initString are provided, it is assumed that the remote device is not TSP\u2011enabled. The Series 3700A does not perform any extra processing, prompt handling, error handling, or sending of commands. In addition, the tspnet.tsp.* commands cannot be used on devices that are not TSP\u2011enabled.If neither a portNumber nor an initString is provided, the remote device is assumed to be a Keithley Instruments TSP\u2011enabled device. Depending on the state of the tspnet.tsp.abortonconnect attribute, the Series 3700A sends an abort command to the remote device on connection. The Series 3700A also enables TSP prompts on the remote device and error management. The Series 3700A places remote errors from the TSP\u2011enabled device in its own error queue and prefaces these errors with Remote Error, followed by an error description. Do not manually change either the prompt functionality (localnode.prompts) or show errors by changing localnode.showerrors on the remote TSP-enabled device. If you do this, subsequent tspnet.tsp.* commands using the connection may fail.You can simultaneously connect to a maximum of 32 remote devices.",
            "param_info": [
                {
                    "name": "connectionID",
                    "description": "The connection ID to be used as a handle in all other tspnet function calls",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": ""
                },
                {
                    "name": "ipAddress",
                    "description": "IP address to which to connect in a string; accepts IP address or host name when trying to connect",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "portNumber",
                    "description": "Port number (default 5025)",
                    "enum": "",
                    "type": "number",
                    "range": "(default 5025)"
                },
                {
                    "name": "initString",
                    "description": "Initialization string to send to ipAddress",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "connectionID = tspnet.connect(ipAddress)",
                "connectionID = tspnet.connect(ipAddress, portNumber, initString)"
            ],
            "overloads": [
                "connectionID = tspnet.connect(ipAddress)"
            ],
            "examples": [
                {
                    "example": "instrumentID = tspnet.connect(\"192.0.2.1\");if instrumentID then;   -- Use instrumentID as needed here;   tspnet.disconnect(instrumentID);end;",
                    "description": "Connect to a TSP-enabled device.\n"
                },
                {
                    "example": "instrumentID = tspnet.connect(\"192.0.2.1\", 1394, \"*rst\\r\\n\");if instrumentID then;   -- Use instrumentID as needed here;   tspnet.disconnect(instrumentID);end;",
                    "description": "Connect to a device that is not TSP\u2011enabled.\n"
                }
            ],
            "related_commands": [
                "localnode.prompts",
                "localnode.showerrors ",
                "tspnet.tsp.abortonconnect",
                "tspnet.disconnect()"
            ]
        },
        {
            "name": "tspnet.disconnect()",
            "webhelpfile": "14076.htm",
            "signature": "tspnet.disconnect(connectionID)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function disconnects a specified TSP-Net session.",
            "details": "This function disconnects the two devices by closing the connection. The connectionID is the session handle returned by tspnet.connect().For TSP-enabled devices, this aborts any remotely running commands or scripts.",
            "param_info": [
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                }
            ],
            "usage": [
                "tspnet.disconnect(connectionID)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testID = tspnet.connect(\"192.0.2.0\");-- Use the connection;tspnet.disconnect(testID);",
                    "description": "Create a TSP\u2011Net session.\n--- --Close the session.\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()"
            ]
        },
        {
            "name": "tspnet.execute()",
            "webhelpfile": "14077.htm",
            "signature": "tspnet.execute(connectionID, commandString, formatString)",
            "command_return": "value1, value2",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function sends a command string to the remote device.",
            "details": "This command sends a command string to the remote instrument. A termination is added to the command string when it is sent to the remote instrument (tspnet.termination()). You can also specify a format string, which causes the command to wait for a response from the remote instrument. The Series 3700A decodes the response message according to the format specified in the format string and returns the message as return values from the function (see tspnet.read() for format specifiers).When this command is sent to a TSP-enabled instrument, the Series 3700A suspends operation until a timeout error is generated or until the instrument responds. The TSP prompt from the remote instrument is read and discarded. The Series 3700A places any remotely generated errors into its error queue. When the optional format string is not specified, this command is equivalent to tspnet.write(), except that a termination is automatically added to the end of the command.",
            "param_info": [
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                },
                {
                    "name": "commandString",
                    "description": "The command to send to the remote device",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "value1",
                    "description": "The first value decoded from the response message",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value2",
                    "description": "The second value decoded from the response message",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "valueN",
                    "description": "The Nth value decoded from the response message; there is one return value for each format specifier in the format string",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more values separated with commas",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "formatString",
                    "description": "Format string for the output",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "tspnet.execute(connectionID, commandString)",
                "value1 = tspnet.execute(connectionID, commandString, formatString)",
                "value1, value2 = tspnet.execute(connectionID, commandString, formatString)",
                "value1, ...= tspnet.execute(connectionID, commandString, formatString)"
            ],
            "overloads": [
                "tspnet.execute(connectionID, commandString)",
                "value1 = tspnet.execute(connectionID, commandString, formatString)",
                "value1, ...= tspnet.execute(connectionID, commandString, formatString)"
            ],
            "examples": [
                {
                    "example": "tspnet.execute(instrumentID, \"runScript()\");",
                    "description": "Command the remote device to run a script named runScript.\n"
                },
                {
                    "example": "tspnet.timeout = 5;id_instr = tspnet.connect(\"192.0.2.23\", 23, \"*rst\\r\\n\");tspnet.termination(id_instr, tspnet.TERM_CRLF);tspnet.execute(id_instr, \"*idn?\");print(\"tspnet.execute returns:\", tspnet.read(id_instr));",
                    "description": "Print the *idn? string from the remote device.\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()",
                "tspnet.read()",
                "tspnet.termination()",
                "tspnet.write()"
            ]
        },
        {
            "name": "tspnet.idn()",
            "webhelpfile": "14078.htm",
            "signature": "tspnet.idn(connectionID)",
            "command_return": "idnString",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function retrieves the response of the remote device to *IDN?.",
            "details": "This function retrieves the response of the remote device to *IDN?.",
            "param_info": [
                {
                    "name": "idnString",
                    "description": "The returned *IDN? string",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                }
            ],
            "usage": [
                "idnString = tspnet.idn(connectionID)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "deviceID = tspnet.connect(\"192.0.2.1\");print(tspnet.idn(deviceID));tspnet.disconnect(deviceID);",
                    "description": "Assume the instrument is at IP address 192.0.2.1.\n--- --The output that is produced when you connect to the instrument and read the identification string may appear as:\n--- --KEITHLEY INSTRUMENTS,MODEL 2470,00000170,1.1.0s\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()"
            ]
        },
        {
            "name": "tspnet.read()",
            "webhelpfile": "14079.htm",
            "signature": "tspnet.read(connectionID, formatString)",
            "command_return": "value1, value2",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function reads data from a remote device.",
            "details": "This command reads available data from the remote instrument and returns responses for the specified number of arguments.The format string can contain the following specifiers:A maximum of 10 format specifiers can be used for a maximum of 10 return values.If formatString is not provided, the command returns a string that contains the data until a new line is reached. If no data is available, the Series 3700A pauses operation until the requested data is available or until a timeout error is generated. Use tspnet.timeout to specify the timeout period.When the Series 3700A reads from a TSP-enabled remote instrument, the Series 3700A removes Test Script Processor (TSP\u00ae) prompts and places any errors it receives from the remote instrument into its own error queue. The Series 3700A prefaces errors from the remote device with \"Remote Error,\" followed by the error number and error description.",
            "param_info": [
                {
                    "name": "value1",
                    "description": "The first value decoded from the response message",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value2",
                    "description": "The second value decoded from the response message",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "valueN",
                    "description": "The nth value decoded from the response message; there is one return value for each format specifier in the format string",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more values separated with commas",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                },
                {
                    "name": "formatString",
                    "description": "Format string for the output, maximum of 10 specifiers",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "value1 = tspnet.read(connectionID)",
                "value1 = tspnet.read(connectionID, formatString)",
                "value1, value2 = tspnet.read(connectionID, formatString)",
                "value1, ...= tspnet.read(connectionID, formatString)"
            ],
            "overloads": [
                "value1 = tspnet.read(connectionID)",
                "value1 = tspnet.read(connectionID, formatString)",
                "value1, ...= tspnet.read(connectionID, formatString)"
            ],
            "examples": [
                {
                    "example": "tspnet.write(deviceID, \"*idn?\\r\\n\");\u00a0;print(\"write/read returns:\", tspnet.read(deviceID));",
                    "description": "Send the \"*idn?\\r\\n\" message to the instrument connected as deviceID.\n--- --Display the response that is read from deviceID (based on the *idn? message).\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()",
                "tspnet.readavailable()",
                "tspnet.timeout",
                "tspnet.write()"
            ]
        },
        {
            "name": "tspnet.readavailable()",
            "webhelpfile": "14080.htm",
            "signature": "tspnet.readavailable(connectionID)",
            "command_return": "bytesAvailable",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function checks to see if data is available from the remote device.",
            "details": "This command checks to see if any output data is available from the device. No data is read from the instrument. This allows TSP scripts to continue to run without waiting on a remote command to finish.",
            "param_info": [
                {
                    "name": "bytesAvailable",
                    "description": "The number of bytes available to be read from the connection",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                }
            ],
            "usage": [
                "bytesAvailable = tspnet.readavailable(connectionID)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "ID = tspnet.connect(\"192.0.2.1\");tspnet.write(ID, \"*idn?\\r\\n\");repeat bytes = tspnet.readavailable(ID) until bytes > 0;print(tspnet.read(ID));tspnet.disconnect(ID);",
                    "description": "Send commands that create data.\n--- --Wait for data to be available.\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()",
                "tspnet.read()"
            ]
        },
        {
            "name": "tspnet.reset()",
            "webhelpfile": "14081.htm",
            "signature": "tspnet.reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function disconnects all TSP-Net sessions.",
            "details": "This command disconnects all remote instruments connected through TSP-Net. For TSP-enabled devices, this causes any commands or scripts running remotely to be terminated.",
            "param_info": [],
            "usage": [
                "tspnet.reset()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "tspnet.termination()",
            "webhelpfile": "14082.htm",
            "signature": "tspnet.termination(connectionID, termSequence)",
            "command_return": "type",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function sets the device line termination sequence.",
            "details": "This function sets and gets the termination character sequence that is used to indicate the end of a line for a TSP-Net connection.Using the termSequence parameter sets the termination sequence. The present termination sequence is always returned.For the termSequence parameter, use the same values listed in the table above for type. There are four possible combinations, all of which are made up of line feeds (LF or 0x10) and carriage returns (CR or 0x13). For TSP-enabled devices, the default is tspnet.TERM_LF. For devices that are not TSP\u2011enabled, the default is tspnet.TERM_CRLF.",
            "param_info": [
                {
                    "name": "type",
                    "description": "An enumerated value indicating the termination type",
                    "enum": "tspnet.TERM_LF4 nil|tspnet.TERM_CR2 nil|tspnet.TERM_CRLF3 nil|tspnet.TERM_LFCR nil",
                    "type": "tspnetterminationtype",
                    "range": ""
                },
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                },
                {
                    "name": "termSequence",
                    "description": "The termination sequence",
                    "enum": "",
                    "type": "tspnetterminationtermSquence",
                    "range": ""
                }
            ],
            "usage": [
                "type = tspnet.termination(connectionID)",
                "type = tspnet.termination(connectionID, termSequence)"
            ],
            "overloads": [
                "type = tspnet.termination(connectionID)"
            ],
            "examples": [
                {
                    "example": "deviceID = tspnet.connect(\"192.0.2.1\");if deviceID then;   tspnet.termination(deviceID, tspnet.TERM_LF);end;",
                    "description": "Sets termination type for IP address 192.0.2.1 to TERM_LF.\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()",
                "tspnet.disconnect()"
            ]
        },
        {
            "name": "tspnet.timeout",
            "webhelpfile": "14084.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "20.0 (20 s)\n",
            "tsp_link": "No\n",
            "description": "This attribute sets the timeout value for the tspnet.connect(), tspnet.execute(), and tspnet.read() commands. ",
            "details": "This attribute sets the amount of time the tspnet.connect(), tspnet.execute(), and tspnet.read() commands wait for a response.The time is specified in seconds. The timeout may be specified to millisecond resolution but is only accurate to the nearest 10\u00a0ms.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The timeout duration in seconds (1\u00a0ms to 30.0\u00a0s)",
                    "enum": "",
                    "type": "number",
                    "range": "(1\u00a0ms to 30.0\u00a0s)"
                }
            ],
            "usage": [
                "value = tspnet.timeout",
                "tspnet.timeout = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tspnet.timeout = 2.0;",
                    "description": "Sets the timeout duration to 2 s.\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()",
                "tspnet.execute()",
                "tspnet.read()"
            ]
        },
        {
            "name": "tspnet.tsp.abort()",
            "webhelpfile": "14085.htm",
            "signature": "tspnet.tsp.abort(connectionID)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function causes the TSP-enabled instrument to stop executing any of the commands that were sent to it.",
            "details": "This function is appropriate only for TSP-enabled instruments.Sends an abort command to the remote instrument.",
            "param_info": [
                {
                    "name": "connectionID",
                    "description": "Integer value used as a handle for other tspnet commands",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": ""
                }
            ],
            "usage": [
                "tspnet.tsp.abort(connectionID)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tspnet.tsp.abort(testConnection);",
                    "description": "Stops remote instrument execution on testConnection.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "tspnet.tsp.abortonconnect",
            "webhelpfile": "14086.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1 (enable)\n",
            "tsp_link": "No\n",
            "description": "This attribute contains the setting for abort on connect to a TSP-enabled instrument.",
            "details": "This setting determines if the instrument sends an abort message when it attempts to connect to a TSP\u2011enabled instrument using the tspnet.connect() function.When you send the abort command on an interface, it causes any other active interface on that instrument to close. If you do not send an abort command (or if tspnet.tsp.abortonconnect is set to 0) and another interface is active, connecting to a TSP\u2011enabled remote instrument results in a connection. However, the instrument does not respond to subsequent reads or executes because control of the instrument is not obtained until an abort command has been sent.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Enable",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                }
            ],
            "usage": [
                "tspnet.tsp.abortonconnect = value",
                "value = tspnet.tsp.abortonconnect"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tspnet.tsp.abortonconnect = 0;",
                    "description": "Configure the instrument so that it does not send an abort command when connecting to a TSP\u2011enabled\u00a0instrument.\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()"
            ]
        },
        {
            "name": "tspnet.write()",
            "webhelpfile": "14089.htm",
            "signature": "tspnet.write(connectionID, inputString)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function writes a string to the remote instrument.",
            "details": "The tspnet.write() function sends inputString to the remote instrument. It does not wait for command completion on the remote instrument.The Series 3700A sends inputString to the remote instrument exactly as indicated. The inputString must contain any necessary new lines, termination, or other syntax elements needed to complete properly.Because tspnet.write() does not process output from the remote instrument, do not send commands that generate too much output without processing the output. This command can stop executing if there is too much unprocessed output from previous commands.",
            "param_info": [
                {
                    "name": "connectionID",
                    "description": "The connection ID returned from tspnet.connect()",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": "()"
                },
                {
                    "name": "inputString",
                    "description": "The string to be written",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "tspnet.write(connectionID, inputString)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tspnet.write(myID, \"runscript()\\r\\n\");",
                    "description": "Commands the remote instrument to execute a command or script named runscript() on a remote device identified in the system as myID.\n"
                }
            ],
            "related_commands": [
                "tspnet.connect()",
                "tspnet.read()"
            ]
        },
        {
            "name": "tspnet.tsp.rbtablecopy()",
            "webhelpfile": "14090.htm",
            "signature": "tspnet.tsp.rbtablecopy(connectionID, name, startIndex, endPointIndex)",
            "command_return": "table",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function copies a reading buffer synchronous table from a remote instrument to a TSP-enabled instrument.",
            "details": "This function is only appropriate for TSP-enabled instruments.This function reads the data from a reading buffer on a remote instrument and returns an array of numbers or a string representing the data. The startIndex and endIndex parameters specify the portion of the reading buffer to read. If no index is specified, the entire buffer is copied. The function returns a table if the table is an array of numbers; otherwise a comma\u2011delimited string is returned.This command is limited to transferring 50,000 readings at a time.",
            "param_info": [
                {
                    "name": "table",
                    "description": "A copy of the synchronous table or a string",
                    "enum": "",
                    "type": "table",
                    "range": ""
                },
                {
                    "name": "connectionID",
                    "description": "Integer value used as a handle for other tspnet commands",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "The full name of the reading buffer name and synchronous table to copy",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "startIndex",
                    "description": "Integer start value",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "endPointIndex",
                    "description": "Integer end value",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "table = tspnet.tsp.rbtablecopy(connectionID, name)",
                "table = tspnet.tsp.rbtablecopy(connectionID, name, startIndex, endPointIndex)"
            ],
            "overloads": [
                "table = tspnet.tsp.rbtablecopy(connectionID, name)"
            ],
            "examples": [
                {
                    "example": "times = tspnet.tsp.rbtablecopy(testTspdevice,;   \"testRemotebuffername.timestamps\", 1, 3);print(times);",
                    "description": "Copy the specified timestamps table for items 1 through 3, then display the table. Example output:\n--- --01/01/2011 10:10:10.0000013,01/01/2011 10:10:10.0000233,01/01/2011 10:10:10.0000576\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "channel.setpowerstate()",
            "webhelpfile": "14135.htm",
            "signature": "channel.setpowerstate(channelList, state)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "Dependent on installed card, but usually 1 (channel.ON)\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the power state on a channel.",
            "details": "When a channel that was previously off is turned on, the channel attributes are reset to their default values (except the power state attribute).Changing the output setting impacts the power consumption of the card. Channels with an off power state consume less power. Before enabling power, the instrument verifies that power is available before changing the state. If insufficient power capability exists, the command generates an error.Consult the specific card documentation for information on a channel\u2019s power usage characteristics, including default state, possible warmup issues, especially for DAC channels, and effects on other channels.When a channel with an off power state is used in a scan, results are undefined. No error notification is issued.For switch, backplane, and digital I/O channels, there is no valid power state attribute. Setting the power state on a specific channel generates an error.On some cards for totalizer channels, setting the power state of a single channel can affect the power state of other channels. If a single totalizer channel is turned on, all totalizer channels are reset to their defaults.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "The channels to set, using standard channel naming",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "state",
                    "description": "channel.OFF or 0",
                    "enum": "channel.OFF 0|channel.ON 1",
                    "type": "channelsetpowerstatestate",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setpowerstate(channelList, state)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setpowerstate(\"1010\", channel.ON);",
                    "description": "Sets the power state for DAC channel 10 on the card in slot 1 to ON, assuming a\u00a03750.\n"
                }
            ],
            "related_commands": [
                "channel.getpowerstate()"
            ]
        },
        {
            "name": "beeper.enable",
            "webhelpfile": "14435.htm",
            "signature": "",
            "command_return": "state",
            "type": "(RW)Attribute (RW)\n",
            "default_value": "1 (beeper.ON)\n",
            "tsp_link": "Yes\n",
            "description": "This command allows you to turn the beeper on or off.",
            "details": "This command enables or disables the beeper. When enabled, a beep signals that a front\u2011panel key has been pressed. Disabling the beeper also disables front\u2011panel key clicks.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Disable the beeper",
                    "enum": "beeper.OFF 0|beeper.ON 1",
                    "type": "beeperenablestate",
                    "range": ""
                }
            ],
            "usage": [
                "state = beeper.enable",
                "beeper.enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "beeper.enable = beeper.ON;beeper.beep(2, 2400);",
                    "description": "Enables the beeper and generates a two\u2011second, 2400\u00a0Hz tone.\n"
                }
            ],
            "related_commands": [
                "beeper.beep()"
            ]
        },
        {
            "name": "channel.calibration.lock()",
            "webhelpfile": "14487.htm",
            "signature": "channel.calibration.lock()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function prevents further calibration on the currently unlocked card.",
            "details": "Calibration data is locked during normal operation. To perform calibration, calibration must be unlocked (channel.calibration.unlock()) for the card.Only one card can be calibrated at a time. Therefore, channel.calibration.lock() works only on the currently unlocked card. Once locked, you must unlock calibration to perform it again.This command locks calibration on the card being calibrated, but does not save calibration data.  An error is generated if this command is issued when calibration is already locked.",
            "param_info": [],
            "usage": [
                "channel.calibration.lock()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.calibration.unlock(\"slot1\",\"KI3706\");-- Perform operations to generate the calibration data;channel.calibration.save();channel.calibration.lock();",
                    "description": "Unlock the card calibration for slot 1 using the default password.\n--- --Use the channel.calibration.step command to generate the calibration data.\n--- --Save the calibration data for the card in slot 1, if no errors occurred while generating the calibration data.\n--- --Lock the calibration data for the card in slot 1.\n"
                }
            ],
            "related_commands": [
                "channel.calibration.save()",
                "channel.calibration.step()",
                "channel.calibration.unlock()"
            ]
        },
        {
            "name": "channel.calibration.unlock()",
            "webhelpfile": "14488.htm",
            "signature": "channel.calibration.unlock(slotX, password)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function unlocks calibration functionality for a card so that calibration operations can be performed.",
            "details": "Calibration data is locked during normal operation. This command enables calibration functionality.  When calibration is completed, calibration functionality must once again be locked (channel.calibration.lock()). Only one card at a time may be unlocked.There is only one password per card. Therefore, the only acceptable values for channel list are \"slot1\", \"slot2\", and so on. Otherwise, an error is generated.An error is generated if the password that is entered does not match the one that was saved with channel.calibration.password().The password can only contain six case-sensitive, alphanumeric characters.The default password from the factory is KI3706.",
            "param_info": [
                {
                    "name": "X",
                    "description": "The slot number ( 1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "( 1 to 6)"
                },
                {
                    "name": "password",
                    "description": "The password that unlocks calibration",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.calibration.unlock(slotX, password)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.calibration.unlock(\"slot1\",\"KI3706\");-- Perform operations to generate the calibration data;channel.calibration.save();channel.calibration.lock();",
                    "description": "Unlock the channel.\n--- --Save the calibration settings.\n--- --Lock the channel.\n"
                }
            ],
            "related_commands": [
                "channel.calibration.lock()",
                "channel.calibration.password()",
                "channel.calibration.save()"
            ]
        },
        {
            "name": "channel.calibration.verifydate()",
            "webhelpfile": "14500.htm",
            "signature": "channel.calibration.verifydate(slotX, date)",
            "command_return": "returnDate",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function gets or sets the date the calibration was verified in UTC format (number of seconds since January 1, 1970).",
            "details": "This command gets the verification date whether calibration is presently locked or unlocked. If the slot is not defined, the unlocked channel is assumed.This command can only set the verification date on a previously unlocked card. The date is not permanently saved until channel.calibration.save() is issued.There is only one verification date per card. If more than one slot is defined, an error is generated.",
            "param_info": [
                {
                    "name": "returnDate",
                    "description": "The verification date returned from the function call",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "X",
                    "description": "The slot number ( 1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "( 1 to 6)"
                },
                {
                    "name": "date",
                    "description": "UTC formatted date to which to set the calibration verification date",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "returnDate = channel.calibration.verifydate(slotX)",
                "returnDate = channel.calibration.verifydate(slotX, date)"
            ],
            "overloads": [
                "returnDate = channel.calibration.verifydate(slotX)"
            ],
            "examples": [
                {
                    "example": "channel.calibration.unlock(\"slot1\", \"KI3706\");print(channel.calibration.verifydate(os.time{year=2010, month=8, day=5}));channel.calibration.save();channel.calibration.lock();print(os.date(\"%m/%d/%Y\", channel.calibration.verifydate(\"slot1\")));",
                    "description": "Unlock the calibration for the card in slot 1 using the default password.\n--- --Set the verify calibration date to August 5, 2010.\n--- --Get the newly set verification date in a user-readable format.\n--- --Save the new verification date.\n--- --Lock the calibration.\n--- --Output:\n--- --1281009600\n--- --08/05/2010\n"
                }
            ],
            "related_commands": [
                "Lua date and time",
                "UTC calculator",
                "channel.calibration.adjustdate()",
                "channel.calibration.save()"
            ]
        },
        {
            "name": "channel.calibration.password()",
            "webhelpfile": "14506.htm",
            "signature": "channel.calibration.password(password)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "KI3706\n",
            "tsp_link": "No\n",
            "description": "This function sets the password needed to unlock the calibration functionality of a card.",
            "details": "There is only one password per card. Therefore, channel.calibration.password() works only on the currently unlocked card.Make note of the password, because there is no command to query for the password once it has been set on the instrument. The password is not permanently saved until the channel.calibration.save() command is sent. Passwords are alphanumeric and case-sensitive.This command generates an error if calibration is locked or if the password string length is greater than six characters.The default password from the factory is KI3706.",
            "param_info": [
                {
                    "name": "password",
                    "description": "A string of characters that contain the password",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.calibration.password(password)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.calibration.unlock(\"slot3\",\"KI3706\");channel.calibration.password(\"Unlock\");channel.calibration.save();channel.calibration.lock();\u00a0;",
                    "description": "Unlock the calibration for the card in slot\u00a03, assuming the default password is still valid.\n--- --Set the password to \"Unlock\" for the card in slot\u00a03.\n--- --Save the password for the card in slot\u00a03 for subsequent unlocks.\n--- --Lock the calibration for the card in slot\u00a03.\n"
                }
            ],
            "related_commands": [
                "channel.calibration.lock()",
                "channel.calibration.unlock()"
            ]
        },
        {
            "name": "channel.calibration.step()",
            "webhelpfile": "14508.htm",
            "signature": "channel.calibration.step(channel, step, value)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sends a calibration command.",
            "details": "The specified channel must be on the unlocked slot. Only DAC and totalizer channels can be calibrated. It is best to calibrate a single channel sequentially to completion before changing channels.The card assumes that the given voltage or current value is exactly what it is sourcing for the given step. This command generates an error if the step is out of sequence, does not exist, or the calibration is locked. Also, an error is generated if the calibration step does not complete successfully, if the value passed is invalid or out of range for the step, or not needed.",
            "param_info": [
                {
                    "name": "channel",
                    "description": "The channel to be calibrated",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "step",
                    "description": "The number corresponding to the specified step",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "The measured value for the specified step when the step value is even",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "channel.calibration.step(channel, step)",
                "channel.calibration.step(channel, step, value)"
            ],
            "overloads": [
                "channel.calibration.step(channel, step)"
            ],
            "examples": [],
            "related_commands": [
                "channel.calibration.lock()",
                "channel.calibration.save()",
                "channel.calibration.unlock()"
            ]
        },
        {
            "name": "bit.bitand()",
            "webhelpfile": "14632.htm",
            "signature": "bit.bitand(value1, value2)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function performs a bitwise logical AND operation on two numbers.",
            "details": "Any fractional parts of value1 and value2 are truncated to form integers. The returned result is also an\u00a0integer.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the logical AND operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value1",
                    "description": "Operand for the logical AND operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value2",
                    "description": "Operand for the logical AND operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "result = bit.bitand(value1, value2)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.bitand(10, 9);print(testResult);",
                    "description": "Performs a logical AND operation on decimal 10 (binary 1010) with decimal 9 (binary 1001), which returns a value of decimal 8 (binary 1000).\n--- --Output:\n--- --8.00000e+00\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.bitor()",
                "bit.bitxor()"
            ]
        },
        {
            "name": "bit.bitor()",
            "webhelpfile": "14634.htm",
            "signature": "bit.bitor(value1, value2)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function performs a bitwise logical OR operation on two numbers.",
            "details": "Any fractional parts of value1 and value2 are truncated to make them integers. The returned result is also an\u00a0integer.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the logical OR operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value1",
                    "description": "Operand for the logical OR operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value2",
                    "description": "Operand for the logical OR operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "result = bit.bitor(value1, value2)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.bitor(10, 9);print(testResult);",
                    "description": "Performs a bitwise logical OR operation on decimal 10 (binary 1010) with decimal 9 (binary 1001), which returns a value of decimal 11 (binary 1011).\n--- --Output:\n--- --1.10000e+01\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.bitand()",
                "bit.bitxor()"
            ]
        },
        {
            "name": "bit.bitxor()",
            "webhelpfile": "14635.htm",
            "signature": "bit.bitxor(value1, value2)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function performs a bitwise logical XOR (exclusive OR) operation on two numbers.",
            "details": "Any fractional parts of value1 and value2 are truncated to make them integers. The returned result is also an integer.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the logical XOR operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value1",
                    "description": "Operand for the logical XOR operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value2",
                    "description": "Operand for the logical XOR operation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "result = bit.bitxor(value1, value2)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.bitxor(10, 9);print(testResult);",
                    "description": "Performs a logical XOR operation on decimal 10 (binary 1010) with decimal 9 (binary 1001), which returns a value of decimal 3 (binary 0011).\n--- --Output:\n--- --3.00000e+00\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.bitand()",
                "bit.bitor()"
            ]
        },
        {
            "name": "bit.clear()",
            "webhelpfile": "14636.htm",
            "signature": "bit.clear(value, index)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function clears a bit at a specified index position.",
            "details": "Any fractional part of value is truncated to make it an integer. The returned result is also an integer.The least significant bit of value is at index position 1; the most significant bit is at index position\u00a032.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the bit manipulation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Specified number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "One\u2011based bit position within value to clear (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                }
            ],
            "usage": [
                "result = bit.clear(value, index)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.clear(15, 2);print(testResult);",
                    "description": "The binary equivalent of decimal 15 is 1111. If you clear the bit at index position 2, the returned decimal value is 13 (binary\u00a01101).\n--- --Output:\n--- --1.30000e+01\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.get()",
                "bit.set()",
                "bit.test()",
                "bit.toggle()"
            ]
        },
        {
            "name": "bit.get()",
            "webhelpfile": "14637.htm",
            "signature": "bit.get(value, index)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function retrieves the weighted value of a bit at a specified index position.",
            "details": "This function returns the value of the bit in value at index. This is the same as returning value with all other bits set to zero\u00a0(0).The least significant bit of value is at index position 1; the most significant bit is at index position\u00a032.If the indexed bit for the number is set to zero (0), the result is zero (0).",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the bit manipulation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Specified number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "One\u2011based bit position within value to get (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                }
            ],
            "usage": [
                "result = bit.get(value, index)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.get(10, 4);print(testResult);",
                    "description": "The binary equivalent of decimal 10 is 1010. If you get the bit at index position 4, the returned decimal value\u00a0is 8.\n--- --Output:\n--- --8.00000e+00\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.clear()",
                "bit.set()",
                "bit.test()",
                "bit.toggle()"
            ]
        },
        {
            "name": "bit.getfield()",
            "webhelpfile": "14638.htm",
            "signature": "bit.getfield(value, index, width)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function returns a field of bits from the value starting at the specified index position.",
            "details": "A field of bits is a contiguous group of bits. This function retrieves a field of bits from value starting at\u00a0index.The index position is the least significant bit of the retrieved field. The number of bits to return is specified by\u00a0width.The least significant bit of value is at index position 1; the most significant bit is at index\u00a0position\u00a032.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the bit manipulation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Specified number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "One\u2011based bit position within value to get (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                },
                {
                    "name": "width",
                    "description": "The number of bits to include in the field (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                }
            ],
            "usage": [
                "result = bit.getfield(value, index, width)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "myResult = bit.getfield(13, 2, 3);print(myResult);",
                    "description": "The binary equivalent of decimal 13 is 1101. \n--- --The field at index position 2 and width 3 consists of the binary bits 110. The returned value is decimal 6 (binary 110).\n--- --Output:\n--- --6.00000e+00\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.get()",
                "bit.set()",
                "bit.setfield()"
            ]
        },
        {
            "name": "bit.set()",
            "webhelpfile": "14639.htm",
            "signature": "bit.set(value, index)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function sets a bit at the specified index position.",
            "details": "This function returns result, which is value with the indexed bit set. The index must be between\u00a01\u00a0and 32.The least significant bit of value is at index position 1; the most significant bit is at index position\u00a032.Any fractional part of value is truncated to make it an integer.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the bit manipulation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Specified number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "One\u2011based bit position within value to set (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                }
            ],
            "usage": [
                "result = bit.set(value, index)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.set(8, 3);\u00a0;print(testResult);",
                    "description": "The binary equivalent of decimal 8 is 1000. If the bit at index position 3 is set to 1, the returned value is decimal 12 (binary\u00a01100).\n--- --Output:\n--- --1.20000e+01\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.clear()",
                "bit.get()",
                "bit.getfield()",
                "bit.setfield()",
                "bit.test()",
                "bit.toggle()"
            ]
        },
        {
            "name": "bit.setfield()",
            "webhelpfile": "14640.htm",
            "signature": "bit.setfield(value, index, width, fieldValue)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function overwrites a bit field at a specified index position.",
            "details": "This function returns result, which is value with a field of bits overwritten, starting at index. The index specifies the position of the least significant bit of value. The width bits starting at index are set to\u00a0fieldValue.The least significant bit of value is at index position 1; the most significant bit is at index position\u00a032.Before setting the field of bits, any fractional parts of value and fieldValue are truncated to form integers.If fieldValue is wider than width, the most significant bits of the fieldValue that exceed the width are truncated. For example, if width is 4 bits and the binary value for fieldValue is 11110 (5\u00a0bits), the most significant bit of fieldValue is truncated and a binary value of 1110 is used.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the bit manipulation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Specified number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "One\u2011based bit position in value to set (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                },
                {
                    "name": "width",
                    "description": "The number of bits to include in the field (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                },
                {
                    "name": "fieldValue",
                    "description": "Value to write to the field",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "result = bit.setfield(value, index, width, fieldValue)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.setfield(15, 2, 3, 5);print(testResult);",
                    "description": "The binary equivalent of decimal 15 is 1111. After overwriting it with a decimal 5 (binary 101) at index position 2, the returned value is decimal 11 (binary 1011).\n--- --Output:\n--- --1.10000e+01\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.get()",
                "bit.set()",
                "bit.getfield()"
            ]
        },
        {
            "name": "bit.test()",
            "webhelpfile": "14641.htm",
            "signature": "bit.test(value, index)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function returns the Boolean value (true or false) of a bit at the specified index position.",
            "details": "This function returns result, which is the result of the tested bit. The least significant bit of value is at index position 1; the most significant bit is at index position\u00a032.If the indexed bit for value is 0, result is false. If the bit of value at index is 1, the returned value is\u00a0true.If index is bigger than the number of bits in value, the result is false.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the bit manipulation",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Specified number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "One\u2011based bit position within value to test (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                }
            ],
            "usage": [
                "result = bit.test(value, index)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.test(10, 4);print(testResult);",
                    "description": "The binary equivalent of decimal 10 is 1010. Testing the bit at index position 4 returns a Boolean value of\u00a0true.\n--- --Output:\n--- --true\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.clear()",
                "bit.get()",
                "bit.set()",
                "bit.toggle()"
            ]
        },
        {
            "name": "bit.toggle()",
            "webhelpfile": "14642.htm",
            "signature": "bit.toggle(value, index)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function toggles the value of a bit at a specified index position.",
            "details": "This function returns result, which is the result of toggling the bit index in value.Any fractional part of value is truncated to make it an integer. The returned value is also an integer.The least significant bit of value is at index position 1; the most significant bit is at index position\u00a032.The indexed bit for value is toggled from 0 to 1, or 1 to 0.",
            "param_info": [
                {
                    "name": "result",
                    "description": "Result of the bit manipulation",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Specified number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "One\u2011based bit position within value to toggle (1 to 32)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 32)"
                }
            ],
            "usage": [
                "result = bit.toggle(value, index)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testResult = bit.toggle(10, 3);print(testResult);",
                    "description": "The binary equivalent of decimal 10 is 1010. Toggling the bit at index position 3 returns a decimal value of 14 (binary\u00a01110).\n--- --Output:\n--- --1.40000e+01\n"
                }
            ],
            "related_commands": [
                "Bit manipulation and logic operations",
                "bit.clear()",
                "bit.get()",
                "bit.set()",
                "bit.test()"
            ]
        },
        {
            "name": "dataqueue.add()",
            "webhelpfile": "14654.htm",
            "signature": "dataqueue.add(value, timeout)",
            "command_return": "result",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function adds an entry to the data queue.",
            "details": "You cannot use the timeout value when accessing the data queue from a remote node (you can only use the timeout value while adding data to the local data queue).The timeout value is ignored if the data queue is not full.The dataqueue.add() function returns false:If the value is a table, a duplicate of the table and any subtables is made. The duplicate table does not contain any references to the original table or to any subtables.",
            "param_info": [
                {
                    "name": "result",
                    "description": "The resulting value of true or false based on the success of the function",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "The data item to add; value can be of any type",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "timeout",
                    "description": "The maximum number of seconds to wait for space in the data queue",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "result = dataqueue.add(value)",
                "result = dataqueue.add(value, timeout)"
            ],
            "overloads": [
                "result = dataqueue.add(value)"
            ],
            "examples": [
                {
                    "example": "dataqueue.clear();dataqueue.add(10);dataqueue.add(11, 2);result = dataqueue.add(12, 3);if result == false then;   print(\"Failed to add 12 to the dataqueue\");end;print(\"The dataqueue contains:\");while dataqueue.count > 0 do;   print(dataqueue.next());end;",
                    "description": "Clear the data queue.\n--- --Each line adds one item to the data queue.\n--- --Output:\n--- --The dataqueue contains:\n--- --10\n--- --11\n--- --12\n"
                }
            ],
            "related_commands": [
                "dataqueue.CAPACITY",
                "dataqueue.clear()",
                "dataqueue.count",
                "dataqueue.next()",
                "Using the data queue for real-time communication"
            ]
        },
        {
            "name": "dataqueue.clear()",
            "webhelpfile": "14655.htm",
            "signature": "dataqueue.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the data queue.",
            "details": "This function forces all dataqueue.add() commands that are in progress to time out and deletes all data from the data queue.",
            "param_info": [],
            "usage": [
                "dataqueue.clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "MaxCount = dataqueue.CAPACITY;while dataqueue.count < MaxCount do;   dataqueue.add(1);end;print(\"There are \" .. dataqueue.count;   .. \" items in the data queue\");dataqueue.clear();print(\"There are \" .. dataqueue.count;   .. \" items in the data queue\");",
                    "description": "This example fills the data queue and prints the number of items in the queue. It then clears the queue and prints the number of items again.\n--- --Output:\n--- --There are 128 items in the dataqueue\n--- --There are 0 items in the data queue\n"
                }
            ],
            "related_commands": [
                "dataqueue.add()",
                "dataqueue.CAPACITY",
                "dataqueue.count",
                "dataqueue.next()",
                "Using the data queue for real-time communication"
            ]
        },
        {
            "name": "dataqueue.CAPACITY",
            "webhelpfile": "14656.htm",
            "signature": "",
            "command_return": "count",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant is the maximum number of entries that you can store in the data queue.",
            "details": "This constant always returns the maximum number of entries that can be stored in the data queue.",
            "param_info": [
                {
                    "name": "count",
                    "description": "The variable that is assigned the value of dataqueue.CAPACITY",
                    "enum": "dataqueue.CAPACITY nil",
                    "type": "dataqueueCAPACITYcount",
                    "range": ""
                }
            ],
            "usage": [
                "count = CAPACITY"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "MaxCount = dataqueue.CAPACITY;while dataqueue.count < MaxCount do;   dataqueue.add(1);end;print(\"There are \" .. dataqueue.count .. \" items in the data queue\");",
                    "description": "This example fills the data queue until it is full and prints the number of items in the queue.\n--- --Output:\n--- --There are 128 items in the data queue\n"
                }
            ],
            "related_commands": [
                "dataqueue.add()",
                "dataqueue.clear()",
                "dataqueue.count",
                "dataqueue.next()",
                "Using the data queue for real-time communication"
            ]
        },
        {
            "name": "dataqueue.count",
            "webhelpfile": "14657.htm",
            "signature": "",
            "command_return": "count",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the number of items in the data queue.",
            "details": "The count is updated as entries are added with dataqueue.add() and read from the data queue with dataqueue.next(). It is also updated when the data queue is cleared with dataqueue.clear().A maximum of dataqueue.CAPACITY items can be stored at any one time in the data queue.",
            "param_info": [
                {
                    "name": "count",
                    "description": "The number of items in the data queue",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "count = dataqueue.count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "MaxCount = dataqueue.CAPACITY;while dataqueue.count < MaxCount do;   dataqueue.add(1);end;print(\"There are \" .. dataqueue.count;   .. \" items in the data queue\");dataqueue.clear();print(\"There are \" .. dataqueue.count;   .. \" items in the data queue\");",
                    "description": "This example fills the data queue and prints the number of items in the queue. It then clears the queue and prints the number of items again.\n--- --Output:\n--- --There are 128 items in the data queue\n--- --There are 0 items in the data queue\n"
                }
            ],
            "related_commands": [
                "dataqueue.add()",
                "dataqueue.CAPACITY",
                "dataqueue.clear()",
                "dataqueue.next()",
                "Using the data queue for real-time communication"
            ]
        },
        {
            "name": "dataqueue.next()",
            "webhelpfile": "14658.htm",
            "signature": "dataqueue.next(timeout)",
            "command_return": "value",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function removes the next entry from the data queue.",
            "details": "If the data queue is empty, the function waits up to the timeout value.If data is not available in the data queue before the timeout expires, the return value is nil.The entries in the data queue are removed in first-in, first-out (FIFO) order.If the value is a table, a duplicate of the original table and any subtables is made. The duplicate table does not contain any references to the original table or to any subtables.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The next entry in the data queue",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "timeout",
                    "description": "The number of seconds to wait for data in the queue",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "value = dataqueue.next()",
                "value = dataqueue.next(timeout)"
            ],
            "overloads": [
                "value = dataqueue.next()"
            ],
            "examples": [
                {
                    "example": "dataqueue.clear();for i = 1, 10 do;   dataqueue.add(i);end;print(\"There are \" .. dataqueue.count .. \" items in the data queue\");\u00a0;while dataqueue.count > 0 do;   x = dataqueue.next();   print(x);end;print(\"There are \" .. dataqueue.count .. \" items in the data queue\");",
                    "description": "Clears the data queue, adds ten entries, then reads the entries from the data queue. Note that your output may differ depending on the setting of format.asciiprecision.\n--- --Output:\n--- --There are 10 items in the data queue\n--- --1\n--- --2\n--- --3\n--- --4\n--- --5\n--- --6\n--- --7\n--- --8\n--- --9\n--- --10\n--- --There are 0 items in the data queue\n"
                }
            ],
            "related_commands": [
                "dataqueue.add()",
                "dataqueue.CAPACITY",
                "dataqueue.clear()",
                "dataqueue.count",
                "format.asciiprecision",
                "Using the data queue for real-time communication"
            ]
        },
        {
            "name": "digio.readbit()",
            "webhelpfile": "14668.htm",
            "signature": "digio.readbit(N)",
            "command_return": "data",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads one digital I/O line. ",
            "details": "A returned value of zero (0) indicates that the line is low. A returned value of one (1) indicates that the line is high.",
            "param_info": [
                {
                    "name": "data",
                    "description": "The state of the I/O line",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Digital I/O line number to be read (1 to 14)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "data = digio.readbit(N)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(digio.readbit(4));",
                    "description": "Assume line 4 is set high, and it is then read.\n--- --Output:\n--- --1.00000e+00\n"
                }
            ],
            "related_commands": [
                "digio.readport()",
                "digio.writebit()",
                "digio.writeport()",
                "Digital I/O port"
            ]
        },
        {
            "name": "digio.readport()",
            "webhelpfile": "14669.htm",
            "signature": "digio.readport()",
            "command_return": "data",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads the digital I/O port. ",
            "details": "The binary equivalent of the returned value indicates the value of the input lines on the I/O port. The least significant bit (bit B1) of the binary number corresponds to line 1; bit B14 corresponds to line 14.For example, a returned value of 170 has a binary equivalent of 000000010101010, which indicates that lines 2, 4, 6, and 8 are high (1), and the other 10 lines are low (0).",
            "param_info": [
                {
                    "name": "data",
                    "description": "The present value of the input lines on the digital I/O port",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "data = digio.readport()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "data = digio.readport();print(data);",
                    "description": "Assume lines 2, 4, 6, and 8 are set high when the I/O port is read.\n--- --Output:\n--- --1.70000e+02\n--- --This is binary 10101010.\n"
                }
            ],
            "related_commands": [
                "digio.readbit()",
                "digio.writebit()",
                "digio.writeport()",
                "Digital I/O port"
            ]
        },
        {
            "name": "digio.trigger[N].assert()",
            "webhelpfile": "14670.htm",
            "signature": "digio.trigger[N].assert()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function asserts a trigger pulse on one of the digital I/O lines. ",
            "details": "The pulse width that is set determines how long the instrument asserts the trigger.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "digio.trigger[N].assert()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[2].assert();",
                    "description": "Asserts a trigger on digital I/O line 2.\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].pulsewidth"
            ]
        },
        {
            "name": "digio.trigger[N].clear()",
            "webhelpfile": "14671.htm",
            "signature": "digio.trigger[N].clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the trigger event on a digital I/O line. ",
            "details": "The event detector of a trigger enters the detected state when an event is detected. It is cleared when digio.trigger[N].wait() or digio.trigger[N].clear() is called.digio.trigger[N].clear() clears the event detector of the specified trigger line, discards the history of the trigger line, and clears the digio.trigger[N].overrun attribute.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "digio.trigger[N].clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[2].clear();",
                    "description": "Clears the trigger event detector on I/O line 2.\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].overrun",
                "digio.trigger[N].wait()"
            ]
        },
        {
            "name": "digio.trigger[N].EVENT_ID",
            "webhelpfile": "14672.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant identifies the trigger event generated by the digital I/O line N. ",
            "details": "To have another trigger object respond to trigger events generated by the trigger line, set the stimulus attribute of the other object to the value of this constant.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The trigger event number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "eventID = digio.trigger[N].EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[5].stimulus = digio.trigger[3].EVENT_ID;",
                    "description": "Uses a trigger event on digital I/O trigger line 3 to be the stimulus for digital I/O trigger line 5.\n"
                },
                {
                    "example": "scan.trigger.arm.stimulus = digio.trigger[3].EVENT_ID;",
                    "description": "Uses a trigger event on digital I/O trigger line 3 to be the stimulus for starting a scan.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "digio.trigger[N].mode",
            "webhelpfile": "14674.htm",
            "signature": "",
            "command_return": "triggerMode",
            "type": "Attribute (RW)\n",
            "default_value": "0 (digio.TRIG_BYPASS)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the mode in which the trigger event detector and the output trigger generator operate on the given trigger line. ",
            "details": "Set triggerMode to one of the following values:When programmed to any mode except digio.TRIG_BYPASS, the output state of the I/O line is controlled by the trigger logic, and the user\u2011specified output state of the line is ignored.Use of either digio.TRIG_SYNCHRONOUSA or digio.TRIG_SYNCHRONOUSM is preferred over digio.TRIG_SYNCHRONOUS, because digio.TRIG_SYNCHRONOUS is provided for compatibility with the digital I/O and TSP-Link triggering on other Keithley Instruments products.To control the line state, set the mode to digio.TRIG_BYPASS and use the digio.writebit() and digio.writeport() commands.",
            "param_info": [
                {
                    "name": "triggerMode",
                    "description": "The trigger mode; see Details for values",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "triggerMode = digio.trigger[N].mode",
                "digio.trigger[N].mode = triggerMode"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[4].mode = 2;",
                    "description": "Sets the trigger mode for I/O line 4 to digio.TRIG_RISING.\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].clear()",
                "digio.trigger[N].reset()",
                "digio.writebit()",
                "digio.writeport()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "digio.trigger[N].overrun",
            "webhelpfile": "14675.htm",
            "signature": "",
            "command_return": "overrun",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the event detector overrun status. ",
            "details": "If this is true, an event was ignored because the event detector was already in the detected state when the event occurred.This is an indication of the state of the event detector built into the line itself. It does not indicate if an overrun occurred in any other part of the trigger model or in any other detector that is monitoring the event.",
            "param_info": [
                {
                    "name": "overrun",
                    "description": "Trigger overrun state (true or false)",
                    "enum": "",
                    "type": "any",
                    "range": "(true or false)"
                },
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "overrun = digio.trigger[N].overrun"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "overrun = digio.trigger[1].overrun;print(overrun);",
                    "description": "If there is no trigger overrun, the following text is output:\n--- --false\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].clear()",
                "digio.trigger[N].reset()"
            ]
        },
        {
            "name": "digio.trigger[N].release()",
            "webhelpfile": "14677.htm",
            "signature": "digio.trigger[N].release()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function releases an indefinite length or latched trigger. ",
            "details": "Releases a trigger that was asserted with an indefinite pulsewidth time. It also releases a trigger that was latched in response to receiving a synchronous mode trigger. Only the specified trigger line is affected.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "digio.trigger[N].release()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[4].release();",
                    "description": "Releases digital I/O trigger line 4.\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].assert()",
                "digio.trigger[N].pulsewidth"
            ]
        },
        {
            "name": "digio.trigger[N].wait()",
            "webhelpfile": "14679.htm",
            "signature": "digio.trigger[N].wait(timeout)",
            "command_return": "triggered",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function waits for a trigger. ",
            "details": "This function pauses trigger operation up to the seconds set by timeout for an input trigger. If one or more trigger events are detected since the last time digio.trigger[N].wait() or digio.trigger[N].clear() was called, this function returns a value immediately. After waiting for a trigger with this function, the event detector is automatically reset and ready to detect the next trigger. This is true regardless of the number of events detected.",
            "param_info": [
                {
                    "name": "triggered",
                    "description": "The value is true if a trigger is detected, or false if no triggers are detected during the timeout period",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 14)"
                },
                {
                    "name": "timeout",
                    "description": "Timeout in seconds",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "triggered = digio.trigger[N].wait(timeout)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "triggered = digio.trigger[4].wait(3);print(triggered);",
                    "description": "Waits up to three seconds for a trigger to be detected on trigger line 4, then outputs the results.\n--- --Output if no trigger is detected:\n--- --false\n--- --Output if a trigger is detected:\n--- --true\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].clear()"
            ]
        },
        {
            "name": "digio.writebit()",
            "webhelpfile": "14680.htm",
            "signature": "digio.writebit(N, data)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets a digital I/O line high or low. ",
            "details": "If the output line is write\u2011protected using the digio.writeprotect attribute, the command is ignored.The reset() function does not affect the present state of the digital I/O lines.Use the digio.writebit() and digio.writeport() commands to control the output state of the synchronization line when trigger operation is set to digio.TRIG_BYPASS.The data must be zero (0) to clear the bit. Any value other than zero (0) sets the bit.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 14)"
                },
                {
                    "name": "data",
                    "description": "The value to write to the bit",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "digio.writebit(N, data)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.writebit(4, 0);",
                    "description": "Sets digital I/O line 4 low (0).\n"
                }
            ],
            "related_commands": [
                "digio.readbit()",
                "digio.readport()",
                "digio.trigger[N].mode",
                "digio.writeport()",
                "digio.writeprotect"
            ]
        },
        {
            "name": "digio.writeport()",
            "webhelpfile": "14681.htm",
            "signature": "digio.writeport(data)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function writes to all digital I/O lines. ",
            "details": "The binary representation of data indicates the output pattern to be written to the I/O port. For example, a data value of 170 has a binary equivalent of 00000010101010. Lines 2, 4, 6, and 8 are set high (1), and the other 10 lines are set low (0).Write\u2011protected lines are not changed.The reset() function does not affect the present states of the digital I/O lines.Use the digio.writebit() and digio.writeport() commands to control the output state of the synchronization line when trigger operation is set to digio.TRIG_BYPASS.",
            "param_info": [
                {
                    "name": "data",
                    "description": "Value to write to the port (0 to 16383)",
                    "enum": "",
                    "type": "number",
                    "range": "(0 to 16383)"
                }
            ],
            "usage": [
                "digio.writeport(data)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.writeport(255);",
                    "description": "Sets digital I/O Lines 1 through 8 high (binary 00000011111111).\n"
                }
            ],
            "related_commands": [
                "digio.readbit()",
                "digio.readport()",
                "digio.writebit()",
                "digio.writeprotect"
            ]
        },
        {
            "name": "digio.writeprotect",
            "webhelpfile": "14682.htm",
            "signature": "",
            "command_return": "mask",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the write\u2011protect mask that protects bits from changes from the digio.writebit() and digio.writeport() functions. ",
            "details": "Bits that are set to one cause the corresponding line to be write\u2011protected.The binary equivalent of mask indicates the mask to be set for the I/O port. For example, a mask value of 7 has a binary equivalent of 00000000000111. This mask write\u2011protects lines 1, 2, and 3.",
            "param_info": [
                {
                    "name": "mask",
                    "description": "Sets the value that specifies the bit pattern for write\u2011protect",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "mask = digio.writeprotect",
                "digio.writeprotect = mask"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.writeprotect = 15;",
                    "description": "Write\u2011protects lines 1, 2, 3, and 4.\n"
                }
            ],
            "related_commands": [
                "digio.writebit()",
                "digio.writeport()"
            ]
        },
        {
            "name": "display.clear()",
            "webhelpfile": "14699.htm",
            "signature": "display.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears all lines of the front\u2011panel display.",
            "details": "This function switches to the user screen and then clears the front\u2011panel display.The display.clear(), display.setcursor(), and display.settext() functions are overlapped commands. That is, the script does not wait for one of these commands to complete. These functions do not immediately update the display. For performance considerations, they update the display as soon as processing time becomes available.",
            "param_info": [],
            "usage": [
                "display.clear()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "display.setcursor()",
                "display.settext()"
            ]
        },
        {
            "name": "display.getcursor()",
            "webhelpfile": "14700.htm",
            "signature": "display.getcursor()",
            "command_return": "row, column, style",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads the present position of the cursor on the front\u2011panel display.",
            "details": "This function switches the front\u2011panel display to the user screen (the text set by display.settext()), and then returns values to indicate the row that contains the cursor and the column position and cursor\u00a0style.Columns are numbered from left to right on the display.",
            "param_info": [
                {
                    "name": "row",
                    "description": "The row where the cursor is",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "column",
                    "description": "The column where the cursor is",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "style",
                    "description": "Visibility of the cursor",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "row, column, style = display.getcursor()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testRow, testColumn = display.getcursor();print(testRow, testColumn);",
                    "description": "This example reads the cursor position into local variables and prints them.\n--- --Example output:\n--- --1.00000e+00     1.00000e+00\n"
                },
                {
                    "example": "print(display.getcursor());",
                    "description": "This example prints the cursor position directly. In this example, the cursor is in row 1 at column 3, with an invisible cursor:\n--- --1.00000e+00   3.00000e+00   0.00000e+00\n"
                }
            ],
            "related_commands": [
                "display.gettext()",
                "display.screen",
                "display.setcursor()",
                "display.settext()"
            ]
        },
        {
            "name": "display.gettext()",
            "webhelpfile": "14702.htm",
            "signature": "display.gettext(embellished, row, columnStart, columnEnd)",
            "command_return": "text",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads the text displayed on the front panel.",
            "details": "Using the command without any parameters returns both lines of the front\u2011panel\u00a0display.The $N character code is included in the returned value to show where the top line ends and the bottom line begins. This is not affected by the value of embellished.When embellished is set to true, all other character codes are returned along with the message. When embellished is set to false, only the message and the $N character code is returned. For information on the embedded character codes, see display.settext().The display is not switched to the user screen (the screen set using display.settext()). Text is read from the active screen.",
            "param_info": [
                {
                    "name": "text",
                    "description": "The returned value, which contains the text that is presently displayed",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "embellished",
                    "description": "Indicates type of returned text",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "row",
                    "description": "Selects the row from which to read the text",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "columnStart",
                    "description": "Selects the first column from which to read text; for row 1, the valid column numbers are 1 to 20; for row 2, the valid column numbers are 1 to 32; if nothing is selected, 1 is used",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "columnEnd",
                    "description": "Selects the last column from which to read text; for row 1, the valid column numbers are 1 to 20; for row 2, the valid column numbers are 1 to 32; the default is 20 for row 1, and 32 for row 2",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "text = display.gettext()",
                "text = display.gettext(embellished)",
                "text = display.gettext(embellished, row)",
                "text = display.gettext(embellished, row, columnStart)",
                "text = display.gettext(embellished, row, columnStart, columnEnd)"
            ],
            "overloads": [
                "text = display.gettext()",
                "text = display.gettext(embellished)",
                "text = display.gettext(embellished, row)",
                "text = display.gettext(embellished, row, columnStart)"
            ],
            "examples": [
                {
                    "example": "display.clear();display.setcursor(1, 1);display.settext(\"ABCDEFGHIJ$DKLMNOPQRST\");display.setcursor(2, 1);display.settext(\"abcdefghijklm$Bnopqrstuvwxyz$F123456\");print(display.gettext());print(display.gettext(true));print(display.gettext(false, 2));print(display.gettext(true, 2, 9));print(display.gettext(false, 2, 9, 10));",
                    "description": "This example shows how to retrieve the display text in multiple ways. The output is:\n--- --\u00a0\n--- --ABCDEFGHIJKLMNOPQRST$Nabcdefghijklmnopqrstuvwxyz123456\n--- --$RABCDEFGHIJ$DKLMNOPQRST$N$Rabcdefghijklm$Bnopqrstuvwxyz$F123456\n--- --abcdefghijklmnopqrstuvwxyz123456\n--- --$Rijklm$Bnopqrstuvwxyz$F123456\n--- --ij\n"
                },
                {
                    "example": "display.clear();display.settext(\"User Screen\");text = display.gettext();print(text);",
                    "description": "This outputs all text in both lines of the display:\n--- --User Screen       $N\n--- --This indicates that the message \u201cUser Screen\u201d is on the top line. The bottom line is blank.\n"
                }
            ],
            "related_commands": [
                "display.clear()",
                "display.getcursor()",
                "display.setcursor()",
                "display.settext()"
            ]
        },
        {
            "name": "display.inputvalue()",
            "webhelpfile": "14703.htm",
            "signature": "display.inputvalue(format, default, minimum, maximum)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function displays a formatted input field on the front\u2011panel display that the operator can edit.",
            "details": "The format parameter uses zeros (0), the decimal point, polarity sign, and exponents to define how the input field is formatted. The format parameter can include the options shown in the following table.The default parameter is the value shown when the value is first displayed.You can use the minimum and maximum parameters to limit the values that can be entered. When + is not selected for format, the minimum limit must be more than or equal to zero (0). When limits are used, you cannot enter values above or below these limits.The input value is limited to \u00b11e37.Before calling display.inputvalue(), you should send a message prompt to the operator using display.prompt(). Make sure to position the cursor where the edit field should appear.After this command is sent, script execution pauses until you enter a value and press the ENTER key.For positive and negative entry (plus sign (+) used for the value field and the exponent field), polarity of a nonzero value or exponent can be toggled by positioning the cursor on the polarity sign and turning the navigation wheel . Polarity is also toggled when using the navigation wheel  to decrease or increase the value or exponent past zero. A zero (0) value or exponent (for example, +00) is always positive and cannot be toggled to negative polarity.After executing this command and pressing the EXIT (LOCAL) key, the function returns nil.",
            "param_info": [
                {
                    "name": "format",
                    "description": "A string that defines how the input field is formatted; see Details for more\u00a0information",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "default",
                    "description": "The default value for the input value",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "minimum",
                    "description": "The minimum input value",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "maximum",
                    "description": "The maximum input value",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "display.inputvalue(format)",
                "display.inputvalue(format, default)",
                "display.inputvalue(format, default, minimum)",
                "display.inputvalue(format, default, minimum, maximum)"
            ],
            "overloads": [
                "display.inputvalue(format)",
                "display.inputvalue(format, default)",
                "display.inputvalue(format, default, minimum)"
            ],
            "examples": [
                {
                    "example": "display.clear();display.settext(\"Enter value between$N  -0.10 and 2.00:  \");value = display.inputvalue(\"+0.00\", 0.5, -0.1, 2.0);print(\"Value entered = \", value);",
                    "description": "Displays an editable field (+0.50) for operator input. The valid input range is \u22120.10 to +2.00, with a default of\u00a00.50.\n--- --Output:\n--- --Value entered =    1.35000e+00\n"
                }
            ],
            "related_commands": [
                "display.prompt()",
                "display.setcursor()",
                "display.settext()"
            ]
        },
        {
            "name": "display.loadmenu.catalog()",
            "webhelpfile": "14705.htm",
            "signature": "for displayName, code in display.loadmenu.catalog() do body end",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates an iterator for the user menu items accessed using the LOAD key on the front panel.",
            "details": "Each time through the loop, displayName and code take on the values in the USER TESTS menu.The instrument goes through the list in random order.",
            "param_info": [
                {
                    "name": "displayName",
                    "description": "The name displayed in the menu",
                    "enum": "",
                    "type": "String",
                    "range": ""
                },
                {
                    "name": "code",
                    "description": "The code associated with the displayName",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "body",
                    "description": "The body of the code to process the entries in the loop",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "for displayName in display.loadmenu.catalog() do body end",
                "for displayName, code in display.loadmenu.catalog() do body end"
            ],
            "overloads": [
                "for displayName in display.loadmenu.catalog() do body end"
            ],
            "examples": [
                {
                    "example": "for displayName, code in display.loadmenu.catalog() do;   print(displayName, code);end;",
                    "description": "Output:\n--- --Test DUT1() beeper.beep(2, 500)\n--- --Part1 testpart([[Part1]], 5.0)\n--- --Test9 Test9()\n"
                }
            ],
            "related_commands": [
                "display.loadmenu.add()",
                "display.loadmenu.delete()"
            ]
        },
        {
            "name": "display.loadmenu.delete()",
            "webhelpfile": "14706.htm",
            "signature": "display.loadmenu.delete(displayName)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function removes an entry from the USER TESTS menu, which can be accessed using the LOAD key on the front\u00a0panel.",
            "details": "If you delete an entry from the USER TESTS menu, you can no longer run it by pressing the LOAD key.",
            "param_info": [
                {
                    "name": "displayName",
                    "description": "The name to be deleted from the USER TESTS menu",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "display.loadmenu.delete(displayName)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "display.loadmenu.delete(\"Test9\");for displayName, code in display.loadmenu.catalog() do;   print(displayName, code);end;",
                    "description": "Deletes the entry named Test9.\n--- --Output:\n--- --Test   DUT1() beeper.beep(2, 500)\n--- --Part1   testpart([[Part1]], 5.0)\n"
                }
            ],
            "related_commands": [
                "display.loadmenu.add()",
                "display.loadmenu.catalog()"
            ]
        },
        {
            "name": "display.locallockout",
            "webhelpfile": "14707.htm",
            "signature": "",
            "command_return": "lockout",
            "type": "Attribute (RW)\n",
            "default_value": "0 (display.UNLOCK)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes whether or not the EXIT (LOCAL) key on the instrument front panel is enabled.",
            "details": "Set display.locallockout to display.LOCK to prevent the user from interrupting remote operation by pressing the EXIT (LOCAL) key.Set this attribute to display.UNLOCK to allow the EXIT (LOCAL) key to interrupt script or remote operation.",
            "param_info": [
                {
                    "name": "lockout",
                    "description": "0 or display.UNLOCK",
                    "enum": "display.UNLOCK nil|display.LOCK nil",
                    "type": "displaylocallockoutlockout",
                    "range": ""
                }
            ],
            "usage": [
                "lockout = display.locallockout",
                "display.locallockout = lockout"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "display.locallockout = display.LOCK;",
                    "description": "Disables the front\u2011panel EXIT (LOCAL) key.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "display.menu()",
            "webhelpfile": "14708.htm",
            "signature": "display.menu(name, items)",
            "command_return": "selection",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function presents a menu on the front\u2011panel display.",
            "details": "The menu consists of the menu name string on the top line, and a selectable list of items on the bottom line. The menu items must be a single string with each item separated by whitespace. The name for the top line is limited to 20 characters.After sending this command, script execution pauses for the operator to select a menu item. An item is selected by rotating the navigation wheel  to place the blinking cursor on the item, and then pressing the navigation wheel  (or the ENTER key). When an item is selected, the text of that selection is returned.Pressing the EXIT (LOCAL) key does not abort the script while the menu is displayed, but it does return nil. The script can be aborted by calling the exit function when nil is returned.",
            "param_info": [
                {
                    "name": "selection",
                    "description": "Name of the variable that holds the selected menu item",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "Menu name to display on the top line",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "items",
                    "description": "Menu items to display on the bottom line",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "selection = display.menu(name, items)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "selection = display.menu(\"Menu\", \"Test1 Test2 Test3\");print(selection);",
                    "description": "Displays a menu with three menu items. If the second menu item is selected, selection is given the value Test2.\n--- --Output:\n--- --Test2\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "display.setcursor()",
            "webhelpfile": "14711.htm",
            "signature": "display.setcursor(row, column, style)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the position of the cursor.",
            "details": "Sending this command selects the user screen and then moves the cursor to the given location.The display.clear(), display.setcursor(), and display.settext() functions are overlapped commands. That is, the script does not wait for one of these commands to complete. These functions do not immediately update the display. For performance considerations, they update the display as soon as processing time becomes available.An out\u2011of-range parameter for row sets the cursor to row 2. An out\u2011of\u2011range parameter for column sets the cursor to column 20 for row 1, or 32 for row 2.An out\u2011of\u2011range parameter for style sets it to 0 (invisible).A blinking cursor is only visible when it is positioned over displayed text. It cannot be seen when positioned over a space character.",
            "param_info": [
                {
                    "name": "row",
                    "description": "The row number for the cursor (1 or 2)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 or 2)"
                },
                {
                    "name": "column",
                    "description": "The active column position to set; row 1 has columns 1 to 20, row 2 has columns 1 to 32",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "style",
                    "description": "Set the cursor to invisible (0, default) or blinking (1)",
                    "enum": "",
                    "type": "number",
                    "range": "(0, default)"
                }
            ],
            "usage": [
                "display.setcursor(row, column)",
                "display.setcursor(row, column, style)"
            ],
            "overloads": [
                "display.setcursor(row, column)"
            ],
            "examples": [
                {
                    "example": "display.clear();display.setcursor(1, 8);display.settext(\"Hello\");display.setcursor(2, 14);display.settext(\"World\");",
                    "description": "This example displays a message on the front panel, approximately center. Note that the top line of text is larger than the bottom line of text.\n--- --The front panel of the instrument displays Hello on the top line and World on the second line.\n"
                }
            ],
            "related_commands": [
                "display.clear()",
                "display.getcursor()",
                "display.gettext()",
                "display.screen",
                "display.settext()"
            ]
        },
        {
            "name": "display.settext()",
            "webhelpfile": "14712.htm",
            "signature": "display.settext(DisplayText, Text)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function displays text on the front\u2011panel user screen.",
            "details": "This function selects the user display screen and displays the given text.After the instrument is turned on, the first time you use a display command to write to the display, the message \"User Screen\" is cleared. After the first write, you need to use display.clear() to clear the message.The display.clear(), display.setcursor(), and display.settext() functions are overlapped commands. That is, the script does not wait for one of these commands to complete. These functions do not immediately update the display. For performance considerations, they update the display as soon as processing time becomes available.The text starts at the present cursor position. After the text is displayed, the cursor is after the last character in the display message.Top line text does not wrap to the bottom line of the display automatically. Any text that does not fit on the current line is truncated. If the text is truncated, the cursor remains at the end of the line.The text remains on the display until replaced or cleared.The character codes described in the following table can also be included in the text string.",
            "param_info": [],
            "usage": [
                "display.settext(DisplayText, Text)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "display.clear();display.settext(\"Normal $BBlinking$N\");display.settext(\"$DDim $FBackgroundBlink$R $$$$ 2 dollars\");",
                    "description": "This example sets the display to:\n--- --Normal Blinking\n--- --Dim BackgroundBlink $$ 2 dollars\n--- --with the named effect on each word.\n"
                }
            ],
            "related_commands": [
                "display.clear()",
                "display.getcursor()",
                "display.gettext()",
                "display.screen",
                "display.setcursor()"
            ]
        },
        {
            "name": "display.trigger.EVENT_ID",
            "webhelpfile": "14716.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant is the event ID of the event generated when the front\u2011panel TRIG key is pressed.",
            "details": "Set the stimulus of any trigger event detector to the value of this constant to have it respond to front-panel trigger key events.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The trigger event number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "eventID = display.EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.channel.stimulus = display.trigger.EVENT_ID;",
                    "description": "Have the channel action of the trigger model be paced by a user pressing the front\u2011panel TRIG key.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.channel.stimulus"
            ]
        },
        {
            "name": "display.getannunciators()",
            "webhelpfile": "14719.htm",
            "signature": "display.getannunciators()",
            "command_return": "annunciators",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads the annunciators (indicators) that are presently turned on.",
            "details": "This function returns a bitmasked value showing which indicators are turned on. The 16\u2011bit binary equivalent of the returned value is the bitmask. The return value is a sum of set annunciators, based on the weighted value, as shown in the following table.",
            "param_info": [
                {
                    "name": "annunciators",
                    "description": "The bitmasked value that shows which indicators are turned on",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "annunciators = display.getannunciators()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testAnnunciators = display.getannunciators();print(testAnnunciators);\u00a0;rem = bit.bitand(testAnnunciators, 1024);if rem > 0 then;   print(\"REM is on\");else;   print(\"REM is off\");end;",
                    "description": "REM indicator is turned on.\n--- --Output:\n--- --1.28000e+03\n--- --REM is on\n"
                },
                {
                    "example": "print(display.ANNUNCIATOR_EDIT);print(display.ANNUNCIATOR_TRIGGER);print(display.ANNUNCIATOR_AUTO);",
                    "description": "Output:\n--- --2.56000e+02\n--- --3.20000e+01\n--- --8.00000e+00\n"
                }
            ],
            "related_commands": [
                "bit.bitand()"
            ]
        },
        {
            "name": "display.prompt()",
            "webhelpfile": "14740.htm",
            "signature": "display.prompt(format, units, help, default, minimum, maximum)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function prompts the user to enter a parameter from the front panel of the instrument.",
            "details": "This function creates an editable input field at the present cursor position, and an input prompt message on the bottom line. Example of a displayed input field and prompt:0.00VInput 0 to +2VThe format parameter uses zeros (0), the decimal point, polarity sign, and exponents to define how the input field is formatted.The format parameter can include the options shown in the following table.You can use the minimum and maximum parameters to limit the values that can be entered. When a plus sign (+) is not selected for format, the minimum limit must be greater than or equal to zero (0). When limits are used, the operator cannot enter values above or below these limits.The input value is limited to \u00b11e37.After sending this command, script execution pauses for the operator to enter a value and press ENTER.For positive and negative entry (plus sign (+) used for the value field and the exponent field), polarity of a nonzero value or exponent can be toggled by positioning the cursor on the polarity sign and turning the navigation wheel . Polarity also toggles when using the navigation wheel  to decrease or increase the value or exponent past zero. A zero value or exponent (for example, +00) is always positive and cannot be toggled to negative polarity.After executing this command and pressing the EXIT (LOCAL) key, the value returns nil.",
            "param_info": [
                {
                    "name": "format",
                    "description": "A string that defines how the input field is formatted; see Details for more\u00a0information",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "units",
                    "description": "Set the units text string for the top line (eight characters maximum); this indicates the units (for example, \"V\" or \"A\") for the value",
                    "enum": "",
                    "type": "string",
                    "range": "(eight characters maximum)"
                },
                {
                    "name": "help",
                    "description": "Text string to display on the bottom line (32 characters maximum)",
                    "enum": "",
                    "type": "string",
                    "range": "(32 characters maximum)"
                },
                {
                    "name": "default",
                    "description": "The value that is shown when the value is first displayed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "minimum",
                    "description": "The minimum input value that can be entered",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "maximum",
                    "description": "The maximum input value that can be entered (must be more than minimum)",
                    "enum": "",
                    "type": "number",
                    "range": "(must be more than minimum)"
                }
            ],
            "usage": [
                "display.prompt(format, units, help)",
                "display.prompt(format, units, help, default)",
                "display.prompt(format, units, help, default, minimum)",
                "display.prompt(format, units, help, default, minimum, maximum)"
            ],
            "overloads": [
                "display.prompt(format, units, help)",
                "display.prompt(format, units, help, default)",
                "display.prompt(format, units, help, default, minimum)"
            ],
            "examples": [
                {
                    "example": "value = display.prompt(\"0.00\", \"V\", \"Input 0 to +2V\", 0.5, 0, 2);print(value);",
                    "description": "The above command prompts the operator to enter a voltage value. The valid input range is 0 to +2.00, with a default of 0.50:\n--- --0.50V\n--- --Input 0 to +2V\n--- --If the operator enters 0.70, the output is:\n--- --7.00000e-01\n"
                }
            ],
            "related_commands": [
                "display.inputvalue()"
            ]
        },
        {
            "name": "display.screen",
            "webhelpfile": "14741.htm",
            "signature": "",
            "command_return": "displayID",
            "type": "Attribute (RW)\n",
            "default_value": "display.MAIN\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the selected display screen.",
            "details": "Setting this attribute selects the display screen for the front panel. This performs the same action as pressing the DISPLAY key on the front panel. The text for the display screen is set by display.settext().Read this attribute to determine which of the available display screens was last selected.",
            "param_info": [
                {
                    "name": "displayID",
                    "description": "One of the following values",
                    "enum": "display.MAIN nil|display.USER nil",
                    "type": "displayscreendisplayID",
                    "range": ""
                }
            ],
            "usage": [
                "displayID = display.screen",
                "display.screen = displayID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "display.screen = display.USER;",
                    "description": "Selects the user display.\n"
                }
            ],
            "related_commands": [
                "display.settext()"
            ]
        },
        {
            "name": "errorqueue.clear()",
            "webhelpfile": "14749.htm",
            "signature": "errorqueue.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears all entries out of the error queue.",
            "details": "",
            "param_info": [],
            "usage": [
                "errorqueue.clear()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "errorqueue.count",
                "errorqueue.next()"
            ]
        },
        {
            "name": "errorqueue.count",
            "webhelpfile": "14750.htm",
            "signature": "",
            "command_return": "count",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute gets the number of entries in the error queue.",
            "details": "",
            "param_info": [
                {
                    "name": "count",
                    "description": "The number of entries in the error queue",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "count = errorqueue.count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "count = errorqueue.count;print(count);",
                    "description": "Returns the number of entries in the error queue.\n--- --The output below indicates that there are four entries in the error queue:\n--- --4.00000e+00\n"
                }
            ],
            "related_commands": [
                "Error Available Bit (Error or Event Queue)",
                "errorqueue.clear()",
                "errorqueue.next()"
            ]
        },
        {
            "name": "eventlog.all()",
            "webhelpfile": "14756.htm",
            "signature": "eventlog.all()",
            "command_return": "logString",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns all entries from the event log as a single string and removes them from the event log.",
            "details": "This function returns all events in the event log. Logged items are shown from oldest to newest. The response is a string that has the messages delimited with a new line character.This function also clears the event log.If there are no entries in the event log, this function returns the value nil.",
            "param_info": [
                {
                    "name": "logString",
                    "description": "A listing of all event log entries",
                    "enum": "",
                    "type": "string|nil",
                    "range": ""
                }
            ],
            "usage": [
                "logString = eventlog.all()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(eventlog.all());",
                    "description": "Get and print all entries from the event log and remove the entries from the log.\n--- --Output:\n--- --17:26:35.690 10 Oct 2019, LAN0, 192.168.1.102, LXI, 0, 1570728395,   1192037155.733269000, 0, 0x0\n--- --17:26:39.009 10 Oct 2019, LAN5, 192.168.1.102, LXI, 0, 1570728399,   1192037159.052777000, 0, 0x0\n"
                }
            ],
            "related_commands": [
                "eventlog.clear()",
                "eventlog.count",
                "eventlog.enable",
                "eventlog.next()",
                "eventlog.overwritemethod"
            ]
        },
        {
            "name": "eventlog.count",
            "webhelpfile": "14757.htm",
            "signature": "",
            "command_return": "N",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the number of unread events in the event log.",
            "details": "",
            "param_info": [
                {
                    "name": "N",
                    "description": "The number of events in the event log",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "N = eventlog.count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(eventlog.count);",
                    "description": "Displays the present number of events in the instrument event log.\n--- --Output looks similar to:\n--- --3.00000e+00\n"
                }
            ],
            "related_commands": [
                "eventlog.all()",
                "eventlog.clear()",
                "eventlog.enable",
                "eventlog.next()",
                "eventlog.overwritemethod"
            ]
        },
        {
            "name": "eventlog.clear()",
            "webhelpfile": "14758.htm",
            "signature": "eventlog.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the event log.",
            "details": "This command removes all messages from the event log.",
            "param_info": [],
            "usage": [
                "eventlog.clear()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "eventlog.all()",
                "eventlog.count",
                "eventlog.enable",
                "eventlog.next()",
                "eventlog.overwritemethod"
            ]
        },
        {
            "name": "eventlog.overwritemethod",
            "webhelpfile": "14759.htm",
            "signature": "",
            "command_return": "method",
            "type": "Attribute (RW)\n",
            "default_value": "1 (eventlog.DISCARD_OLDEST)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute controls how the event log processes events if the event log is full.",
            "details": "When this attribute is set to eventlog.DISCARD_NEWEST, new entries are not logged.When this attribute is set to eventlog.DISCARD_OLDEST, the oldest entry is discarded when a new entry is added.",
            "param_info": [
                {
                    "name": "method",
                    "description": "Set to one of the following values",
                    "enum": "eventlog.DISCARD_NEWEST nil|eventlog.DISCARD_OLDEST nil",
                    "type": "eventlogoverwritemethodmethod",
                    "range": ""
                }
            ],
            "usage": [
                "method = eventlog.overwritemethod",
                "eventlog.overwritemethod = method"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "eventlog.overwritemethod = 0;",
                    "description": "When the log is full, the event log ignores new entries.\n"
                }
            ],
            "related_commands": [
                "eventlog.all()",
                "eventlog.clear()",
                "eventlog.count",
                "eventlog.enable",
                "eventlog.next()"
            ]
        },
        {
            "name": "eventlog.enable",
            "webhelpfile": "14760.htm",
            "signature": "",
            "command_return": "status",
            "type": "Attribute (RW)\n",
            "default_value": "eventlog.ENABLE\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables the event log.",
            "details": "When the event log is disabled (eventlog.DISABLE or 0), no new events are added to the event log. You can, however, read and remove existing events.When the event log is enabled, new events are logged.",
            "param_info": [
                {
                    "name": "status",
                    "description": "The enable status of the event log",
                    "enum": "eventlog.ENABLE nil|eventlog.DISABLE nil",
                    "type": "eventlogenablestatus",
                    "range": ""
                }
            ],
            "usage": [
                "status = eventlog.enable",
                "eventlog.enable = status"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(eventlog.enable);eventlog.enable = eventlog.DISABLE;print(eventlog.enable);",
                    "description": "Displays the present status of the Series 3700A event log.\n--- --Output:\n--- --1.00000e+00\n--- --0.00000e+00\n"
                }
            ],
            "related_commands": [
                "eventlog.all()",
                "eventlog.clear()",
                "eventlog.count",
                "eventlog.next()",
                "eventlog.overwritemethod"
            ]
        },
        {
            "name": "eventlog.next()",
            "webhelpfile": "14761.htm",
            "signature": "eventlog.next()",
            "command_return": "logString",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the oldest unread event message from the event log and removes it from the event log.",
            "details": "Returns the next entry from the event log and removes it from the log.If there are no entries in the event log, returns the value nil.",
            "param_info": [
                {
                    "name": "logString",
                    "description": "The next log entry",
                    "enum": "",
                    "type": "string|nil",
                    "range": ""
                }
            ],
            "usage": [
                "logString = eventlog.next()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(eventlog.next());",
                    "description": "Get the oldest message in the event log and remove that entry from the log.\n--- --Output:\n--- --17:28:22.085 10 Oct 2019, LAN2, 192.168.1.102, LXI, 0, 1570728502, <no time>, 0, 0x0\n"
                },
                {
                    "example": "print(eventlog.next());",
                    "description": "If you send this command when there is nothing in the event log, you get the following output:\n--- --nil\n"
                }
            ],
            "related_commands": [
                "eventlog.all()",
                "eventlog.clear()",
                "eventlog.count",
                "eventlog.enable",
                "eventlog.overwritemethod"
            ]
        },
        {
            "name": "exit()",
            "webhelpfile": "14769.htm",
            "signature": "exit()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function stops a script that is presently running.",
            "details": "Terminates script execution when called from a script that is being executed.This command does not wait for overlapped commands to complete before terminating script execution. If overlapped commands are required to finish, use the waitcomplete() function before calling exit().",
            "param_info": [],
            "usage": [
                "exit()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "waitcomplete()"
            ]
        },
        {
            "name": "fileVar:close()",
            "webhelpfile": "14772.htm",
            "signature": "fileVar:close()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function closes the file that is represented by the fileVar variable.",
            "details": "This command is equivalent to io.close(fileVar).Note that files are automatically closed when the file descriptors are garbage collected.",
            "param_info": [
                {
                    "name": "fileVar",
                    "description": "The file descriptor variable to close",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "fileVar:close()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;print(\"\\n*** fileVar:close\");do;myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\");myfile:close();end;myfile, myfile_err, myfile_errnum = io.open(fileName, \"r\");myfile:close();os.remove(fileName);",
                    "description": "Opens file myfile.txt for writing. If no errors were found while opening, writes Removing file and closes the file.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fileVar:flush()",
                "fileVar:read()",
                "fileVar:seek()",
                "fileVar:write()",
                "io.close()",
                "io.open()"
            ]
        },
        {
            "name": "fileVar:flush()",
            "webhelpfile": "14786.htm",
            "signature": "fileVar:flush()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function writes buffered data to a file.",
            "details": "The fileVar:write() or io.write() functions buffer data, which may not be written immediately to the USB flash drive. Use fileVar:flush() to flush this data. Using this function removes the need to close a file after writing to it, allowing the file to be left open to write more data. Data may be lost if the file is not closed or flushed before a script ends. If there is going to be a time delay before more data is written to a file, and you want to keep the file open, flush the file after you write to it to prevent loss of data.",
            "param_info": [
                {
                    "name": "fileVar",
                    "description": "The file descriptor variable to flush",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "fileVar:flush()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;errorqueue.clear();print(\"\\n*** io.read\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\\n\");myfile:flush();myfile:close();do;fileHandle = io.input(fileName);value = io.read(\"*a\");print(value);end;fileHandle:close();\u00a0;print(errorqueue.next());",
                    "description": "Writes data to a USB flash drive.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fileVar:write()",
                "io.open()",
                "io.write()"
            ]
        },
        {
            "name": "fileVar:read()",
            "webhelpfile": "14787.htm",
            "signature": "fileVar:read(format1, format2)",
            "command_return": "data1, data2",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function reads data from a file.",
            "details": "The format parameters may be any of the following:\"*n\": Returns a number.\"*a\": Returns the whole file, starting at the current position (returns an empty string if the current file position is at the end of the file).\"*l\": Returns the next line, skipping the end of line; returns nil if the current file position is at the end of file.n: Returns a string with up to n characters; returns an empty string if n is zero; returns nil if the current file position is at the end of file.If no format parameters are provided, the function performs as if the function is passed the value \"*l\".Any number of format parameters may be passed to this command, each corresponding to a returned data value.",
            "param_info": [
                {
                    "name": "data1",
                    "description": "First data read from the file",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "data2",
                    "description": "Second data read from the file",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "datan",
                    "description": "Last data read from the file",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "fileVar",
                    "description": "The descriptor of the file to be read",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "format1",
                    "description": "A string or number indicating the first type of data to be read",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "format2",
                    "description": "A string or number indicating the second type of data to be read",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "formatn",
                    "description": "A string or number indicating the last type of data to be read",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more entries (or values) separated by commas",
                    "enum": "",
                    "type": "any",
                    "range": "(or values)"
                }
            ],
            "usage": [
                "data1 = fileVar:read()\t",
                "data1 = fileVar:read(format1)",
                "data1, data2 = fileVar:read(format1, format2)",
                "data1, ...= fileVar:read(format1, ...)"
            ],
            "overloads": [
                "data1 = fileVar:read()\t",
                "data1 = fileVar:read(format1)",
                "data1, ...= fileVar:read(format1, ...)"
            ],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;print(\"fileVar:read\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\");myfile:close();do;myfile, myfile_err, myfile_errnum = io.open(fileName, \"r\");contents = myfile:read(\"*a\");print(contents);end;myfile:close();os.remove(fileName);",
                    "description": "Reads data from the input file.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fileVar:write()",
                "io.input()",
                "io.open()"
            ]
        },
        {
            "name": "fileVar:seek()",
            "webhelpfile": "14788.htm",
            "signature": "fileVar:seek(whence, offset)",
            "command_return": "position, errorMsg",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function sets and gets the present position of a file.",
            "details": "The whence parameters may be any of the following:\"set\": Beginning of file\"cur\": Current position\"end\": End of fileIf an error is encountered, it is logged to the error queue, and the command returns nil and the error\u00a0string.",
            "param_info": [
                {
                    "name": "position",
                    "description": "The new file position, measured in bytes from the beginning of the file",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "errorMsg",
                    "description": "A string containing the error message",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "fileVar",
                    "description": "The file descriptor variable",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "whence",
                    "description": "A string indicating the base against which offset is applied; the default is\u00a0\"cur\"",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "offset",
                    "description": "The intended new position, measured in bytes from a base indicated by whence (default is 0)",
                    "enum": "",
                    "type": "number",
                    "range": "(default is 0)"
                }
            ],
            "usage": [
                "position, errorMsg = fileVar:seek()",
                "position, errorMsg = fileVar:seek(whence)",
                "position, errorMsg = fileVar:seek(whence, offset)"
            ],
            "overloads": [
                "position, errorMsg = fileVar:seek()",
                "position, errorMsg = fileVar:seek(whence)"
            ],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;errorqueue.clear();\u00a0;print(\"\\n*** fileVar:seek\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\");myfile:close();do;myfile, myfile_err, myfile_errnum = io.open(fileName, \"r\");position = myfile:seek(\"end\", -1);print(position);end;myfile:close();os.remove(fileName);",
                    "description": "Get the present position of a file.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "io.open()"
            ]
        },
        {
            "name": "fileVar:write()",
            "webhelpfile": "14789.htm",
            "signature": "fileVar:write(data1, data2)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function writes data to a file.",
            "details": "This function may buffer data until a flush (fileVar:flush() or io.flush()) or close (fileVar:close() or io.close()) operation is performed.",
            "param_info": [
                {
                    "name": "fileVar",
                    "description": "The file descriptor variable",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "data",
                    "description": "Write all data to the file",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "data1",
                    "description": "The first data to write to the file",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "data2",
                    "description": "The second data to write to the file",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "datan",
                    "description": "The last data to write to the file",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more entries (or values) separated by commas",
                    "enum": "",
                    "type": "any",
                    "range": "(or values)"
                }
            ],
            "usage": [
                "fileVar:write(data)",
                "fileVar:write(data1, data2)",
                "fileVar:write(data1, ...)"
            ],
            "overloads": [
                "fileVar:write(data)",
                "fileVar:write(data1, ...)"
            ],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;errorqueue.clear();\u00a0;print(\"\\n*** fileVar:write\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");do;myfile:write(\"Line 1\");end;myfile:close();os.remove(fileName);",
                    "description": "Write data to a file.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fileVar:close()",
                "fileVar:flush()",
                "io.close()",
                "io.flush()",
                "io.open()"
            ]
        },
        {
            "name": "format.asciiprecision",
            "webhelpfile": "14797.htm",
            "signature": "",
            "command_return": "precision",
            "type": "Attribute (RW)\n",
            "default_value": "6\n",
            "tsp_link": "No\n",
            "description": "This attribute sets the precision (number of digits) for all numbers returned in the ASCII format.",
            "details": "This attribute specifies the precision (number of digits) for numeric data printed with the print(), printbuffer(), and printnumber() functions. The format.asciiprecision attribute is only used with the ASCII format. The precision value must be a number from 0 to 16.Note that the precision is the number of significant digits printed. There is always one digit to the left of the decimal point; be sure to include this digit when setting the precision.",
            "param_info": [
                {
                    "name": "precision",
                    "description": "A number representing the number of digits to be printed for numbers printed with the print(), printbuffer(), and printnumber() functions; must be a number between 1 and 16",
                    "enum": "",
                    "type": "number",
                    "range": "()"
                }
            ],
            "usage": [
                "precision = format.asciiprecision",
                "format.asciiprecision = precision"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "format.asciiprecision = 10;x = 2.54;printnumber(x);format.asciiprecision = 3;printnumber(x);",
                    "description": "Output:\n--- --2.540000000e+00\n--- --\u00a0\n--- --2.54e+00\n"
                }
            ],
            "related_commands": [
                "format.byteorder",
                "format.data",
                "print()",
                "printbuffer()",
                "printnumber()"
            ]
        },
        {
            "name": "format.byteorder",
            "webhelpfile": "14801.htm",
            "signature": "",
            "command_return": "order",
            "type": "Attribute (RW)\n",
            "default_value": "format.LITTLEENDIAN\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the binary byte order for the data that is printed using the printnumber() and printbuffer() functions.",
            "details": "This attribute selects the byte order in which data is written when you are printing data values with the printnumber() and printbuffer() functions. The byte order attribute is only used with the format.SREAL, format.REAL, format.REAL32, and format.REAL64 data formats.format.NORMAL, format.BIGENDIAN, and format.NETWORK select the same byte order. format.SWAPPED and format.LITTLEENDIAN select the same byte order. Selecting which to use is a matter of preference.Select the format.SWAPPED or format.LITTLEENDIAN byte order when sending data to a computer with a Microsoft Windows operating system.",
            "param_info": [
                {
                    "name": "order",
                    "description": "Byte order value as follows",
                    "enum": "format.NORMAL nil|format.NETWORK nil|format.BIGENDIANL nil|format.SWAPPED nil|format.LITTLEENDIAN nil",
                    "type": "formatbyteorderorder",
                    "range": ""
                }
            ],
            "usage": [
                "order = format.byteorder",
                "format.byteorder = order"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "x = 1.23;format.data = format.REAL32;format.byteorder = format.LITTLEENDIAN;printnumber(x);format.byteorder = format.BIGENDIAN;printnumber(x);",
                    "description": "The output depends on the terminal program you use, but it looks something like:\n--- --#0\u00a4p??\n--- --#0??p\u00a4\n"
                }
            ],
            "related_commands": [
                "format.asciiprecision",
                "format.data",
                "printbuffer()",
                "printnumber()"
            ]
        },
        {
            "name": "format.data",
            "webhelpfile": "14803.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1 (format.ASCII)\n",
            "tsp_link": "No\n",
            "description": "This attribute sets the data format for data that is printed using the printnumber() and printbuffer() functions.",
            "details": "The precision of numeric values can be controlled with the format.asciiprecision attribute. The byte order of format.SREAL, format.REAL, format.REAL32, and format.REAL64 can be selected with the format.byteorder attribute.REAL32 and SREAL select the same single precision format. REAL and REAL64 select the same double\u2011precision format. They are alternative identifiers. Selecting which to use is a matter of preference.The IEEE Std 754 binary formats use four bytes for single\u2011precision values and eight bytes for double\u2011precision values.When data is written with any of the binary formats, the response message starts with #0 and ends with a new line. When data is written with the ASCII format, elements are separated with a comma and space.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The format to use for data, set to one of the following values",
                    "enum": "format.ASCIIS nil|format.SREAL nil|format.REAL32D nil|format.REAL nil|format.REAL64 nil|format.DREAL nil",
                    "type": "formatdatavalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = format.data",
                "format.data = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "format.asciiprecision = 10;x = 3.14159265;format.data = format.ASCII;printnumber(x);format.data = format.REAL64;printnumber(x);",
                    "description": "Output a number represented by x in ASCII using a precision of 10, then output the same number in binary using double\u2011precision format.\n--- --Output:\n--- --3.141592650e+00\n--- --#0\u00f1\u00d4\u00c8S\u00fb!   @\n"
                }
            ],
            "related_commands": [
                "format.asciiprecision",
                "format.byteorder",
                "printbuffer()",
                "printnumber()"
            ]
        },
        {
            "name": "fs.chdir()",
            "webhelpfile": "14808.htm",
            "signature": "fs.chdir(path)",
            "command_return": "workingDirectory",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the current working directory.",
            "details": "The new working directory path may be absolute or relative to the current working directory.An error is logged to the error queue if the given path does not exist.",
            "param_info": [
                {
                    "name": "workingDirectory",
                    "description": "Returned value containing the working path",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "path",
                    "description": "A string indicating the new working directory path",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "workingDirectory = fs.chdir(path)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "if fs.is_dir(\"/usb1/temp\") == true then;\u00a0 fs.chdir(\"/usb1/temp\");\u00a0 testPath = fs.cwd();\u00a0 print(testPath);else;\u00a0 testPath = fs.cwd();\u00a0 print(testPath);end;",
                    "description": "Insert a USB flash drive into the front panel of the instrument.\n--- --Verify that /usb1/temp is a directory and change it to be the current working directory.\n--- --Set the variable for the current working directory to be testPath.\n--- --The return should be:\n--- --/usb1/temp\n--- --If /usb1/temp is not a directory, set the variable for the current working directory to be testPath.\n--- --The return is:\n--- --/usb1\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "fs.cwd()",
            "webhelpfile": "14810.htm",
            "signature": "fs.cwd()",
            "command_return": "path",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the absolute path of the current working directory.",
            "details": "",
            "param_info": [
                {
                    "name": "path",
                    "description": "The absolute path of the current working directory",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "path = fs.cwd()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "if fs.is_dir(\"/usb1/temp\") == true then;\u00a0 fs.chdir(\"/usb1/temp\");\u00a0 testPath = fs.cwd();\u00a0 print(testPath);else;\u00a0 testPath = fs.cwd();\u00a0 print(testPath);end;",
                    "description": "Insert a USB flash drive into the front panel of the instrument.\n--- --Verify that /usb1/temp is a directory and change it to be the current working directory.\n--- --Set the variable for the current working directory to be testPath.\n--- --The return should be:\n--- --/usb1/temp\n--- --If /usb1/temp is not a directory, set the variable for the current working directory to be testPath.\n--- --The return is:\n--- --/usb1\n"
                }
            ],
            "related_commands": [
                "File I/O"
            ]
        },
        {
            "name": "fs.is_dir()",
            "webhelpfile": "14811.htm",
            "signature": "is_dir(path)",
            "command_return": "status",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function tests whether or not the specified path refers to a directory.",
            "details": "The file system path may be absolute or relative to the current working system path.An error is logged to the error queue if the given path does not exist.",
            "param_info": [
                {
                    "name": "status",
                    "description": "Whether or not the given path is a directory (true or false)",
                    "enum": "",
                    "type": "boolean",
                    "range": "(true or false)"
                },
                {
                    "name": "path",
                    "description": "The path of the file system entry to test",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "status = is_dir(path)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(\"Is directory: \", fs.is_dir(\"/usb1/\"));",
                    "description": "Because /usb1/ is always the root directory of an inserted flash drive, you can use this command to verify that USB flash drive is inserted.\n"
                },
                {
                    "example": "if fs.is_dir(\"/usb1/temp\") == false then;\u00a0\u00a0\u00a0 fs.mkdir(\"/usb1/temp\");end;",
                    "description": "Insert a USB flash drive into the front panel of the instrument.\n--- --Check to see if the temp directory exists.\n--- --If it does not exist, create a directory named temp.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fs.is_file()"
            ]
        },
        {
            "name": "fs.mkdir()",
            "webhelpfile": "14812.htm",
            "signature": "fs.mkdir(newPath)",
            "command_return": "path",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function creates a directory at the specified path.",
            "details": "The directory path may be absolute or relative to the current working directory.An error is logged to the error queue if the parent folder of the new directory does not exist, or if a file system entry already exists at the given path.",
            "param_info": [
                {
                    "name": "path",
                    "description": "The returned path of the new directory",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "newpath",
                    "description": "Location (path) of where to create the new directory",
                    "enum": "",
                    "type": "string",
                    "range": "(path)"
                }
            ],
            "usage": [
                "path = fs.mkdir(newPath)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "if fs.is_dir(\"/usb1/temp\") == false then;\u00a0\u00a0\u00a0 fs.mkdir(\"/usb1/temp\");end;",
                    "description": "Insert a USB flash drive into the front panel of the instrument.\n--- --Check to see if the temp directory exists.\n--- --If it does not exist, create a directory named temp.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fs.rmdir()"
            ]
        },
        {
            "name": "fs.readdir()",
            "webhelpfile": "14814.htm",
            "signature": "fs.readdir(path)",
            "command_return": "files",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns a list of the file system entries in the directory.",
            "details": "The directory path may be absolute or relative to the current working directory.This command is nonrecursive. For example, entries in subfolders are not returned.An error is logged to the error queue if the given path does not exist or does not represent a directory.",
            "param_info": [
                {
                    "name": "files",
                    "description": "A table containing the names of all the file system entries in the specified directory",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "path",
                    "description": "The directory path",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "files = fs.readdir(path)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "rootDirectory = \"/usb1/\";entries = fs.readdir(rootDirectory);count = table.getn(entries);print(\"Found a total of \"..count..\" files and directories\");for i = 1, count do;   print(entries[i]);end;",
                    "description": "Insert a USB flash drive into the front panel of the instrument.\n--- --Set rootDirectory to be the USB port.\n--- --Set entries as the variable for the file system entries in rootDirectory.\n--- --Return the number of files and directories in the directory.\n"
                }
            ],
            "related_commands": [
                "File I/O"
            ]
        },
        {
            "name": "fs.rmdir()",
            "webhelpfile": "14815.htm",
            "signature": "fs.rmdir(path)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function removes a directory from the file system.",
            "details": "This path may be absolute or relative to the present working directory.An error is logged to the error queue if the given path does not exist or does not represent a directory. An error is also logged if the directory is not empty.",
            "param_info": [
                {
                    "name": "path",
                    "description": "The path of the directory to remove",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "fs.rmdir(path)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "rootDirectory = \"/usb1/\";tempDirectoryName = \"temp\";if fs.is_dir(rootDirectory..tempDirectoryName) == false then;\u00a0\u00a0\u00a0 fs.mkdir(rootDirectory..tempDirectoryName);end;fs.rmdir(rootDirectory..tempDirectoryName);",
                    "description": "Insert a USB flash drive into the front panel of the instrument.\n--- --Set rootDirectory to be the USB port.\n--- --Set tempDirectoryName to be equivalent to temp.\n--- --Check to see if tempDirectoryName exists.\n--- --If it does not exist, create a directory named temp.\n--- --Remove the directory.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fs.mkdir()"
            ]
        },
        {
            "name": "fs.is_file()",
            "webhelpfile": "14824.htm",
            "signature": "is_file(path)",
            "command_return": "status",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "Tests whether the specified path refers to a file (as opposed to a directory).",
            "details": "The file system path may be absolute or relative to the current working system path.An error is logged to the error queue if the given path does not exist.",
            "param_info": [
                {
                    "name": "status",
                    "description": "true if the given path is a file; otherwise, false",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "path",
                    "description": "The path of the file system entry to test",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "status = is_file(path)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "rootDirectory = \"/usb1/\";print(\"Is file: \", fs.is_file(rootDirectory));",
                    "description": "Insert a USB flash drive into the front panel of the instrument.\n--- --Set rootDirectory to be the USB port.\n--- --Check to see if rootDirectory is a file. Because rootDirectory was set up as a directory, the return is false.\n"
                }
            ],
            "related_commands": [
                "File I/O",
                "fs.is_dir()"
            ]
        },
        {
            "name": "gpib.address",
            "webhelpfile": "14860.htm",
            "signature": "",
            "command_return": "address",
            "type": "Attribute (RW)\n",
            "default_value": "16\n",
            "tsp_link": "No\n",
            "description": "This attribute contains the GPIB address.",
            "details": "The address can be set to any address value from 1 to 30. However, the address must be unique in the system. It cannot conflict with an address that is assigned to another instrument or to the GPIB controller.A new GPIB address takes effect when the command to change it is processed. If there are response messages in the output queue when this command is processed, they must be read at the new address.If command messages are being queued (sent before this command has executed), the new settings may take effect in the middle of a subsequent command message, so use care when setting this attribute from the GPIB interface.You should allow sufficient time for the command to be processed before attempting to communicate with the instrument again.The reset() function does not affect the GPIB address.",
            "param_info": [
                {
                    "name": "address",
                    "description": "The GPIB address of the instrument (1 to 30)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 30)"
                }
            ],
            "usage": [
                "address = gpib.address",
                "gpib.address = address"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "gpib.address = 26;address = gpib.address;print(address);",
                    "description": "Sets the GPIB address and reads the address.\n--- --Output:\n--- --26\n"
                }
            ],
            "related_commands": [
                "GPIB setup"
            ]
        },
        {
            "name": "io.close()",
            "webhelpfile": "14868.htm",
            "signature": "io.close(file)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes (see Details)\n",
            "description": "This function closes a file.",
            "details": "If a file is not specified, the default output file closes.Only io.close(), used without specifying a parameter, can be accessed from a remote node.",
            "param_info": [
                {
                    "name": "file",
                    "description": "The descriptor of the file to close",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "io.close()",
                "io.close(file)"
            ],
            "overloads": [
                "io.close()"
            ],
            "examples": [
                {
                    "example": "testFile, testError = io.open(\"testfile.txt\", \"w\");if nil == testError then;   testFile:write(\"This is my test file\");   io.close(testFile);end;",
                    "description": "Opens file testfile.txt for writing. If no errors were found while opening, writes \"This is my test file\" and closes the file.\n"
                }
            ],
            "related_commands": [
                "fileVar:close",
                "Script examples",
                "io.open()"
            ]
        },
        {
            "name": "io.flush()",
            "webhelpfile": "14870.htm",
            "signature": "io.flush()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function saves buffered data to a file.",
            "details": "You must use the io.flush() or io.close() functions to write data to the file system.This function only flushes the default output file.Using this command removes the need to close a file after writing to it and allows it to be left open to write more data. Data may be lost if the file is not closed or flushed before an application ends. To prevent the loss of data if there is going to be a time delay before more data is written (and when you want to keep the file open and not close it), flush the file after writing to it.",
            "param_info": [],
            "usage": [
                "io.flush()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "Script examples",
                "fileVar:flush()",
                "fileVar:write()",
                "io.write()"
            ]
        },
        {
            "name": "io.open()",
            "webhelpfile": "14872.htm",
            "signature": "io.open(path, mode)",
            "command_return": "fileVar, errorMsg",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function opens a file for later reference.",
            "details": "The path to the file to open may be absolute or relative to the current working directory. If you successfully open the file, errorMsg is nil and fileVar has the descriptor used to access the file.If an error is encountered, the command returns nil for fileVar and an error string.",
            "param_info": [
                {
                    "name": "fileVar",
                    "description": "The descriptor of the opened file",
                    "enum": "",
                    "type": "io_object",
                    "range": ""
                },
                {
                    "name": "errorMsg",
                    "description": "Indicates whether an error was encountered while processing the function",
                    "enum": "",
                    "type": "string|nil",
                    "range": ""
                },
                {
                    "name": "path",
                    "description": "The path of the file to open",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "mode",
                    "description": "A string representing the intended access mode (\"r\" = read, \"w\"\u00a0=\u00a0write, and \"a\" = append)",
                    "enum": "",
                    "type": "string",
                    "range": "(\"r\" = read, \"w\"\u00a0=\u00a0write, and \"a\" = append)"
                }
            ],
            "usage": [
                "fileVar, errorMsg = io.open(path)",
                "fileVar, errorMsg = io.open(path, mode)"
            ],
            "overloads": [
                "fileVar, errorMsg = io.open(path)"
            ],
            "examples": [
                {
                    "example": "testFile, testError = io.open(\"testfile.txt\", \"w\");if testError == nil then;   testFile:write(\"This is my test file\");   io.close(testFile);end;",
                    "description": "Opens file testfile.txt for writing. If no errors were found while opening, writes \"This is my test file\" and closes the file.\n"
                }
            ],
            "related_commands": [
                "Script examples",
                "fileVar:close()",
                "io.close()"
            ]
        },
        {
            "name": "io.output()",
            "webhelpfile": "14873.htm",
            "signature": "io.output(newfile)",
            "command_return": "fileVar",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes (see Details)\n",
            "description": "This function assigns a previously opened file or opens a new file as the default output file.",
            "details": "The path of the file to open may be absolute or relative to the current working directory.When accessed from a remote node using the TSP-Link network, this command does not accept a file descriptor parameter and does not return a value.If the function fails, an error message is returned.",
            "param_info": [
                {
                    "name": "fileVar",
                    "description": "The descriptor of the output file or an error message (if the function fails)",
                    "enum": "",
                    "type": "io_object",
                    "range": "(if the function fails)"
                },
                {
                    "name": "newfile",
                    "description": "A file descriptor to assign (or the path of a file to open) as the default output\u00a0file",
                    "enum": "",
                    "type": "string",
                    "range": "(or the path of a file to open)"
                }
            ],
            "usage": [
                "fileVar = io.output()",
                "fileVar = io.output(newfile)"
            ],
            "overloads": [
                "fileVar = io.output()"
            ],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;errorqueue.clear();\u00a0;print(\"\\n*** io.output\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\");myfile:close();do;fileHandle = io.output(fileName);print(fileHandle);end;io.close(fileHandle);print(fileHandle);os.remove(fileName);",
                    "description": "Assign the file to be the default output file.\n"
                }
            ],
            "related_commands": [
                "Script examples",
                "io.input()",
                "io.open()"
            ]
        },
        {
            "name": "io.read()",
            "webhelpfile": "14874.htm",
            "signature": "io.read(format1, format2)",
            "command_return": "data1, data2",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads data from the default input file.",
            "details": "The format parameters may be any of the following:Any number of format parameters may be passed to this command, each corresponding to a returned data value.",
            "param_info": [
                {
                    "name": "data1",
                    "description": "The data read from the file",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "data2",
                    "description": "The data read from the file",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "dataN",
                    "description": "The data read from the file; the number of return values matches the number of format values given",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "format1",
                    "description": "A string or number indicating the type of data to be read",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "format2",
                    "description": "A string or number indicating the type of data to be read",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "formatN",
                    "description": "A string or number indicating the type of data to be read",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more entries (or values) separated by commas",
                    "enum": "",
                    "type": "any",
                    "range": "(or values)"
                }
            ],
            "usage": [
                "data1 = io.read()",
                "data1 = io.read(format1)",
                "data1, data2 = io.read(format1, format2)",
                "data1, ...= io.read(format1, ...)"
            ],
            "overloads": [
                "data1 = io.read()",
                "data1 = io.read(format1)",
                "data1, ...= io.read(format1, ...)"
            ],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;errorqueue.clear();\u00a0;-- io.read;print(\"\\n*** io.read\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\\n\");myfile:flush();myfile:close();do;fileHandle = io.input(fileName);value = io.read(\"*a\");print(value);end;fileHandle:close();\u00a0;print(errorqueue.next());",
                    "description": "Read data from the default input file.\n"
                }
            ],
            "related_commands": [
                "fileVar:read()",
                "Script examples"
            ]
        },
        {
            "name": "io.type()",
            "webhelpfile": "14875.htm",
            "signature": "io.type(obj)",
            "command_return": "type",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function checks whether or not a given object is a file handle.",
            "details": "Returns the string \"file\" if the object is an open file handle. If it is not an open file handle, nil is returned.",
            "param_info": [
                {
                    "name": "type",
                    "description": "Indicates whether the object is an open file handle",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "obj",
                    "description": "Object to check",
                    "enum": "",
                    "type": "file_object",
                    "range": ""
                }
            ],
            "usage": [
                "type = io.type(obj)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;errorqueue.clear();\u00a0;print(\"\\n*** io.type\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\");myfile:close();do;fileHandle = io.output(fileName);state = io.type(fileHandle);print(state);end;io.close(fileHandle);local state = io.type(fileHandle);print(state);os.remove(fileName);",
                    "description": "Check whether or not fileName is a file handle.\n"
                }
            ],
            "related_commands": [
                "Script examples",
                "io.open()"
            ]
        },
        {
            "name": "io.write()",
            "webhelpfile": "14877.htm",
            "signature": "io.write(data1, data2)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function writes data to the default output file.",
            "details": "All data parameters must be either strings or numbers.",
            "param_info": [
                {
                    "name": "data1",
                    "description": "The data to be written",
                    "enum": "",
                    "type": "string|number",
                    "range": ""
                },
                {
                    "name": "data2",
                    "description": "The data to be written",
                    "enum": "",
                    "type": "string|number",
                    "range": ""
                },
                {
                    "name": "dataN",
                    "description": "The data to be written",
                    "enum": "",
                    "type": "string|number",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more values separated by commas",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "io.write()",
                "io.write(data1)",
                "io.write(data1, data2)",
                "io.write(data1, ...)"
            ],
            "overloads": [
                "io.write()",
                "io.write(data1)",
                "io.write(data1, ...)"
            ],
            "examples": [
                {
                    "example": "local fileName = \"/usb1/myfile.txt\";\u00a0;if fs.is_file(fileName) then;\tos.remove(fileName);\tprint(\"Removing file\");else;\tprint(\"Nothing removed\");end;\u00a0;errorqueue.clear();\u00a0;print(\"\\n*** io.write\");myfile, myfile_err, myfile_errnum = io.open(fileName, \"w\");myfile:write(\"Line 1\");myfile:close();do;fileHandle = io.output(fileName);io.write(\"Line 2\");end;io.close(fileHandle);os.remove(fileName);",
                    "description": "Writes data to the default output file.\n"
                }
            ],
            "related_commands": [
                "Script examples",
                "io.flush()"
            ]
        },
        {
            "name": "lan.applysettings()",
            "webhelpfile": "14890.htm",
            "signature": "lan.applysettings()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function re-initializes the LAN interface with new settings.",
            "details": "Disconnects all existing LAN connections to the instrument and re-initializes the LAN with the present configuration\u00a0settings.This function initiates a background operation. LAN configuration could be a lengthy operation. Although the function returns immediately, the LAN initialization continues to run in the background.Even though the LAN configuration settings may not have changed since the LAN was last connected, new settings may take effect due to the dynamic nature of dynamic host configuration protocol (DHCP) or dynamic link local addressing (DLLA) configuration.Re-initialization takes effect even if the configuration has not changed since the last time the instrument connected to the\u00a0LAN.",
            "param_info": [],
            "usage": [
                "lan.applysettings()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.applysettings();",
                    "description": "Re-initialize the LAN interface with new settings.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.lxidomain",
            "webhelpfile": "14893.htm",
            "signature": "",
            "command_return": "domain",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LXI domain.",
            "details": "This attribute sets the LXI domain number.All outgoing LXI packets are generated with this domain number. All inbound LXI packets are ignored unless they have this domain number.",
            "param_info": [
                {
                    "name": "domain",
                    "description": "The LXI domain number (0 to 255)",
                    "enum": "",
                    "type": "number",
                    "range": "(0 to 255)"
                }
            ],
            "usage": [
                "domain = lan.lxidomain",
                "lan.lxidomain = domain"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.lxidomain);",
                    "description": "Displays the LXI domain.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.nagle",
            "webhelpfile": "14894.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (lan.DISABLE)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute controls the state of the LAN Nagle algorithm.",
            "details": "This attribute enables or disables the use of the LAN Nagle algorithm on transmission control protocol (TCP) connections.",
            "param_info": [
                {
                    "name": "state",
                    "description": "The state of the Nagle algorithm",
                    "enum": "lan.ENABLE nil|lan.DISABLE nil",
                    "type": "lannaglestate",
                    "range": ""
                }
            ],
            "usage": [
                "state = lan.nagle",
                "lan.nagle = state"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "lan.restoredefaults()"
            ]
        },
        {
            "name": "lan.reset()",
            "webhelpfile": "14895.htm",
            "signature": "lan.reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets the LAN interface.",
            "details": "This function resets the LAN interface. It performs the commands lan.restoredefaults() and lan.applysettings(). It also resets the LAN password.",
            "param_info": [],
            "usage": [
                "lan.reset()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "lan.applysettings()",
                "lan.restoredefaults()",
                "localnode.password"
            ]
        },
        {
            "name": "lan.restoredefaults()",
            "webhelpfile": "14896.htm",
            "signature": "lan.restoredefaults()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets LAN settings to default values.",
            "details": "The settings that are restored are shown in the following table.The lan.restoredefaults() function does not reset the LAN password. The localnode.password attribute controls the web password, which can be reset separately.This command is run when lan.reset() is sent.",
            "param_info": [],
            "usage": [
                "lan.restoredefaults()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.restoredefaults();",
                    "description": "Restores the LAN defaults.\n"
                }
            ],
            "related_commands": [
                "lan.reset()",
                "localnode.password"
            ]
        },
        {
            "name": "lan.config.dns.address[N]",
            "webhelpfile": "14898.htm",
            "signature": "",
            "command_return": "dnsAddress",
            "type": "Attribute (RW)\n",
            "default_value": "\"0.0.0.0\"\n",
            "tsp_link": "Yes\n",
            "description": "Configures DNS server IP addresses.",
            "details": "This attribute is an array of Domain Name System (DNS) server addresses. These addresses take priority for DNS lookups and are consulted before any server addresses that are obtained using DHCP. This allows local DNS servers to be specified that take priority over DHCP\u2011configured global DNS servers.You can specify up to two addresses. The address specified by 1 is consulted first for DNS lookups. dnsAddress must be a string specifying the IP address of the DNS server in dotted decimal notation.Unused entries are returned as \"0.0.0.0\" when read. To disable an entry, set its value to \"0.0.0.0\" or the empty string\u00a0\"\".Although only two addresses may be manually specified here, the instrument uses up to three DNS server addresses. If two are specified here, only one that is given by a DHCP server is used. If no entries are specified here, up to three addresses that are given by a DHCP server are used.",
            "param_info": [
                {
                    "name": "dnsAddress",
                    "description": "DNS server IP address",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Entry index (1 or 2)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 or 2)"
                }
            ],
            "usage": [
                "dnsAddress = lan.config.dns.address[N]",
                "lan.config.dns.address[N] = dnsAddress"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dnsaddress = \"164.109.48.173\";lan.config.dns.address[1] = dnsaddress;",
                    "description": "Set the DNS address 1 to 164.109.48.173.\n"
                }
            ],
            "related_commands": [
                "lan.config.dns.domain",
                "lan.config.dns.dynamic",
                "lan.config.dns.hostname",
                "lan.config.dns.verify",
                "lan.restoredefaults()"
            ]
        },
        {
            "name": "lan.config.dns.domain",
            "webhelpfile": "14899.htm",
            "signature": "",
            "command_return": "domain",
            "type": "Attribute (RW)\n",
            "default_value": "\"\"\n",
            "tsp_link": "Yes\n",
            "description": "Configures the dynamic DNS domain.",
            "details": "This attribute holds the domain to request during dynamic DNS registration. Dynamic DNS registration works with DHCP to register the domain specified in this attribute with the DNS server.The length of the fully qualified host name (combined length of the domain and host name with separator characters) must be less than or equal to 255 characters. Although up to 255 characters are allowed, you must make sure the combined length is also no more than 255 characters.",
            "param_info": [
                {
                    "name": "domain",
                    "description": "Dynamic DNS registration domain; use a string of 255 characters or less",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "domain = lan.config.dns.domain",
                "lan.config.dns.domain = domain"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.config.dns.domain);",
                    "description": "Outputs the present dynamic DNS domain. For example, if the domain is \"Matrix\", the response is:\n--- --Matrix\n"
                }
            ],
            "related_commands": [
                "lan.config.dns.dynamic",
                "lan.config.dns.hostname",
                "lan.config.dns.verify",
                "lan.restoredefaults()"
            ]
        },
        {
            "name": "lan.config.dns.dynamic",
            "webhelpfile": "14900.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "1 (lan.ENABLE)\n",
            "tsp_link": "Yes\n",
            "description": "Enables or disables the dynamic DNS registration.",
            "details": "Dynamic DNS registration works with DHCP to register the host name with the DNS server. The host name is specified in the lan.config.dns.hostname attribute.",
            "param_info": [
                {
                    "name": "state",
                    "description": "The dynamic DNS registration state. It may be one of the following values",
                    "enum": "lan.ENABLE nil|lan.DISABLE nil",
                    "type": "lanconfigdnsdynamicstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = lan.config.dns.dynamic",
                "lan.config.dns.dynamic = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.config.dns.dynamic);",
                    "description": "Outputs the dynamic registration state.\n--- --If dynamic DNS registration is enabled, the response is:\n--- --1.00000e+00\n"
                }
            ],
            "related_commands": [
                "lan.config.dns.hostname",
                "lan.restoredefaults()"
            ]
        },
        {
            "name": "lan.config.dns.verify",
            "webhelpfile": "14902.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "1 (lan.ENABLE)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the DNS host name verification state.",
            "details": "When this is enabled, the instrument performs DNS lookups to verify that the DNS host name matches the value specified by lan.config.dns.hostname.",
            "param_info": [
                {
                    "name": "state",
                    "description": "DNS hostname verification state",
                    "enum": "lan.ENABLE nil|lan.DISABLE nil",
                    "type": "lanconfigdnsverifystate",
                    "range": ""
                }
            ],
            "usage": [
                "state = lan.config.dns.verify",
                "lan.config.dns.verify = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.config.dns.verify);",
                    "description": "Outputs the present DNS host name verification state.\n--- --If it is enabled, the output is:\n--- --1.00000e+00\n"
                }
            ],
            "related_commands": [
                "lan.config.dns.hostname",
                "lan.restoredefaults()"
            ]
        },
        {
            "name": "lan.config.gateway",
            "webhelpfile": "14904.htm",
            "signature": "",
            "command_return": "gatewayAddress",
            "type": "Attribute (RW)\n",
            "default_value": "\"0.0.0.0\"\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN default gateway address.",
            "details": "This attribute specifies the default gateway IP address to use when manual or DLLA configuration methods are used to configure the LAN. If DHCP is enabled, this setting is ignored.This attribute does not indicate the actual setting that is presently in effect. Use the lan.status.gateway attribute to determine the present operating state of the\u00a0LAN.The IP address must be formatted in four groups of numbers, each separated by a\u00a0decimal.",
            "param_info": [
                {
                    "name": "gatewayAddress",
                    "description": "LAN default gateway address; must be a string specifying the default IP address of the gateway in dotted decimal notation",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "gatewayAddress = lan.config.gateway",
                "lan.config.gateway = gatewayAddress"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.config.gateway);",
                    "description": "Outputs the default gateway address. For example, you might see the output:\n--- --192.168.0.1\n"
                }
            ],
            "related_commands": [
                "lan.restoredefaults()",
                "lan.status.gateway"
            ]
        },
        {
            "name": "lan.config.ipaddress",
            "webhelpfile": "14905.htm",
            "signature": "",
            "command_return": "ipAddress",
            "type": "Attribute (RW)\n",
            "default_value": "\"192.168.0.2\"\n",
            "tsp_link": "Yes\n",
            "description": "This command specifies the LAN IP address.",
            "details": "This command specifies the LAN IP address to use when the LAN is configured using the manual configuration method. This setting is ignored when DLLA or DHCP is used. This attribute does not indicate the actual setting that is presently in effect. Use the lan.status.ipaddress attribute to determine the present operating state of the LAN.",
            "param_info": [
                {
                    "name": "ipAddress",
                    "description": "LAN IP address; must be a string specifying the IP address in dotted decimal notation",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "ipAddress = lan.config.ipaddress",
                "lan.config.ipaddress = ipAddress"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "ipaddress = lan.config.ipaddress;",
                    "description": "Retrieves the presently set LAN IP address.\n"
                }
            ],
            "related_commands": [
                "lan.restoredefaults()",
                "lan.status.ipaddress"
            ]
        },
        {
            "name": "lan.config.method",
            "webhelpfile": "14906.htm",
            "signature": "",
            "command_return": "method",
            "type": "Attribute (RW)\n",
            "default_value": "0 (lan.AUTO)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN settings configuration method.",
            "details": "This attribute controls how the LAN IP address, subnet mask, default gateway address, and DNS server addresses are\u00a0determined.When method is lan.AUTO, the instrument first attempts to configure the LAN settings using dynamic host configuration protocol (DHCP). If DHCP fails, it tries dynamic link local addressing (DLLA). If DLLA fails, it uses the manually specified\u00a0settings.When method is lan.MANUAL, only the manually specified settings are used. Neither DHCP nor DLLA are attempted.",
            "param_info": [
                {
                    "name": "method",
                    "description": "The method for configuring LAN settings; it can be one of the following values",
                    "enum": "lan.AUTO nil|lan.MANUAL nil",
                    "type": "lanconfigmethodmethod",
                    "range": ""
                }
            ],
            "usage": [
                "method = lan.config.method",
                "lan.config.method = method"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.config.method);",
                    "description": "Outputs the present method.\n--- --For example:\n--- --1.00000e+00\n"
                }
            ],
            "related_commands": [
                "lan.restoredefaults()"
            ]
        },
        {
            "name": "lan.config.subnetmask",
            "webhelpfile": "14908.htm",
            "signature": "",
            "command_return": "mask",
            "type": "Attribute (RW)\n",
            "default_value": "\"255.255.255.0\"\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN subnet mask.",
            "details": "This attribute specifies the LAN subnet mask that is used when the manual configuration method is used to configure the LAN. This setting is ignored when DLLA or DHCP is used.This attribute does not indicate the actual setting presently in effect. Use the lan.status.subnetmask attribute to determine the present operating state of the LAN.",
            "param_info": [
                {
                    "name": "mask",
                    "description": "String that specifies the LAN subnet mask value in dotted decimal notation",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "mask = lan.config.subnetmask",
                "lan.config.subnetmask = mask"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.config.subnetmask);",
                    "description": "Outputs the LAN subnet mask, such as:\n--- --255.255.255.0\n"
                }
            ],
            "related_commands": [
                "lan.restoredefaults()",
                "lan.status.subnetmask"
            ]
        },
        {
            "name": "lan.status.dns.address[N]",
            "webhelpfile": "14909.htm",
            "signature": "",
            "command_return": "dnsAddress",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the DNS server IP addresses.",
            "details": "This attribute is an array of DNS server addresses. The instrument can use up to three addresses.Unused or disabled entries are returned as \"0.0.0.0\" when read. The dnsAddress returned is a string specifying the IP address of the DNS server in dotted decimal notation.You can only specify two addresses manually. However, the instrument uses up to three DNS server addresses. If two are specified, only the one given by a DHCP server is used. If no entries are specified, up to three address given by a DHCP server are used.The value of lan.status.dns.address[1] is referenced first for all DNS lookups. The values of lan.status.dns.address[2] and lan.status.dns.address[3] are referenced second and third, respectively.",
            "param_info": [
                {
                    "name": "dnsAddress",
                    "description": "DNS server IP address",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Entry index (1, 2, or 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1, 2, or 3)"
                }
            ],
            "usage": [
                "dnsAddress = lan.status.dns.address[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.dns.address[1]);",
                    "description": "Outputs DNS server address 1, for\u00a0example:\n--- --164.109.48.173\n"
                }
            ],
            "related_commands": [
                "lan.status.dns.name"
            ]
        },
        {
            "name": "lan.status.dns.name",
            "webhelpfile": "14910.htm",
            "signature": "",
            "command_return": "hostName",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the present DNS fully qualified host name.",
            "details": "A fully qualified domain name (FQDN) specifies its exact location in the tree hierarchy of the Domain Name System (DNS).A FQDN is the complete domain name for a specific computer or host on the LAN. The FQDN consists of two parts: The host name and the domain name.If the DNS host name for an instrument is not found, this attribute stores the IP address in dotted decimal notation.",
            "param_info": [
                {
                    "name": "hostName",
                    "description": "Fully qualified DNS host name that can be used to connect to the instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "hostName = lan.status.dns.name"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.dns.name);",
                    "description": "Outputs the dynamic DNS host name.\n"
                }
            ],
            "related_commands": [
                "lan.config.dns.address[N]",
                "lan.config.dns.hostname"
            ]
        },
        {
            "name": "lan.status.duplex",
            "webhelpfile": "14911.htm",
            "signature": "",
            "command_return": "duplex",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the duplex mode presently in use by the LAN interface.",
            "details": "",
            "param_info": [
                {
                    "name": "duplex",
                    "description": "LAN duplex setting can be one of the following values",
                    "enum": "lan.HALF nil|lan.FULL nil",
                    "type": "lanstatusduplexduplex",
                    "range": ""
                }
            ],
            "usage": [
                "duplex = lan.status.duplex"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.duplex);",
                    "description": "Outputs the present LAN duplex mode, such as:\n--- --1.00000e+00\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.status.gateway",
            "webhelpfile": "14912.htm",
            "signature": "",
            "command_return": "gatewayAddress",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the gateway address presently in use by the LAN interface.",
            "details": "The value of gatewayAddress is a string that indicates the IP address of the gateway in dotted decimal notation.",
            "param_info": [
                {
                    "name": "gatewayAddress",
                    "description": "LAN gateway address presently being used",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "gatewayAddress = lan.status.gateway"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.gateway);",
                    "description": "Outputs the gateway address, such as:\n--- --192.168.0.1\n"
                }
            ],
            "related_commands": [
                "lan.config.gateway"
            ]
        },
        {
            "name": "lan.status.ipaddress",
            "webhelpfile": "14913.htm",
            "signature": "",
            "command_return": "ipAddress",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN IP address presently in use by the LAN interface.",
            "details": "The IP address is a character string that represents the IP address assigned to the instrument.",
            "param_info": [
                {
                    "name": "ipAddress",
                    "description": "LAN IP address specified in dotted decimal notation",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "ipAddress = lan.status.ipaddress"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.ipaddress);",
                    "description": "Outputs the LAN IP address currently in use, such as:\n--- --192.168.0.2\n"
                }
            ],
            "related_commands": [
                "lan.config.ipaddress"
            ]
        },
        {
            "name": "lan.status.macaddress",
            "webhelpfile": "14914.htm",
            "signature": "",
            "command_return": "macAddress",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN MAC address.",
            "details": "The MAC address is a character string representing the MAC address of the instrument in hexadecimal notation. The string includes colons that separate the address octets (see\u00a0Example).",
            "param_info": [
                {
                    "name": "macAddress",
                    "description": "The instrument MAC address",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "macAddress = lan.status.macaddress"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.macaddress);",
                    "description": "Outputs the MAC address of the instrument, for example:\n--- --08:00:11:00:00:57\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.status.port.dst",
            "webhelpfile": "14915.htm",
            "signature": "",
            "command_return": "port",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN dead socket termination port number.",
            "details": "This attribute holds the TCP port number used to reset all other LAN socket connections.To reset all LAN connections, open a connection to the DST port number.",
            "param_info": [
                {
                    "name": "port",
                    "description": "Dead socket termination socket port number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "port = lan.status.port.dst"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.port.dst);",
                    "description": "Outputs the LAN dead socket termination port number, such\u00a0as:\n--- --5.03000e+03\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.status.port.rawsocket",
            "webhelpfile": "14916.htm",
            "signature": "",
            "command_return": "port",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN raw socket connection port number.",
            "details": "The TCP port number used to connect the instrument and to control the instrument over a raw socket communication interface.",
            "param_info": [
                {
                    "name": "port",
                    "description": "Raw socket port number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "port = lan.status.port.rawsocket"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.port.rawsocket);",
                    "description": "Outputs the LAN raw socket port number, such\u00a0as:\n--- --5.02500e+03\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.status.port.telnet",
            "webhelpfile": "14917.htm",
            "signature": "",
            "command_return": "port",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN Telnet connection port number.",
            "details": "This attribute holds the TCP port number used to connect to the instrument to control it over a Telnet interface.",
            "param_info": [
                {
                    "name": "port",
                    "description": "Telnet port number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "port = lan.status.port.telnet"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.port.telnet);",
                    "description": "Get the LAN Telnet connection port number.\n--- --Output:\n--- --2.30000e+01\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.status.port.vxi11",
            "webhelpfile": "14918.htm",
            "signature": "",
            "command_return": "port",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN VXI-11 connection port number.",
            "details": "This attribute stores the TCP port number used to connect to the instrument over a VXI-11 interface.",
            "param_info": [
                {
                    "name": "port",
                    "description": "LAN VXI-11 port number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "port = lan.status.vxi11"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.port.vxi11);",
                    "description": "Outputs the VXI-11 number, such as:\n--- --1.02400e+03\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.status.speed",
            "webhelpfile": "14919.htm",
            "signature": "",
            "command_return": "speed",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN speed.",
            "details": "This attribute indicates the transmission speed currently in use by the LAN interface.",
            "param_info": [
                {
                    "name": "speed",
                    "description": "LAN speed in Mbps, either 10 or 100",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "speed = lan.status.speed"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.speed);",
                    "description": "Outputs the transmission speed of the instrument presently in use, such as:\n--- --1.00000e+02\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.status.subnetmask",
            "webhelpfile": "14920.htm",
            "signature": "",
            "command_return": "mask",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the LAN subnet mask that is presently in use by the LAN interface.",
            "details": "Use this attribute to determine the present operating state of the LAN. This attribute returns the present LAN subnet mask value if the LAN is manually configured, or when DLLA or DHCP is used.",
            "param_info": [
                {
                    "name": "mask",
                    "description": "A string specifying the subnet mask in dotted decimal notation",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "mask = lan.status.subnetmask"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.status.subnetmask);",
                    "description": "Outputs the subnet mask of the instrument that is presently in use, such as:\n--- --255.255.255.0\n"
                }
            ],
            "related_commands": [
                "lan.config.subnetmask"
            ]
        },
        {
            "name": "lan.trigger[N].assert()",
            "webhelpfile": "14921.htm",
            "signature": "lan.trigger[N].assert()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function simulates the occurrence of the trigger and generates the corresponding event ID.",
            "details": "Generates and sends a LAN trigger packet for the LAN event number specified.Sets the pseudo line state to the appropriate state.The following indexes provide the listed LXI events:",
            "param_info": [
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "lan.trigger[N].assert()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.trigger[5].assert();",
                    "description": "Creates a trigger with LAN packet 5.\n"
                }
            ],
            "related_commands": [
                "lan.lxidomain",
                "lan.trigger[N].clear()",
                "lan.trigger[N].mode",
                "lan.trigger[N].overrun",
                "lan.trigger[N].stimulus",
                "lan.trigger[N].wait()"
            ]
        },
        {
            "name": "lan.trigger[N].clear()",
            "webhelpfile": "14922.htm",
            "signature": "lan.trigger[N].clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the event detector for a LAN trigger.",
            "details": "The trigger event detector enters the detected state when an event is detected. This function clears a trigger event detector and discards the history of the trigger packet.This function clears all overruns associated with this LAN trigger.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8) to clear",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "lan.trigger[N].clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.trigger[5].clear();",
                    "description": "Clears the event detector with LAN packet 5.\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].assert()",
                "lan.trigger[N].overrun",
                "lan.trigger[N].stimulus",
                "lan.trigger[N].wait()"
            ]
        },
        {
            "name": "lan.trigger[N].connect()",
            "webhelpfile": "14923.htm",
            "signature": "lan.trigger[N].connect()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function prepares the event generator for outgoing trigger events.",
            "details": "This command prepares the event generator to send event messages. For TCP connections, this opens the TCP connection.The event generator automatically disconnects when either the protocol or IP address for this event is changed.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "lan.trigger[N].connect()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.trigger[1].protocol = lan.MULTICAST;lan.trigger[1].connect();lan.trigger[1].assert();",
                    "description": "Set the protocol for LAN trigger\u00a01 to be multicast when sending LAN triggers. Then, after connecting the LAN trigger, send a message on LAN trigger\u00a01 by asserting it.\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].assert()",
                "lan.trigger[N].ipaddress",
                "lan.trigger[N].overrun",
                "lan.trigger[N].protocol",
                "lan.trigger[N].stimulus",
                "lan.trigger[N].wait()"
            ]
        },
        {
            "name": "lan.trigger[N].connected",
            "webhelpfile": "14924.htm",
            "signature": "",
            "command_return": "connected",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the LAN event connection state.",
            "details": "This read-only attribute is set to true when the LAN trigger is connected and ready to send trigger events following a successful lan.trigger[N].connect() command; if the LAN trigger is not ready to send trigger events, this value is false.This attribute is also false when either lan.trigger[N].protocol or lan.trigger[N].ipaddress attributes are changed or the remote connection closes the connection.",
            "param_info": [
                {
                    "name": "connected",
                    "description": "The LAN event connection state",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "connected = lan.trigger[N].connected"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.trigger[1].protocol = lan.MULTICAST;print(lan.trigger[1].connected);",
                    "description": "Outputs true if connected, or false if not\u00a0connected.\n--- --Example output:\n--- --false\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].connect()",
                "lan.trigger[N].ipaddress",
                "lan.trigger[N].protocol"
            ]
        },
        {
            "name": "lan.trigger[N].disconnect()",
            "webhelpfile": "14925.htm",
            "signature": "lan.trigger[N].disconnect()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function disconnects the LAN trigger.",
            "details": "For TCP connections, this closes the TCP connection.The LAN trigger automatically disconnects when either the lan.trigger[N].protocol or lan.trigger[N].ipaddress attributes for this event are changed.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "lan.trigger[N].disconnect()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "lan.trigger[N].ipaddress",
                "lan.trigger[N].protocol"
            ]
        },
        {
            "name": "lan.trigger[N].EVENT_ID",
            "webhelpfile": "14926.htm",
            "signature": "lan.trigger[N].EVENT_ID",
            "command_return": "",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant is the event identifier used to route the LAN trigger to other subsystems (using stimulus properties).",
            "details": "Set the stimulus of any trigger event detector to the value of this constant to have it respond to incoming LAN trigger packets.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "lan.trigger[N].EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[14].stimulus = lan.trigger[1].EVENT_ID;",
                    "description": "Route occurrences of triggers on LAN trigger\u00a01 to digital I/O trigger\u00a014.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.trigger[N].ipaddress",
            "webhelpfile": "14927.htm",
            "signature": "",
            "command_return": "ipAddress",
            "type": "Attribute (RW)\n",
            "default_value": "\"0.0.0.0\"\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the address (in dotted\u2011decimal format) of UDP or TCP listeners.",
            "details": "Sets the IP address for outgoing trigger events.Set to \"0.0.0.0\" for multicast.After changing this setting, the lan.trigger[N].connect() command must be called before outgoing messages can be sent.",
            "param_info": [
                {
                    "name": "ipAddress",
                    "description": "The LAN address for this attribute as a string in dotted decimal notation",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "ipAddress = lan.trigger[N].ipaddress",
                "lan.trigger[N].ipaddress = ipAddress"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.trigger[3].protocol = lan.TCP;lan.trigger[3].ipaddress = \"192.168.1.100\";lan.trigger[3].connect();",
                    "description": "Set the protocol for LAN trigger\u00a03 to be lan.TCP when sending LAN triggers.\n--- --Use IP address \"192.168.1.100\" to connect the LAN trigger.\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].connect()"
            ]
        },
        {
            "name": "lan.trigger[N].mode",
            "webhelpfile": "14928.htm",
            "signature": "",
            "command_return": "mode",
            "type": "Attribute (RW)\n",
            "default_value": "0 (lan.TRIG_EITHER)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the trigger operation and detection mode of the specified LAN event.",
            "details": "This command controls how the trigger event detector and the output trigger generator operate on the given trigger. These settings are intended to provide behavior similar to the digital I/O triggers.lan.TRIG_RISING and lan.TRIG_RISINGA are the same.lan.TRIG_RISING and lan.TRIG_RISINGM are the same.Use of either lan.TRIG_SYNCHRONOUSA or lan.TRIG_SYNCHRONOUSM instead of lan.TRIG_SYNCHRONOUS is preferred. Use of lan.TRIG_SYNCHRONOUS is provided for compatibility with older products and other Keithley Instruments products.",
            "param_info": [
                {
                    "name": "mode",
                    "description": "A number representing the trigger mode (0 to 7); see the Details section for more\u00a0information",
                    "enum": "",
                    "type": "any",
                    "range": "(0 to 7)"
                },
                {
                    "name": "N",
                    "description": "A number representing the LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "mode = lan.trigger[N].mode",
                "lan.trigger[N].mode = mode"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.trigger[1].mode);",
                    "description": "Outputs the present LAN trigger mode of LAN event\u00a01.\n"
                }
            ],
            "related_commands": [
                "Digital I/O",
                "TSP-Link system expansion interface"
            ]
        },
        {
            "name": "lan.trigger[N].overrun",
            "webhelpfile": "14929.htm",
            "signature": "",
            "command_return": "overrun",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the overrun status of the LAN event detector.",
            "details": "This command indicates whether an event has been ignored because the event detector was already in the detected state when the event occurred.This is an indication of the state of the event detector built into the synchronization line itself. It does not indicate if an overrun occurred in any other part of the trigger model, or in any other construct that is monitoring the event.",
            "param_info": [
                {
                    "name": "overrun",
                    "description": "The trigger overrun state for the specified LAN packet (true or false)",
                    "enum": "",
                    "type": "any",
                    "range": "(true or false)"
                },
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "overrun = lan.trigger[N].overrun"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "overrun = lan.trigger[5].overrun;print(overrun);",
                    "description": "Checks the overrun status of a trigger on LAN5 and outputs the value, such as:\n--- --false\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].assert()",
                "lan.trigger[N].clear()",
                "lan.trigger[N].stimulus",
                "lan.trigger[N].wait()"
            ]
        },
        {
            "name": "lan.trigger[N].protocol",
            "webhelpfile": "14930.htm",
            "signature": "",
            "command_return": "protocol",
            "type": "Attribute (RW)\n",
            "default_value": "0 (lan.TCP)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the LAN protocol to use for sending trigger messages.",
            "details": "The LAN trigger listens for trigger messages on all supported protocols, but uses the designated protocol for sending outgoing messages. After changing this setting, lan.trigger[N].connect() must be called before outgoing event messages can be\u00a0sent.When the lan.MULTICAST protocol is selected, the lan.trigger[N].ipaddress attribute is ignored and event messages are sent to the multicast address 224.0.23.159.",
            "param_info": [
                {
                    "name": "protocol",
                    "description": "The protocol to use for messages from the trigger",
                    "enum": "lan.TCP1 nil|lan.UDP2 nil|lan.MULTICAST nil",
                    "type": "lantriggerprotocolprotocol",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "protocol = lan.trigger[N].protocol",
                "lan.trigger[N].protocol = protocol"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.trigger[1].protocol);",
                    "description": "Get LAN protocol to use for sending trigger messages for LAN event 1.\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].connect()",
                "lan.trigger[N].ipaddress"
            ]
        },
        {
            "name": "lan.trigger[N].pseudostate",
            "webhelpfile": "14931.htm",
            "signature": "",
            "command_return": "pseudostate",
            "type": "Attribute (RW)\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the simulated line state for the LAN trigger.",
            "details": "This attribute can be set to initialize the pseudo line state to a known value.Setting this attribute does not cause the LAN trigger to generate any events or output packets.",
            "param_info": [
                {
                    "name": "pseudostate",
                    "description": "The simulated line state (0 or 1)",
                    "enum": "",
                    "type": "any",
                    "range": "(0 or 1)"
                },
                {
                    "name": "N",
                    "description": "A number representing the LAN event number (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "pseudostate = lan.trigger[N].pseudostate",
                "lan.trigger[N].pseudostate = pseudostate"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.trigger[1].pseudostate);",
                    "description": "Get the present simulated line state for the LAN event 1.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "lan.trigger[N].wait()",
            "webhelpfile": "14933.htm",
            "signature": "lan.trigger[N].wait(timeout)",
            "command_return": "triggered",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function waits for an input trigger.",
            "details": "If one or more trigger events have been detected since the last time lan.trigger[N].wait() or lan.trigger[N].clear() was called, this function returns immediately.After waiting for a LAN trigger event with this function, the event detector is automatically reset and rearmed regardless of the number of events detected.",
            "param_info": [
                {
                    "name": "triggered",
                    "description": "Trigger detection indication (true or false)",
                    "enum": "",
                    "type": "any",
                    "range": "(true or false)"
                },
                {
                    "name": "N",
                    "description": "The trigger packet over LAN to wait for (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                },
                {
                    "name": "timeout",
                    "description": "Maximum amount of time in seconds to wait for the trigger event",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "triggered = lan.trigger[N].wait(timeout)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "triggered = lan.trigger[5].wait(3);",
                    "description": "Wait for a trigger with LAN packet 5 with a timeout of 3 seconds.\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].assert()",
                "lan.trigger[N].clear()",
                "lan.trigger[N].overrun",
                "lan.trigger[N].stimulus"
            ]
        },
        {
            "name": "localnode.description",
            "webhelpfile": "15008.htm",
            "signature": "",
            "command_return": "description",
            "type": "Attribute (RW)\n",
            "default_value": "Instrument specific (see Details)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores a user-defined description and mDNS service name of the instrument.",
            "details": "This attribute stores a string that contains a description of the instrument. This value appears on LXI welcome page of the instrument. The value of this attribute is also used as the mDNS service name of the instrument.The default value of this attribute contains Keithley ModelNumber #SSSSSSSS, where: ModelNumber  is the model number of the instrument and #SSSSSSSS is the eight-digit serial number of the instrument. You can change it to a value that makes sense for your system. Setting this attribute to an empty string (in other words, setting this attribute to a string of length zero or a string consisting entirely of whitespace characters) reverts the description to the factory default value.When using this command from a remote node, replace localnode with the node reference, for example node[5].description.",
            "param_info": [
                {
                    "name": "description",
                    "description": "User-defined description and mDNS service name of the instrument; use a string of 63 characters or less",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "localnode.description = description",
                "description = localnode.description"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "description = \"System in Lab 05\";localnode.description = description;",
                    "description": "Set description to System in Lab 05.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "node[N].execute()",
            "webhelpfile": "15009.htm",
            "signature": "node[N].execute(scriptCode)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes (see Details)\n",
            "description": "This function starts test scripts on a remote TSP\u2011Link node. ",
            "details": "This command is only applicable to TSP\u2011Link systems. You can use this command to use the remote master node to run a script on the specified node. This function does not run test scripts on the master node; only on the subordinate node when initiated by the master node.This function may only be called when the group number of the node is different than the node of the master.This function does not wait for the script to finish execution.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The node number of this instrument (1 to 63)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 63)"
                },
                {
                    "name": "scriptCode",
                    "description": "A string containing the source code",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "node[N].execute(scriptCode)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "node[2].execute(sourcecode);",
                    "description": "Runs script code on node 2. The code is in a string variable called sourcecode.\n"
                },
                {
                    "example": "node[3].execute(\"x = 5\");",
                    "description": "Runs script code in string constant (x = 5) to set x equal to 5 on node 3.\n"
                },
                {
                    "example": "node[32].execute(TestDut.source);",
                    "description": "Runs the test script stored in the variable TestDut (previously stored on the master node) on node 32.\n"
                }
            ],
            "related_commands": [
                "TSP advanced features",
                "tsplink.group"
            ]
        },
        {
            "name": "node[N].getglobal()",
            "webhelpfile": "15010.htm",
            "signature": "node[N].getglobal(name)",
            "command_return": "value",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the value of a global variable. ",
            "details": "This function retrieves the value of a global variable from the runtime environment of this node.Do not use this command to retrieve the value of a global variable from the local node. Instead, access the global variable directly. This command should only be used from a remote master when controlling this instrument over a TSP-Link network.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The value of the variable",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The node number of this instrument (1 to 64)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 64)"
                },
                {
                    "name": "name",
                    "description": "The global variable name",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "value = node[N].getglobal(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(node[5].getglobal(\"test_val\"));",
                    "description": "Retrieves and outputs the value of the global variable named test_val from node 5.\n"
                }
            ],
            "related_commands": [
                "node[N].setglobal()",
                "TSP advanced features"
            ]
        },
        {
            "name": "gettimezone()",
            "webhelpfile": "15011.htm",
            "signature": "gettimezone()",
            "command_return": "timeZone",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function retrieves the local time zone.",
            "details": "See settimezone() for additional details about the time zone format and a description of the fields.timeZone can be in either of the following formats:",
            "param_info": [
                {
                    "name": "timeZone",
                    "description": "The local time zone of the instrument",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "timeZone = gettimezone()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "timezone = gettimezone();",
                    "description": "Reads the value of the local time zone.\n"
                }
            ],
            "related_commands": [
                "settimezone()"
            ]
        },
        {
            "name": "localnode.model",
            "webhelpfile": "15013.htm",
            "signature": "",
            "command_return": "model",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the model number.",
            "details": "",
            "param_info": [
                {
                    "name": "model",
                    "description": "The model number of the instrument",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "model = localnode.model"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(localnode.model);",
                    "description": "Outputs the model number of the local node. For example:\n--- --<CT2470_only_start_***Set CT2470 variable****>2470 <CT2470_only_end_***Set CT2470 variable****>3700A \n"
                }
            ],
            "related_commands": [
                "localnode.serialno"
            ]
        },
        {
            "name": "localnode.password",
            "webhelpfile": "15014.htm",
            "signature": "",
            "command_return": "password",
            "type": "Attribute (W)\n",
            "default_value": "\"admin\"\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the remote access password.",
            "details": "This write-only attribute stores the password that is set for any remote interface. When password usage is enabled (localnode.passwordmode), you must supply a password to change the configuration or to control an instrument from a remote command interface.The instrument continues to use the old password for all interactions until the command to change it executes. When changing the password, give the instrument time to execute the command before attempting to use the new password.You can retrieve the password from the front panel through MENU > LAN > STATUS > PASSWORD.You can reset the password by resetting the LAN from the front panel or by sending the lan.reset() command.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].password.",
            "param_info": [
                {
                    "name": "password",
                    "description": "A string that contains the remote interface password, up to 255 characters",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "localnode.password = password"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "localnode.password = \"N3wpa55w0rd\";",
                    "description": "Changes the remote interface password to N3wpa55w0rd.\n"
                }
            ],
            "related_commands": [
                "lan.reset()",
                "localnode.passwordmode"
            ]
        },
        {
            "name": "localnode.passwordmode",
            "webhelpfile": "15015.htm",
            "signature": "",
            "command_return": "mode",
            "type": "Attribute (RW)\n",
            "default_value": "1 (localnode.PASSWORD_WEB)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the password enable mode for remote access to the instrument.",
            "details": "This attribute controls if and where remote access passwords are required. Set this attribute to one of the values below to enable password checking:When using this command from a remote node, replace localnode with the node reference, for example node[5].passwordmode.If you enable password mode, you must also assign a password.",
            "param_info": [
                {
                    "name": "mode",
                    "description": "The remote password enable mode",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "mode = localnode.passwordmode",
                "localnode.passwordmode = mode"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "mode = localnode.PASSWORD_WEB;localnode.passwordmode = mode;localnode.password = \"SMU1234\";",
                    "description": "Sets value of mode to PASSWORD_WEB.\n--- --Allows use of passwords on the web interface only.\n--- --Set the password to SMU1234.\n"
                }
            ],
            "related_commands": [
                "localnode.password"
            ]
        },
        {
            "name": "localnode.prompts",
            "webhelpfile": "15016.htm",
            "signature": "",
            "command_return": "prompting",
            "type": "Attribute (RW)\n",
            "default_value": "0 (disabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines if the instrument generates prompts in response to command messages.",
            "details": "When the prompting mode is enabled, the instrument generates prompts when the instrument is ready to take another command. Because the prompt is not generated until the previous command completes, enabling prompts provides handshaking with the instrument to prevent buffer overruns.When prompting is enabled, the instrument might generate the following prompts:Commands do not generate prompts. The instrument generates prompts in response to command completion.Prompts are enabled or disabled only for the remote interface that is active when you send the command. For example, if you enable prompts when the LAN connection is active, they are not enabled for a subsequent USB connection.",
            "param_info": [
                {
                    "name": "prompting",
                    "description": "Prompting mode",
                    "enum": "",
                    "type": "localnodepromptsprompting",
                    "range": ""
                }
            ],
            "usage": [
                "prompting = localnode.prompts",
                "localnode.prompts = prompting"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "localnode.prompts = 1;",
                    "description": "Enable prompting.\n"
                }
            ],
            "related_commands": [
                "localnode.prompts4882",
                "localnode.showerrors",
                "tsplink.reset()"
            ]
        },
        {
            "name": "localnode.prompts4882",
            "webhelpfile": "15017.htm",
            "signature": "",
            "command_return": "prompting",
            "type": "Attribute (RW)\n",
            "default_value": "1 (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables and disables the generation of prompts for IEEE Std 488.2 common commands.",
            "details": "When this attribute is enabled, the IEEE Std 488.2 common commands generate prompts if prompting is enabled with the localnode.prompts attribute. If localnode.prompts4882 is enabled, limit the number of *trg commands sent to a running script to 50 regardless of the setting of the localnode.prompts attribute.When this attribute is disabled, IEEE Std 488.2 common commands do not generate prompts. When using the *trg command with a script that executes trigger.wait() repeatedly, disable prompting to avoid problems associated with the command interface input queue filling.",
            "param_info": [
                {
                    "name": "prompting",
                    "description": "IEEE Std 488.2 prompting mode",
                    "enum": "",
                    "type": "localnodeprompts4882prompting",
                    "range": ""
                }
            ],
            "usage": [
                "prompting = prompts4882",
                "prompts4882 = prompting"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "localnode.prompts4882 = 0;",
                    "description": "Disables IEEE Std 488.2 common command prompting.\n"
                }
            ],
            "related_commands": [
                "localnode.prompts"
            ]
        },
        {
            "name": "localnode.revision",
            "webhelpfile": "15018.htm",
            "signature": "",
            "command_return": "revision",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the firmware revision level.",
            "details": "This attribute indicates the revision number of the firmware that is presently running in the instrument.When using this command from a remote node, replace localnode with the node reference. For example, node[5].revision.",
            "param_info": [
                {
                    "name": "revision",
                    "description": "Firmware revision level",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "revision = localnode.revision"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(localnode.revision);",
                    "description": "Outputs the present revision level.\n--- --Sample output:\n--- --01.50b\n"
                }
            ],
            "related_commands": [
                "localnode.description",
                "localnode.model",
                "localnode.serialno"
            ]
        },
        {
            "name": "localnode.serialno",
            "webhelpfile": "15019.htm",
            "signature": "",
            "command_return": "serialno",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the serial number of the instrument.",
            "details": "This indicates the instrument serial number.",
            "param_info": [
                {
                    "name": "serialno",
                    "description": "The serial number of the instrument",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "serialno = localnode.serialno"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "display.clear();display.settext(localnode.serialno);",
                    "description": "Clears the instrument display.\n--- --Places the serial number of the instrument on the top line of its display.\n"
                }
            ],
            "related_commands": [
                "localnode.description",
                "localnode.model",
                "localnode.revision"
            ]
        },
        {
            "name": "node[N].setglobal()",
            "webhelpfile": "15020.htm",
            "signature": "node[N].setglobal(name, value)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the value of a global variable. ",
            "details": "From a remote node, use this function to assign the given value to a global variable.Do not use this command to create or set the value of a global variable from the local node (set the global variable directly instead). This command should only be used from a remote master when controlling this instrument over a TSP-Link network.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The node number of this instrument (1 to 64)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 64)"
                },
                {
                    "name": "name",
                    "description": "The global variable name to set",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "The value to assign to the variable",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "node[N].setglobal(name, value)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "node[3].setglobal(\"x\", 5);",
                    "description": "Sets the global variable x on node 3 to the value of 5.\n"
                }
            ],
            "related_commands": [
                "node[N].getglobal()",
                "TSP advanced features"
            ]
        },
        {
            "name": "settimezone()",
            "webhelpfile": "15021.htm",
            "signature": "settimezone(offset, dstOffset, dstStart, dstEnd)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function sets the local time zone.",
            "details": "You only need to set the time zone if you use the os.time() and os.date() functions. If only one parameter is given, the same time offset is used throughout the year. If four parameters are given, time is adjusted twice during the year for daylight savings time.offset and dstOffset are strings of the form \"[+|-]hh[:mm[:ss]]\" that indicate how much time must be added to the local time to get UTC time:The minute, second, +, and \u2212 fields are optional.For example, to set the UTC-5 time zone, you specify the string \"5\", because UTC-5 is 5 hours behind UTC and you must add 5 hours to the local time to determine UTC time. To specify the time zone UTC4, you specify \"-4\", because UTC4 is 4 hours ahead of UTC and 4 hours must be subtracted from the local time to determine UTC.dstStart and dstEnd are strings of the form \"MM.w.dw/hh[:mm[:ss]]\" that indicate when daylight savings time begins and ends respectively:The rest of the fields represent the time of day that the change takes effect:The minutes and seconds fields are optional.The week of the month and day of the week fields are not specific dates.",
            "param_info": [
                {
                    "name": "offset",
                    "description": "String representing offset from UTC",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "dstOffset",
                    "description": "String representing the daylight savings offset from UTC",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "dstStart",
                    "description": "String representing when daylight savings time starts",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "dstEnd",
                    "description": "String representing when daylight savings time ends",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "settimezone(offset)",
                "settimezone(offset, dstOffset, dstStart, dstEnd)"
            ],
            "overloads": [
                "settimezone(offset)"
            ],
            "examples": [
                {
                    "example": "settimezone(\"8\", \"1\", \"3.3.0/02\", \"11.2.0/02\")settimezone(offset);",
                    "description": "Sets offset to equal +8 hours, +1\u00a0hour for DST, starts on Mar 14 at 2:00\u00a0am, ends on Nov 7 at 2:00 am.\n--- --Sets local time zone to offset.\n"
                }
            ],
            "related_commands": [
                "gettimezone()",
                "os.time()",
                "settime()"
            ]
        },
        {
            "name": "localnode.showerrors",
            "webhelpfile": "15022.htm",
            "signature": "",
            "command_return": "errorMode",
            "type": "Attribute (RW)\n",
            "default_value": "0 (disabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets whether or not the instrument automatically sends generated errors.",
            "details": "If this attribute is set to 1, the instrument automatically sends any generated errors stored in the error queue, and then clears the queue. Errors are processed after executing a command message (just before issuing a prompt if prompts are enabled).If this attribute is set to 0, errors are left in the error queue and must be explicitly read or cleared.When using this command from a remote node, replace localnode with the node reference, for example, node[5].showerrors.",
            "param_info": [
                {
                    "name": "errorMode",
                    "description": "Show error setting",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "errorMode = localnode.showerrors",
                "localnode.showerrors = errorMode"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "localnode.showerrors = 1;",
                    "description": "Enables sending of generated errors.\n"
                }
            ],
            "related_commands": [
                "localnode.prompts"
            ]
        },
        {
            "name": "makegetter()",
            "webhelpfile": "15041.htm",
            "signature": "makegetter(table, attributeName)",
            "command_return": "getter",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates a function to get the value of an attribute.",
            "details": "This function is useful for aliasing attributes to improve execution speed. Calling the function created with makegetter() executes more quickly than accessing the attribute directly.Creating a getter function is only useful if it is going to be called several times. Otherwise, the overhead of creating the getter function outweighs the overhead of accessing the attribute directly.",
            "param_info": [
                {
                    "name": "getter",
                    "description": "The return value",
                    "enum": "",
                    "type": "function",
                    "range": ""
                },
                {
                    "name": "table",
                    "description": "Read\u2011only table where the attribute is located",
                    "enum": "",
                    "type": "table",
                    "range": ""
                },
                {
                    "name": "attributeName",
                    "description": "A string representing the name of the attribute",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "getter = makegetter(table, attributeName)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "getrange = makegetter(dmm, \"range\");-- (intervening code);r = getrange();",
                    "description": "Create a getter function called getrange.\n--- --When getrange() is called, it returns the value of dmm.range and assigns it to the variable r. \n"
                }
            ],
            "related_commands": [
                "makesetter()"
            ]
        },
        {
            "name": "makesetter()",
            "webhelpfile": "15042.htm",
            "signature": "makesetter(table, attributeName)",
            "command_return": "setter",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates a function that, when called, sets the value of an attribute.",
            "details": "This function is useful for aliasing attributes to improve execution speed. Calling the setter function execute more quickly than accessing the attribute directly.Creating a setter function is only useful if it is going to be called several times. If you are not calling the setter function several times, it is more efficient to access the attribute directly. ",
            "param_info": [
                {
                    "name": "setter",
                    "description": "Function that sets the value of the attribute",
                    "enum": "",
                    "type": "function",
                    "range": ""
                },
                {
                    "name": "table",
                    "description": "Read-only table where the attribute is located",
                    "enum": "",
                    "type": "table",
                    "range": ""
                },
                {
                    "name": "attributeName",
                    "description": "The string name of the attribute",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "setter = makesetter(table, attributeName)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "setrange = makesetter(dmm, \"range\");setrange(5);",
                    "description": "Use setrange with a value of 5 to set dmm.range for the currently selected function.\n"
                }
            ],
            "related_commands": [
                "makegetter()"
            ]
        },
        {
            "name": "memory.available()",
            "webhelpfile": "15045.htm",
            "signature": "memory.available()",
            "command_return": "memoryAvailable",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads and returns the amount of memory that is available in the instrument overall for storing user scripts and channel patterns and for user-defined DMM configurations.",
            "details": "Use this function to view the available memory in the overall instrument as well as the memory available for storing user scripts, channel patterns, and user DMM configurations.The response to this function is a single string that returns the overall instrument memory available, script memory available, channel pattern memory available, and DMM configuration memory available as comma-delimited percentages.",
            "param_info": [
                {
                    "name": "memoryAvailable",
                    "description": "Comma-delimited string with percentages for available memory; the format is systemMemory, scriptMemory, patternMemory, configurationMemory, where",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "memoryAvailable = memory.available()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "memoryAvailable = memory.available();print(memoryAvailable);",
                    "description": "Reads and returns the amount of memory available in the instrument.\n--- --Output:\n--- --51.56, 92.84, 100.00, 100.00\n--- --You can also use:\n--- --print(memory.available())\n"
                },
                {
                    "example": "setup.recall(1);print(memory.available());",
                    "description": "Reads and returns the amount of memory available in the instrument after a setup is recalled.\n--- --Output:\n--- --11.13, 92.84, 0.16, 97.03\n"
                },
                {
                    "example": "print(\"Memory used:\", memory.used());print(\"Memory available: \", memory.available()) ;",
                    "description": "Reads and returns the amount memory used and memory available percentages.\n--- --Output:\n--- --Memory used: 69.14, 0.16, 12.74,  1.04\n--- --Memory available: 30.86, 99.84, 87.26, 98.96\n"
                }
            ],
            "related_commands": [
                "memory.used()"
            ]
        },
        {
            "name": "memory.used()",
            "webhelpfile": "15046.htm",
            "signature": "memory.used()",
            "command_return": "memoryUsed",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reports the amount of memory used in the instrument overall and for user scripts, storing channel patterns, and storing user DMM configurations.",
            "details": "Use this function to view the used memory in the overall instrument, as well as the memory used for storing user scripts, channel patterns, and user DMM configurations.The response to this function is a single string that shows the overall instrument memory used, as well as the script memory used, channel pattern memory used, and DMM configuration memory used as comma-delimited percentages.",
            "param_info": [
                {
                    "name": "memoryUsed",
                    "description": "A comma-delimited string with percentages for used memory; the format is systemMemory, scriptMemory, patternMemory, configurationMemory, where",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "memoryUsed = memory.used()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "MemUsed = memory.used();print(MemUsed);",
                    "description": "Reads the memory used in the instrument and returns the percentages.\n--- --Output:\n--- --69.14, 0.16, 12.74, 1.04\n"
                }
            ],
            "related_commands": [
                "memory.available()"
            ]
        },
        {
            "name": "opc()",
            "webhelpfile": "15054.htm",
            "signature": "opc()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function sets the operation complete status bit when all overlapped commands are completed.",
            "details": "This function causes the operation complete bit in the Standard Event Status Register to be set when all previously started local overlapped commands are complete. Note that each node independently sets its operation complete bits in its own status model. Any nodes that are not actively performing overlapped commands set their bits immediately. All remaining nodes set their own bits as they complete their own overlapped commands.",
            "param_info": [],
            "usage": [
                "opc()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "opc();waitcomplete();print(\"1\");",
                    "description": "Output:\n--- --1\n"
                }
            ],
            "related_commands": [
                "Status model",
                "waitcomplete()"
            ]
        },
        {
            "name": "printbuffer()",
            "webhelpfile": "15057.htm",
            "signature": "printbuffer(startIndex, endPointIndex, bufferVar, bufferVar2)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function prints data from tables or reading buffer subtables.",
            "details": "If startIndex is set to less than 1 or if endIndex is more than the size of the index, 9.910000e+37 is returned for each value outside the allowed index and an event is generated.If overlapped commands use the specified reading buffers and the commands are not complete (at least to the specified index), this function outputs data as it becomes available.When there are outstanding overlapped commands to acquire data, n refers to the index that the last entry in the table has after all the readings have completed.If you pass a reading buffer instead of a reading buffer subtable, the default subtable for that reading buffer is used.This command generates a single response message that contains all data.The output of printbuffer() is affected by the data format selected by format.data. If you set format.data to format.REAL32 or format.REAL64, you have fewer options for buffer elements. With these formats, the only buffer elements available are readings, relativetimestamps, and extravalues. If you request a buffer element that is not permitted for the selected data format, the instrument returns 9.91e37.You can use the bufferVar attributes that are listed in the following table with the print buffer command. For example, if testData is the buffer, you can use testData.dates attribute to print the date of each reading in the testData buffer.You can use bufferVar.n to retrieve the number of readings in the specified reading buffer.",
            "param_info": [
                {
                    "name": "startIndex",
                    "description": "Beginning index of the buffer to print; this must be more than one and less than endIndex",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "endPointIndex",
                    "description": "Ending index of the buffer to print; this must be more than startIndex and less than the index of the last entry in the tables",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "bufferVar",
                    "description": "Name of first table or reading buffer subtable to print; may be a default buffer (defbuffer1 or defbuffer2) or a user\u2011defined buffer",
                    "enum": "",
                    "type": "bufferMethods",
                    "range": "(defbuffer1 or defbuffer2)"
                },
                {
                    "name": "bufferVar2",
                    "description": "Second table or reading buffer subtable to print; may be a default buffer (defbuffer1 or defbuffer2) or a user\u2011defined buffer",
                    "enum": "",
                    "type": "any",
                    "range": "(defbuffer1 or defbuffer2)"
                },
                {
                    "name": "bufferVarN",
                    "description": "The last table or reading buffer subtable to print; may be a default buffer (defbuffer1 or defbuffer2) or a user\u2011defined buffer",
                    "enum": "",
                    "type": "any",
                    "range": "(defbuffer1 or defbuffer2)"
                },
                {
                    "name": "...",
                    "description": "One or more tables or reading buffer subtables separated with commas",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "printbuffer(startIndex, endPointIndex, bufferVar)",
                "printbuffer(startIndex, endPointIndex, bufferVar, bufferVar2)",
                "printbuffer(startIndex, endPointIndex, bufferVar, ...)"
            ],
            "overloads": [
                "printbuffer(startIndex, endPointIndex, bufferVar)",
                "printbuffer(startIndex, endPointIndex, bufferVar, ...)"
            ],
            "examples": [
                {
                    "example": "reset();testData = buffer.make(200);format.data = format.ASCII;format.asciiprecision = 6;trigger.model.load(\"SimpleLoop\", 6, 0, testData);trigger.model.initiate();waitcomplete();printbuffer(1, testData.n, testData.readings, testData.units,   testData.relativetimestamps);",
                    "description": "Reset the instrument.\n--- --Set the data format and ASCII precision.\n--- --Use trigger model SimpleLoop to create a 6-count loop with no delays that stores data in the reading buffer testBuffer.\n--- --Start the trigger model, wait for the commands to complete, and output the readings.\n--- --Use of testData.n (bufferVar.n) indicates that the instrument should output all readings in the reading buffer. In this example, testBuffer.n equals 6.\n--- --Example of output data: \n--- --1.10458e-11, Amp DC, 0.00000e+00, 1.19908e-11, Amp DC, 1.01858e-01, 1.19908e-11, Amp DC, 2.03718e-01, 1.20325e-11, Amp DC, 3.05581e-01, 1.20603e-11, Amp DC, 4.07440e-01, 1.20325e-11, Amp DC, 5.09299e-01\n"
                },
                {
                    "example": "for x = 1, testData.n do;   printbuffer(x,x,testData, testData.units, testData.relativetimestamps);end;",
                    "description": "Using the same buffer created in Example 1, output the readings, units and relative timestamps on a separate line for each reading.\n--- --1.10458e-11, Amp DC, 0.00000e+00\n--- --1.19908e-11, Amp DC, 1.01858e-01\n--- --1.19908e-11, Amp DC, 2.03718e-01\n--- --1.20325e-11, Amp DC, 3.05581e-01\n--- --1.20603e-11, Amp DC, 4.07440e-01\n--- --1.20325e-11, Amp DC, 5.09299e-01\n"
                }
            ],
            "related_commands": [
                "bufferVar.n",
                "bufferVar.readings",
                "format.asciiprecision",
                "format.byteorder",
                "format.data",
                "printnumber()"
            ]
        },
        {
            "name": "printnumber()",
            "webhelpfile": "15058.htm",
            "signature": "printnumber(value1, value2)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function prints numbers using the configured format.",
            "details": "There are multiple ways to use this function, depending on how many numbers are to be printed.This function prints the given numbers using the data format specified by format.data and format.asciiprecision.",
            "param_info": [
                {
                    "name": "value1",
                    "description": "First value to print in the configured format",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value2",
                    "description": "Second value to print in the configured format",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "valueN",
                    "description": "Last value to print in the configured format",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more values separated with commas",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "printnumber(value1)",
                "printnumber(value1, value2)",
                "printnumber(value1, ...)"
            ],
            "overloads": [
                "printnumber(value1)",
                "printnumber(value1, ...)"
            ],
            "examples": [
                {
                    "example": "format.asciiprecision = 10;x = 2.54;printnumber(x);format.asciiprecision = 3;printnumber(x, 2.54321, 3.1);",
                    "description": "Configure the ASCII precision to 10 and set x to 2.54.\n--- --Read the value of x based on these settings.\n--- --Change the ASCII precision to 3.\n--- --View how the change affects the output of x and some numbers.\n--- --Output:\n--- --2.540000000e+00\n--- --2.54e+00, 2.54e+00, 3.10e+00\n"
                }
            ],
            "related_commands": [
                "format.asciiprecision",
                "format.byteorder",
                "format.data",
                "print()",
                "printbuffer()"
            ]
        },
        {
            "name": "script.load()",
            "webhelpfile": "15063.htm",
            "signature": "script.load(file, name)",
            "command_return": "scriptVar",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates a script from a specified file.",
            "details": "The file path may be absolute or relative to the current working directory. The root folder of the USB flash drive has the absolute path \"/usb1/\". Both the forward slash (/) and backslash (\\) are supported as directory separators.The file to be loaded must start with the loadscript or loadandrunscript keywords, contain the body of the script, and end with the endscript keyword.Script naming:",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The created script; this is nil if an error is encountered",
                    "enum": "",
                    "type": "script_object",
                    "range": ""
                },
                {
                    "name": "file",
                    "description": "The path and file name of the script file to load",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "The name of the script to be created",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar = script.load(file)",
                "scriptVar = script.load(file, name)"
            ],
            "overloads": [
                "scriptVar = script.load(file)"
            ],
            "examples": [
                {
                    "example": "myTest8 =    script.load(\"/usb1/filename.tsp\", \"myTest8\");",
                    "description": "Loads the script myTest8 from the USB flash drive.\n"
                }
            ],
            "related_commands": [
                "script.new()"
            ]
        },
        {
            "name": "script.new()",
            "webhelpfile": "15064.htm",
            "signature": "script.new(code, name)",
            "command_return": "scriptVar",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates a script.",
            "details": "The name parameter is the name that is added to the script.user.scripts table. If name is not provided, an empty string is used, and the script is unnamed. If the name already exists in script.user.scripts, the name attribute of the existing script is set to an empty string before it is replaced by the new script.Note that name is the value that is used for the instrument front\u2011panel display. If this value is not defined, the script is not available from the front panel.You must save the new script into nonvolatile memory to keep it when the instrument is turned off.",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of the variable that references the script",
                    "enum": "",
                    "type": "script_object",
                    "range": ""
                },
                {
                    "name": "code",
                    "description": "A string containing the body of the script",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "The name of the script",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar = script.new(code)",
                "scriptVar = script.new(code, name)"
            ],
            "overloads": [
                "scriptVar = script.new(code)"
            ],
            "examples": [
                {
                    "example": "myTest8 = script.new(;   \"display.clear() display.settext('Hello\u00a0from\u00a0myTest8')\", \"myTest8\");myTest8();",
                    "description": "Creates a new script referenced by the variable myTest8 with the name myTest8.\n--- --Runs the script. The instrument displays Hello from myTest8.\n"
                },
                {
                    "example": "autoexec = script.new(;   \"display.clear() display.settext('Hello\u00a0from\u00a0autoexec')\", 'autoexec');",
                    "description": "Creates a new autoexec script that clears the display when the instrument is turned on and displays Hello from autoexec.\n"
                }
            ],
            "related_commands": [
                "Create a script using the script.new() command",
                "Global variables and the script.user.scripts table",
                "Named scripts",
                "scriptVar.save()",
                "script.newautorun()"
            ]
        },
        {
            "name": "setup.poweron",
            "webhelpfile": "15081.htm",
            "signature": "",
            "command_return": "id",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies which saved setup to recall when the instrument is turned on.",
            "details": "When id = 0, the instrument uses the factory default setup when it is turned on. When id is set to 1, it uses the setup saved with setup.save().Only setups stored in nonvolatile memory are available.To save a script that is used when the instrument is powered on, you can create a configuration script and name it autoexec.",
            "param_info": [
                {
                    "name": "id",
                    "description": "An integer that specifies the setup to recall when the instrument power is turned on (0 or 1)",
                    "enum": "",
                    "type": "any",
                    "range": "(0 or 1)"
                }
            ],
            "usage": [
                "id = setup.poweron",
                "setup.poweron = id"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "setup.poweron = 0;",
                    "description": "Set the instrument to use the factory default setup when power is turned on.\n"
                }
            ],
            "related_commands": [
                "createconfigscript()",
                "Save the present configuration",
                "setup.save() ",
                "Start-up (power-on) configuration"
            ]
        },
        {
            "name": "setup.save()",
            "webhelpfile": "15083.htm",
            "signature": "setup.save(id)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function saves the present setup as a user-saved setup.",
            "details": "The id parameter can use a path that is absolute or relative to the current working directory.iIf you do not specify the id parameter, the setup is saved to the nonvolatile memory of the instrument. If a previous setup exists, it is overwritten.You can also create configuration scripts to save setups. See Save the present configuration.",
            "param_info": [
                {
                    "name": "id",
                    "description": "A string that specifies the path and file name to which to save the user setup on a USB flash drive (\"/path/filename\")",
                    "enum": "",
                    "type": "number|string",
                    "range": "(\"/path/filename\")"
                }
            ],
            "usage": [
                "setup.save()",
                "setup.save(id)"
            ],
            "overloads": [
                "setup.save()"
            ],
            "examples": [
                {
                    "example": "setup.save();",
                    "description": "Saves the present setup to the internal memory of the instrument. If there is an existing setup, it is overwritten.\n"
                }
            ],
            "related_commands": [
                "createconfigscript()",
                "Saved setups",
                "setup.recall()"
            ]
        },
        {
            "name": "bufferVar.appendmode",
            "webhelpfile": "15127.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "See Details\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the state of the append mode of the reading buffer.",
            "details": "Assigning a value to this attribute enables or disables the buffer append mode. This value can only be changed with an empty buffer. Use bufferVar.clear() to empty the buffer.When a buffer is created over a remote interface, the append mode attribute default setting is off (0). However, when using the front panel or web interface, the default setting is on (1) to allow triggered readings to fill a buffer without clearing the previous readings.If the append mode is set to 0, any stored readings in the buffer are cleared before new ones are stored. If append mode is set to 1, any stored readings remain in the buffer and new readings are added to the buffer after the stored readings.With append mode on, the first new measurement is stored at rb[n+1], where n is the number of readings stored in buffer rb.",
            "param_info": [],
            "usage": [
                "state = bufferVar.appendmode",
                "bufferVar.appendmode = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "buffer1.appendmode = 1;",
                    "description": "Append new readings to contents of the reading buffer named buffer1.\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.capacity",
            "webhelpfile": "15129.htm",
            "signature": "",
            "command_return": "bufferCapacity",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the number of readings a buffer can store.",
            "details": "This read-only attribute reads the number of readings that can be stored in the buffer.",
            "param_info": [],
            "usage": [
                "bufferCapacity = bufferVar.capacity"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "bufferCapacity = buffer1.capacity;\u00a0;print(bufferCapacity);",
                    "description": "Reads the capacity of a reading buffer named buffer1.\n--- --Output:\n--- --1.00000e+05\n--- --The above output indicates that the buffer can hold 100000 readings.\n"
                }
            ],
            "related_commands": [
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.clear()",
            "webhelpfile": "15130.htm",
            "signature": "bufferVar.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function empties the buffer.",
            "details": "This function clears all readings and statistics from the specified buffer (for example, time, status, channels, and units) from the specified buffer.",
            "param_info": [],
            "usage": [
                "bufferVar.clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testData = dmm.makebuffer(50);testData.appendmode = 1;dmm.measurecount = 3;dmm.measure(testData);printbuffer(1,testData.n, testData );\u00a0;\u00a0;testData.clear();print(\"Readings in buffer after clear =\"    .. testData.n);dmm.measurecount = 3;dmm.measure(testData);printbuffer(1,testData.n, testData );\u00a0;",
                    "description": "Create a reading buffer named testData and enable append mode for it. Make three readings and store them in testData, and then view the readings. \n--- --Output:\n--- --3.515871341e\u201107, 5.596728126e\u201107, 3.944283032e\u201107\n--- --Clear the data and verify there are no readings in buffer. \n--- --Output:\n--- --Readings in buffer after clear =  0\n--- --\u00a0\n--- --Store three new readings in the buffer and view those when done.\n--- --Output:\n--- --4.923509754e\u201107, 3.332266330e\u201107, 3.974883867e\u201107\n"
                }
            ],
            "related_commands": [
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.clearcache()",
            "webhelpfile": "15131.htm",
            "signature": "bufferVar.clearcache()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the cache.",
            "details": "This function clears all readings from the specified cache. If you run successive operations that overwrite reading buffer data, the reading buffer may return stale cache data. This can happen when initiating successive scans without reconfiguring the scan measurements. Watch for this when running Lua code remotely on more than one node, because values in the reading buffer cache may change while the Lua code is running.To avoid this, you can include explicit calls to the bufferVar.clearcache() function to remove stale values from the reading buffer cache.",
            "param_info": [],
            "usage": [
                "bufferVar.clearcache()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "testData.clearcache();",
                    "description": "Clears the reading buffer cache for a user\u2011defined buffer named testData.\n"
                }
            ],
            "related_commands": [
                "bufferVar.cachemode",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.collecttimestamps",
            "webhelpfile": "15133.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "1 (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets whether or not timestamp values are stored with the readings in the buffer.",
            "details": "Assigning a value to this attribute enables or disables the storage of timestamps. Reading this attribute returns the state of timestamp collection. When on, timestamp values are stored with readings in the buffer. This requires four extra bytes of storage for each reading. The state variable can only be changed when the buffer is empty. Empty the buffer using the bufferVar.clear() function.",
            "param_info": [],
            "usage": [
                "state = bufferVar.collecttimestamps",
                "bufferVar.collecttimestamps = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collecttimestamps = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.timestamps[1]);\u00a0;\u00a0;\u00a0;\u00a0;printbuffer(1, 6, testData.timestamps);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect timestamp data, sets and saves the DMM configuration, creates a scan list, and then runs the scan. \n--- --The print() command then outputs the first measurement timestamp. \n--- --Output:\n--- --07/11/2011 09:14:48.509762161\n--- --The printbuffer() command then outputs the timestamps for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --07/11/2011 09:14:48.509762161, 07/11/2011 09:14:48.528708001, 07/11/2011 09:14:48.547659196, 07/11/2011 09:14:48.566612446, 07/11/2011 09:14:48.585565606, 07/11/2011 09:14:48.681325966\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.timestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.n",
            "webhelpfile": "15134.htm",
            "signature": "",
            "command_return": "numberOfReadings",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the number of readings in the buffer.",
            "details": "This read-only attribute contains the number of readings presently stored in the buffer.",
            "param_info": [],
            "usage": [
                "numberOfReadings = bufferVar.n"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "numberOfReadings = buffer1.n;\u00a0;print(numberOfReadings);\u00a0;",
                    "description": "Reads the number of readings stored in a reading buffer named buffer1.\n--- --Output: \n--- --1.250000+02\n--- --The above output indicates that there are 125 readings stored in the buffer.\n"
                }
            ],
            "related_commands": [
                "bufferVar.formattedreadings",
                "bufferVar.fractionalseconds",
                "bufferVar.readings",
                "bufferVar.relativetimestamps",
                "bufferVar.seconds",
                "bufferVar.statuses",
                "bufferVar.times",
                "bufferVar.units",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.timestampresolution",
            "webhelpfile": "15135.htm",
            "signature": "",
            "command_return": "resolution",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the resolution of the timestamp.",
            "details": "Reading this attribute returns the timestamp resolution value.The finest timestamp resolution is 0.000001 seconds (1 \u03bcs). At this resolution, the reading buffer can store unique timestamps for up to 71\u00a0minutes. You can increase this value for very long tests.",
            "param_info": [],
            "usage": [
                "resolution = bufferVar.timestampresolution"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "buffer1.timestampresolution = 0.000008;\u00a0;",
                    "description": "Sets the timestamp resolution of reading buffer 1 to 8 \u03bcs.\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "bufferVar.timestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "tspnet.tsp.runscript()",
            "webhelpfile": "15280.htm",
            "signature": "tspnet.tsp.runscript(connectionID, name, script)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function loads and runs a script on a remote TSP-enabled instrument.",
            "details": "This function is appropriate only for TSP-enabled instruments.This function downloads a script to a remote instrument and runs it. It automatically adds the appropriate loadscript and endscript commands around the script, captures any errors, and reads back any prompts. No additional substitutions are done on the text.The script is automatically loaded, compiled, and run.Any output from previous commands is discarded.This command does not wait for the script to complete.If you do not want the script to do anything immediately, make sure the script only defines functions for later use. Use the tspnet.execute() function to execute those functions later.If no name is specified, the script is loaded as the anonymous script.",
            "param_info": [
                {
                    "name": "connectionID",
                    "description": "Integer value used as an identifier for other tspnet commands",
                    "enum": "",
                    "type": "tspnetConnectionID",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "The name that is assigned to the script",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "script",
                    "description": "The body of the script as a string",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "tspnet.tsp.runscript(connectionID, script)",
                "tspnet.tsp.runscript(connectionID, name, script)"
            ],
            "overloads": [
                "tspnet.tsp.runscript(connectionID, script)"
            ],
            "examples": [
                {
                    "example": "tspnet.tsp.runscript(myconnection, \"mytest\",;\"print([[start]]) for d = 1, 10 do print([[work]]) end print([[end]])\");",
                    "description": "Load and run a script entitled mytest on the TSP\u2011enabled instrument connected with myconnection.\n"
                }
            ],
            "related_commands": [
                "tspnet.execute()"
            ]
        },
        {
            "name": "timer.measure.t()",
            "webhelpfile": "15281.htm",
            "signature": "timer.measure.t()",
            "command_return": "time",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function measures the elapsed time since the timer was last reset.",
            "details": "",
            "param_info": [
                {
                    "name": "time",
                    "description": "The elapsed time in seconds (1\u00a0\u00b5s resolution)",
                    "enum": "",
                    "type": "number",
                    "range": "(1\u00a0\u00b5s resolution)"
                }
            ],
            "usage": [
                "time = timer.measure.t()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "timer.reset();-- (intervening code);time = timer.measure.t();print(time);",
                    "description": "This example resets the timer and measures the time since the reset.\n--- --Output:\n--- --1.469077e+01\n--- --The output varies. The above output indicates that timer.measure.t() was executed 14.69077\u00a0seconds after timer.reset().\n"
                },
                {
                    "example": "beeper.enable = beeper.ON;beeper.beep(0.5, 2400);print(\"reset timer\");timer.reset();delay(0.5);dt = timer.measure.t();print(\"timer after delay:\", dt);beeper.beep(0.5, 2400);",
                    "description": "Enable the beeper.\n--- --Emit a beep and set the beeper.\n--- --Reset the timer.\n--- --Set a delay.\n--- --Verify the duration of the delay before emitting another beep.\n--- --Output:\n--- --reset timer\n--- --timer after delay: 5.00e-01\n"
                }
            ],
            "related_commands": [
                "timer.reset()"
            ]
        },
        {
            "name": "timer.reset()",
            "webhelpfile": "15282.htm",
            "signature": "timer.reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets the timer to zero (0) seconds.",
            "details": "",
            "param_info": [],
            "usage": [
                "timer.reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "timer.reset();-- (intervening code);time = timer.measure.t();print(time);",
                    "description": "Resets the timer and then measures the time since the reset.\n--- --Output:\n--- --1.469077e+01\n--- --The above output indicates that timer.measure.t() was executed 14.69077 seconds after timer.reset().\n"
                }
            ],
            "related_commands": [
                "timer.measure.t()"
            ]
        },
        {
            "name": "tsplink.group",
            "webhelpfile": "15285.htm",
            "signature": "",
            "command_return": "groupNumber",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the group number of a TSP\u2011Link node. ",
            "details": "To remove the node from all groups, set the attribute value to 0.When the node is turned off, the group number for that node changes to 0.The master node can be assigned to any group. You can also include other nodes in the group that includes the master. Note that any nodes that are set to 0 are automatically included in the group that contains the master node, regardless of the group that is assigned to the master node.",
            "param_info": [
                {
                    "name": "groupNumber",
                    "description": "The group number of the TSP-Link node (0 to 64)",
                    "enum": "",
                    "type": "number",
                    "range": "(0 to 64)"
                }
            ],
            "usage": [
                "groupNumber = tsplink.group",
                "tsplink.group = groupNumber"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.group = 3;",
                    "description": "Assign the instrument to TSP-Link group number 3.\n"
                }
            ],
            "related_commands": [
                "Using groups to manage nodes on TSP-Link network"
            ]
        },
        {
            "name": "tsplink.master",
            "webhelpfile": "15286.htm",
            "signature": "",
            "command_return": "masterNodeNumber",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute reads the node number assigned to the master node. ",
            "details": "After doing a TSP-Link reset (tsplink.reset()), use this attribute to access the node number of the master in a set of instruments connected over TSP-Link.",
            "param_info": [
                {
                    "name": "masterNodeNumber",
                    "description": "The node number of the master node",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "masterNodeNumber = tsplink.master"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "LinkMaster = tsplink.master;",
                    "description": "Store the TSP-Link master node number in a variable called LinkMaster.\n"
                }
            ],
            "related_commands": [
                "tsplink.reset()"
            ]
        },
        {
            "name": "tsplink.node",
            "webhelpfile": "15287.htm",
            "signature": "",
            "command_return": "nodeNumber",
            "type": "Attribute (RW)\n",
            "default_value": "2\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the node number. ",
            "details": "This command sets the TSP\u2011Link node number and saves the value in nonvolatile memory.Changes to the node number do not take effect until tsplink.reset() from an earlier TSP\u2011Link instrument is executed on any node in the system.Each node connected to the TSP-Link system must be assigned a different node number.",
            "param_info": [
                {
                    "name": "nodeNumber",
                    "description": "The node number of the instrument or enclosure (1 to 64 )",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 64 )"
                }
            ],
            "usage": [
                "nodeNumber = tsplink.node",
                "tsplink.node = nodeNumber"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.node = 3;",
                    "description": "Sets the TSP\u2011Link node for this instrument to number\u00a03.\n"
                }
            ],
            "related_commands": [
                "tsplink.reset() ",
                "tsplink.state"
            ]
        },
        {
            "name": "tsplink.readbit()",
            "webhelpfile": "15288.htm",
            "signature": "tsplink.readbit(N)",
            "command_return": "data",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads the state of a TSP-Link synchronization line. ",
            "details": "Returns a value of zero (0) if the line is low and 1 if the line is high.",
            "param_info": [
                {
                    "name": "data",
                    "description": "The state of the synchronization line",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "data = tsplink.readbit(N)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "data = tsplink.readbit(3);print(data);",
                    "description": "Assume line 3 is set high, and it is then read.\n--- --Output:\n--- --1.000000e+00\n"
                }
            ],
            "related_commands": [
                "tsplink.readport()",
                "tsplink.writebit()"
            ]
        },
        {
            "name": "tsplink.readport()",
            "webhelpfile": "15289.htm",
            "signature": "tsplink.readport()",
            "command_return": "data",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads the TSP-Link trigger lines as a digital I/O port. ",
            "details": "The binary equivalent of the returned value indicates the input pattern on the I/O port. The least significant bit of the binary number corresponds to line 1 and the value of bit 3 corresponds to line 3. For example, a returned value of 2 has a binary equivalent of 010. This indicates that line 2 is high (1), and that the other two lines are low (0).",
            "param_info": [
                {
                    "name": "data",
                    "description": "Numeric value that indicates which lines are set",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "data = tsplink.readport()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "data = tsplink.readport();print(data);",
                    "description": "Reads state of all three TSP-Link lines.\n--- --Assuming line 2 is set high, the output is:\n--- --2.000000e+00\n--- --(binary 010)\n--- --The format of the output may vary depending on the ASCII precision setting.\n"
                }
            ],
            "related_commands": [
                "TSP-Link trigger lines",
                "tsplink.readbit()",
                "tsplink.writebit()",
                "tsplink.writeport()",
                "tsplink.writeport()"
            ]
        },
        {
            "name": "tsplink.reset()",
            "webhelpfile": "15290.htm",
            "signature": "tsplink.reset(expectedNodes)",
            "command_return": "nodesFound",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function initializes (resets) all nodes (instruments) in the TSP\u2011Link system. ",
            "details": "This function erases all information regarding other nodes connected on the TSP-Link system and regenerates the system configuration. This function must be called at least once before any remote nodes can be accessed. If the node number for any instrument is changed, the TSP-Link must be reset again.If expectedNodes is not given, this function generates an error if no other nodes are found on the TSP\u2011Link network.If nodesFound is less than expectedNodes, an error is generated. Note that the node on which the command is running is counted as a node. For example, giving an expected node count of 1 does not generate any errors, even if there are no other nodes on the TSP-Link network.Also returns the number of nodes found.",
            "param_info": [
                {
                    "name": "nodesFound",
                    "description": "The number of nodes actually found on the system",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "expectedNodes",
                    "description": "The number of nodes expected on the system (1 to 64)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 64)"
                }
            ],
            "usage": [
                "nodesFound = tsplink.reset()",
                "nodesFound = tsplink.reset(expectedNodes)"
            ],
            "overloads": [
                "nodesFound = tsplink.reset()"
            ],
            "examples": [
                {
                    "example": "nodesFound = tsplink.reset(2);print(\"Nodes found = \" .. nodesFound);",
                    "description": "Perform a TSP-Link reset and indicate how many nodes are found.\n--- --Sample output if two nodes are found:Nodes found = 2\n--- --Sample output if fewer nodes are found and if localnode.showerrors = 1:1219, TSP-Link found fewer nodes than expectedNodes found = 1\n"
                }
            ],
            "related_commands": [
                "localnode.showerrors",
                "tsplink.node",
                "tsplink.state"
            ]
        },
        {
            "name": "tsplink.state",
            "webhelpfile": "15291.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the TSP\u2011Link online state. ",
            "details": "When the instrument power is first turned on, the state is offline. After tsplink.reset() is successful, the state is online.",
            "param_info": [
                {
                    "name": "state",
                    "description": "TSP-Link state (online or offline)",
                    "enum": "",
                    "type": "string",
                    "range": "(online or offline)"
                }
            ],
            "usage": [
                "state = tsplink.state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "state = tsplink.state;print(state);",
                    "description": "Read the state of the TSP\u2011Link system. If it is online, the output is:\n--- --online\n"
                }
            ],
            "related_commands": [
                "tsplink.node",
                "tsplink.reset()"
            ]
        },
        {
            "name": "tsplink.trigger[N].assert()",
            "webhelpfile": "15292.htm",
            "signature": "tsplink.trigger[N].assert()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function simulates the occurrence of the trigger and generates the corresponding event ID. ",
            "details": "The set pulse width determines how long the trigger is asserted.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "tsplink.trigger[N].assert()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.trigger[2].assert();",
                    "description": "Asserts trigger on trigger line 2.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].clear()",
                "tsplink.trigger[N].mode",
                "tsplink.trigger[N].overrun",
                "tsplink.trigger[N].pulsewidth",
                "tsplink.trigger[N].release()",
                "tsplink.trigger[N].stimulus",
                "tsplink.trigger[N].wait()"
            ]
        },
        {
            "name": "tsplink.trigger[N].clear()",
            "webhelpfile": "15293.htm",
            "signature": "tsplink.trigger[N].clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the event detector for a LAN trigger. ",
            "details": "The trigger event detector enters the detected state when an event is detected. tsplink.trigger[N].clear() clears a trigger event detector, discards the history of the trigger line, and clears the tsplink.trigger[N].overrun attribute.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3) to clear",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "tsplink.trigger[N].clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.trigger[2].clear();",
                    "description": "Clears trigger event on synchronization line 2.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].mode",
                "tsplink.trigger[N].overrun",
                "tsplink.trigger[N].release()",
                "tsplink.trigger[N].stimulus",
                "tsplink.trigger[N].wait()"
            ]
        },
        {
            "name": "tsplink.trigger[N].EVENT_ID",
            "webhelpfile": "15294.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant identifies the number that is used for the trigger events. ",
            "details": "This number is used by the TSP-Link trigger line when it detects an input trigger.Set the stimulus of any trigger object to the value of this constant to have the trigger object respond to trigger events from this line.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The trigger event number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "eventID = tsplink.trigger[N].EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.timer[1].stimulus = tsplink.trigger[2].EVENT_ID;",
                    "description": "Sets the trigger stimulus of trigger timer 1 to the TSP-Link trigger 2 event.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "tsplink.trigger[N].mode",
            "webhelpfile": "15295.htm",
            "signature": "",
            "command_return": "mode",
            "type": "Attribute (RW)\n",
            "default_value": "0 (tsplink.TRIG_BYPASS)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the trigger operation and detection mode. ",
            "details": "This attribute controls the mode in which the trigger event detector and the output trigger generator operate on the given trigger\u00a0line.The setting for the mode parameter can be one of the values shown in the following table.When programmed to any mode except tsplink.TRIG_BYPASS, the output state of the I/O line is controlled by the trigger logic and the user-specified output state of the line is\u00a0ignored.When the trigger mode is set to tsplink.TRIG_RISING, the user\u2011specified output state of the line is examined. If the output state selected when the mode is changed is high, the actual mode that is used is tsplink.TRIG_RISINGA. If the output state selected when the mode is changed is low, the actual mode that is used is tsplink.TRIG_RISINGM.The mode parameter stores the trigger mode as a numeric value when the attribute is read.To control the line state, use the tsplink.TRIG_BYPASS mode with the tsplink.writebit() and the tsplink.writeport() commands.",
            "param_info": [
                {
                    "name": "mode",
                    "description": "The trigger mode",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "mode = tsplink.trigger[N].mode",
                "tsplink.trigger[N].mode = mode"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.trigger[3].mode = tsplink.TRIG_RISINGM;",
                    "description": "Sets the trigger mode for synchronization line 3 to tsplink.TRIG_RISINGM.\n"
                }
            ],
            "related_commands": [
                "digio.writebit()",
                "digio.writeport()",
                "tsplink.trigger[N].assert()",
                "tsplink.trigger[N].clear()",
                "tsplink.trigger[N].overrun",
                "tsplink.trigger[N].release()",
                "tsplink.trigger[N].reset()",
                "tsplink.trigger[N].stimulus",
                "tsplink.trigger[N].wait()"
            ]
        },
        {
            "name": "tsplink.trigger[N].overrun",
            "webhelpfile": "15296.htm",
            "signature": "",
            "command_return": "overrun",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if the event detector ignored an event while in the detected state. ",
            "details": "This command indicates whether an event has been ignored because the event detector was already in the detected state when the event occurred.This is an indication of the state of the event detector built into the synchronization line itself.",
            "param_info": [
                {
                    "name": "overrun",
                    "description": "Trigger overrun state",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "overrun = tsplink.trigger[N].overrun"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(tsplink.trigger[1].overrun);",
                    "description": "If an event was ignored, displays true; if an event was not ignored, displays false.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].assert()",
                "tsplink.trigger[N].clear()",
                "tsplink.trigger[N].mode",
                "tsplink.trigger[N].release()",
                "tsplink.trigger[N].reset()",
                "tsplink.trigger[N].stimulus",
                "tsplink.trigger[N].wait()"
            ]
        },
        {
            "name": "tsplink.trigger[N].pulsewidth",
            "webhelpfile": "15297.htm",
            "signature": "",
            "command_return": "width",
            "type": "Attribute (RW)\n",
            "default_value": "10e-6 (10 \u00b5s)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the length of time that the trigger line is asserted for output triggers. ",
            "details": "Setting the pulse width to 0 (seconds) asserts the trigger indefinitely.",
            "param_info": [
                {
                    "name": "width",
                    "description": "The pulse width (in seconds)",
                    "enum": "",
                    "type": "any",
                    "range": "(in seconds)"
                },
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "width = tsplink.trigger[N].pulsewidth",
                "tsplink.trigger[N].pulsewidth = width"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.trigger[3].pulsewidth = 20e-6;",
                    "description": "Sets pulse width for trigger line\u00a03 to 20\u00a0\u03bcs.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].release()"
            ]
        },
        {
            "name": "tsplink.trigger[N].release()",
            "webhelpfile": "15298.htm",
            "signature": "tsplink.trigger[N].release()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function releases a latched trigger on the given TSP\u2011Link trigger line. ",
            "details": "Releases a trigger that was asserted with an indefinite pulse width. It also releases a trigger that was latched in response to receiving a synchronous mode trigger.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "tsplink.trigger[N].release()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.trigger[3].release();",
                    "description": "Releases trigger line 3.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].assert()",
                "tsplink.trigger[N].clear()",
                "tsplink.trigger[N].mode",
                "tsplink.trigger[N].overrun",
                "tsplink.trigger[N].pulsewidth",
                "tsplink.trigger[N].stimulus",
                "tsplink.trigger[N].wait()"
            ]
        },
        {
            "name": "tsplink.trigger[N].wait()",
            "webhelpfile": "15300.htm",
            "signature": "tsplink.trigger[N].wait(timeout)",
            "command_return": "triggered",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function waits for a trigger. ",
            "details": "This function waits up to the timeout value for an input trigger. If one or more trigger events were detected since the last time tsplink.trigger[N].wait() or tsplink.trigger[N].clear() was called, this function returns immediately.After waiting for a trigger with this function, the event detector is automatically reset and rearmed. This is true regardless of the number of events detected.",
            "param_info": [
                {
                    "name": "triggered",
                    "description": "Trigger detection indication; set to one of the following values",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                },
                {
                    "name": "timeout",
                    "description": "The timeout value in seconds",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "triggered = tsplink.trigger[N].wait(timeout)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "triggered = tsplink.trigger[3].wait(10);print(triggered);",
                    "description": "Waits up to 10 seconds for a trigger on TSP-Link\u00ae line\u00a03.\n--- --If false is returned, no trigger was detected during the 10-second timeout.\n--- --If true is returned, a trigger was detected.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].clear()"
            ]
        },
        {
            "name": "tsplink.writebit()",
            "webhelpfile": "15301.htm",
            "signature": "tsplink.writebit(N, data)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets a TSP-Link trigger line high or low. ",
            "details": "Use tsplink.writebit() and tsplink.writeport() to control the output state of the trigger line when trigger operation is set to tsplink.TRIG_BYPASS.If the output line is write\u2011protected by the tsplink.writeprotect attribute, this command is ignored.The reset function does not affect the present states of the TSP-Link trigger lines.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 3)"
                },
                {
                    "name": "data",
                    "description": "The value to write to the bit",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "tsplink.writebit(N, data)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.writebit(3, 0);",
                    "description": "Sets trigger line 3 low (0).\n"
                }
            ],
            "related_commands": [
                "tsplink.readbit()",
                "tsplink.readport()",
                "tsplink.writeport()",
                "tsplink.writeprotect"
            ]
        },
        {
            "name": "tsplink.writeport()",
            "webhelpfile": "15302.htm",
            "signature": "tsplink.writeport(data)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function writes to all TSP\u2011Link synchronization lines. ",
            "details": "The binary representation of data indicates the output pattern that is written to the I/O port. For example, a data value of 2 has a binary equivalent of 010. Line 2 is set high (1), and the other two lines are set low (0).Write\u2011protected lines are not changed.Use the tsplink.writebit() and tsplink.writeport() commands to control the output state of the synchronization line when trigger operation is set to tsplink.TRIG_BYPASS.The reset() function does not affect the present states of the trigger lines.",
            "param_info": [
                {
                    "name": "data",
                    "description": "Value to write to the port (0 to 7)",
                    "enum": "",
                    "type": "number",
                    "range": "(0 to 7)"
                }
            ],
            "usage": [
                "tsplink.writeport(data)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.writeport(3);",
                    "description": "Sets the synchronization lines 1 and 2 high (binary 011).\n"
                }
            ],
            "related_commands": [
                "tsplink.readbit()",
                "tsplink.readport()",
                "tsplink.writebit()",
                "tsplink.writeprotect"
            ]
        },
        {
            "name": "trigger.blender[N].clear()",
            "webhelpfile": "15785.htm",
            "signature": "trigger.blender[N].clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the blender event detector and resets the overrun indicator of blender N.",
            "details": "This command sets the blender event detector to the undetected state and resets the overrun indicator of the event detector.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The blender number (up to two)",
                    "enum": "",
                    "type": "any",
                    "range": "(up to two)"
                }
            ],
            "usage": [
                "trigger.blender[N].clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.blender[2].clear();",
                    "description": "Clears the event detector for blender 2.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "trigger.blender[N].EVENT_ID",
            "webhelpfile": "15786.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant contains the trigger blender event number.",
            "details": "Set the stimulus of any trigger object to the value of this constant to have the trigger object respond to trigger events from this trigger blender.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "Trigger event number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The blender number (up to two)",
                    "enum": "",
                    "type": "any",
                    "range": "(up to two)"
                }
            ],
            "usage": [
                "eventID = trigger.blender[N].EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[1].stimulus = trigger.blender[2].EVENT_ID;",
                    "description": "Set the trigger stimulus of digital I/O trigger 1 to be controlled by the trigger blender 2 event.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "trigger.blender[N].orenable",
            "webhelpfile": "15787.htm",
            "signature": "",
            "command_return": "orenable",
            "type": "Attribute (RW)\n",
            "default_value": "false (AND mode)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute selects whether the blender performs OR operations or AND operations.",
            "details": "This command selects whether the blender waits for any one event (OR) or waits for all selected events (AND) before signaling an output event.",
            "param_info": [
                {
                    "name": "orenable",
                    "description": "The type of operation",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The blender number (up to two)",
                    "enum": "",
                    "type": "any",
                    "range": "(up to two)"
                }
            ],
            "usage": [
                "orenable = trigger.blender[N].orenable",
                "trigger.blender[N].orenable = orenable"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.blender[1].orenable = true;trigger.blender[1].stimulus[1] = digio.trigger[3].EVENT_ID;trigger.blender[1].stimulus[2] = digio.trigger[5].EVENT_ID;",
                    "description": "Generate a trigger blender 1 event when a digital I/O trigger happens on line 3 or 5.\n"
                }
            ],
            "related_commands": [
                "trigger.blender[N].reset()"
            ]
        },
        {
            "name": "trigger.blender[N].overrun",
            "webhelpfile": "15788.htm",
            "signature": "",
            "command_return": "overrun",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates whether or not an event was ignored because of the event detector state.",
            "details": "Indicates if an event was ignored because the event detector was already in the detected state when the event occurred. This is an indication of the state of the event detector that is built into the event blender itself.This command does not indicate if an overrun occurred in any other part of the trigger model or in any other trigger object that is monitoring the event. It also is not an indication of an action overrun.",
            "param_info": [
                {
                    "name": "overrun",
                    "description": "Trigger blender overrun state (true or false)",
                    "enum": "",
                    "type": "boolean",
                    "range": "(true or false)"
                },
                {
                    "name": "N",
                    "description": "The blender number (up to two)",
                    "enum": "",
                    "type": "any",
                    "range": "(up to two)"
                }
            ],
            "usage": [
                "overrun = trigger.blender[N].overrun"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(trigger.blender[1].overrun);",
                    "description": "If an event was ignored, the output is true.\n--- --If an event was not ignored, the output is false.\n"
                }
            ],
            "related_commands": [
                "trigger.blender[N].reset()"
            ]
        },
        {
            "name": "trigger.blender[N].wait()",
            "webhelpfile": "15790.htm",
            "signature": "trigger.blender[N].wait(timeout)",
            "command_return": "triggered",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function waits for a blender trigger event to occur.",
            "details": "This function waits for an event blender trigger event. If one or more trigger events were detected since the last time trigger.blender[N].wait() or trigger.blender[N].clear() was called, this function returns immediately.After detecting a trigger with this function, the event detector automatically resets and rearms. This is true regardless of the number of events detected.",
            "param_info": [
                {
                    "name": "triggered",
                    "description": "Trigger detection indication for blender",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The trigger blender (up to two) on which to wait",
                    "enum": "",
                    "type": "any",
                    "range": "(up to two)"
                },
                {
                    "name": "timeout",
                    "description": "Maximum amount of time in seconds to wait for the trigger blender event",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "triggered = trigger.blender[N].wait(timeout)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[3].mode = digio.TRIG_FALLING;digio.trigger[5].mode = digio.TRIG_FALLING;trigger.blender[1].orenable = true;trigger.blender[1].stimulus[1] = digio.trigger[3].EVENT_ID;trigger.blender[1].stimulus[2] = digio.trigger[5].EVENT_ID;print(trigger.blender[1].wait(3));",
                    "description": "Generate a trigger blender 1 event when a digital I/O trigger happens either on line 3 or 5.\n--- --Wait three seconds while checking if trigger blender 1 event has occurred.\n--- --If the blender trigger event has happened, then true is output. If the trigger event has not happened, then false is output after the timeout expires.\n"
                }
            ],
            "related_commands": [
                "trigger.blender[N].clear()"
            ]
        },
        {
            "name": "trigger.clear()",
            "webhelpfile": "15791.htm",
            "signature": "trigger.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function clears the command interface trigger event detector.",
            "details": "The trigger event detector indicates if a trigger event has been detected since the last trigger.wait() call. trigger.clear() clears the trigger event detector and discards the history of command interface trigger events.",
            "param_info": [],
            "usage": [
                "trigger.clear()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "trigger.wait()"
            ]
        },
        {
            "name": "trigger.EVENT_ID",
            "webhelpfile": "15792.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant contains the command interface trigger event number.",
            "details": "You can set the stimulus of any trigger object to the value of this constant to have the trigger object respond to command interface trigger events.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The event ID for the command interface triggers",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "eventID = EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.channel.stimulus = trigger.EVENT_ID;",
                    "description": "Sets the trigger stimulus of the channel event detector to command an interface trigger event.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "trigger.timer[N].clear()",
            "webhelpfile": "15793.htm",
            "signature": "trigger.timer[N].clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the timer event detector and overrun indicator for the specified trigger timer number.",
            "details": "This command sets the timer event detector to the undetected state and resets the overrun indicator.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "trigger.timer[N].clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.timer[1].clear();",
                    "description": "Clears trigger timer 1.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].count"
            ]
        },
        {
            "name": "trigger.timer[N].delay",
            "webhelpfile": "15794.htm",
            "signature": "",
            "command_return": "interval",
            "type": "Attribute (RW)\n",
            "default_value": "10e-6 (10 \u00b5s)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets and reads the timer delay.",
            "details": "Once the timer is enabled, each time the timer is triggered, it uses this delay period.Assigning a value to this attribute is equivalent to:This creates a delay list of one value.Reading this attribute returns the delay interval that is used the next time the timer is triggered.",
            "param_info": [
                {
                    "name": "interval",
                    "description": "Delay interval in seconds (0.5 \u00b5s to 100\u00a0ks)",
                    "enum": "",
                    "type": "number",
                    "range": "(0.5 \u00b5s to 100\u00a0ks)"
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "interval = trigger.timer[N].delay",
                "trigger.timer[N].delay = interval"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.timer[1].delay = 50e-6;",
                    "description": "Set the trigger timer 1 to delay for 50\u00a0\u00b5s.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].reset()"
            ]
        },
        {
            "name": "trigger.timer[N].delaylist",
            "webhelpfile": "15795.htm",
            "signature": "",
            "command_return": "intervals",
            "type": "Attribute (RW)\n",
            "default_value": "10e-6 (10 \u00b5s)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets an array of timer intervals.",
            "details": "Each time the timer is triggered after it is enabled, it uses the next delay period from the array. The default value is an array with one value of 10 \u00b5s.After all elements in the array have been used, the delays restart at the beginning of the list.If the array contains more than one element, the average of the delay intervals in the list must be \u2265\u00a050\u00a0\u00b5s.",
            "param_info": [
                {
                    "name": "intervals",
                    "description": "Table of delay intervals in seconds",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "intervals = trigger.timer[N].delaylist",
                "trigger.timer[N].delaylist = intervals"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.timer[3].delaylist = {50e-6, 100e-6, 150e-6};DelayList = trigger.timer[3].delaylist;for x = 1, table.getn(DelayList) do;   print(DelayList[x]);end;",
                    "description": "Set a delay list on trigger timer 3 with three delays (50 \u00b5s, 100 \u00b5s, and 150 \u00b5s).\n--- --Read the delay list on trigger timer\u00a03.\n--- --Output:\n--- --5e-05\n--- --0.0001\n--- --0.00015\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].reset()"
            ]
        },
        {
            "name": "trigger.timer[N].EVENT_ID",
            "webhelpfile": "15796.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant specifies the trigger timer event number.",
            "details": "This constant is an identification number that identifies events generated by this timer.Set the stimulus of any trigger object to the value of this constant to have the trigger object respond to events from this timer.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The trigger event number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "eventID = trigger.timer[N].EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.channel.stimulus = trigger.timer[2].EVENT_ID;",
                    "description": "Sets the trigger stimulus of the channel event detector to trigger timer 2 event.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "trigger.timer[N].overrun",
            "webhelpfile": "15797.htm",
            "signature": "",
            "command_return": "overrun",
            "type": "Attribute (R)\n",
            "default_value": "false\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if an event was ignored because of the event detector state.",
            "details": "This command indicates if an event was ignored because the event detector was already in the detected state when the event occurred.",
            "param_info": [
                {
                    "name": "overrun",
                    "description": "Trigger overrun state (true or false)",
                    "enum": "",
                    "type": "any",
                    "range": "(true or false)"
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "overrun = trigger.timer[N].overrun"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(trigger.timer[1].overrun);",
                    "description": "If an event was ignored, the output is true.\n--- --If the event was not ignored, the output is false.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].reset()"
            ]
        },
        {
            "name": "trigger.timer[N].passthrough",
            "webhelpfile": "15798.htm",
            "signature": "",
            "command_return": "passthrough",
            "type": "Attribute (RW)\n",
            "default_value": "false (disabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables the timer trigger pass\u2011through mode.",
            "details": "When pass-through mode is enabled, triggers are passed through immediately and initiate the delay. When disabled, a trigger only initiates a delay.",
            "param_info": [
                {
                    "name": "passthrough",
                    "description": "The state of pass-through mode; set to one of the following values",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "passthrough = trigger.timer[N].passthrough",
                "trigger.timer[N].passthrough = passthrough"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.timer[1].passthrough = true;",
                    "description": "Enables pass\u2011through mode on trigger timer 1.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].reset()"
            ]
        },
        {
            "name": "trigger.timer[N].wait()",
            "webhelpfile": "15800.htm",
            "signature": "trigger.timer[N].wait(timeout)",
            "command_return": "triggered",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function waits for a trigger.",
            "details": "If one or more trigger events were detected since the last time trigger.timer[N].wait() or trigger.timer[N].clear() was called, this function returns immediately.After waiting for a trigger with this function, the event detector is automatically reset and rearmed. This is true regardless of the number of events detected.",
            "param_info": [
                {
                    "name": "triggered",
                    "description": "Trigger detection indication",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                },
                {
                    "name": "timeout",
                    "description": "Maximum amount of time in seconds to wait for the trigger",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "triggered = trigger.timer[N].wait(timeout)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "triggered = trigger.timer[3].wait(10);print(triggered);",
                    "description": "Waits up to 10 s for a trigger on timer 3.\n--- --If false is returned, no trigger was detected during the 10\u00a0s timeout.\n--- --If true is returned, a trigger was detected.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].clear()"
            ]
        },
        {
            "name": "trigger.wait()",
            "webhelpfile": "15801.htm",
            "signature": "trigger.wait(timeout)",
            "command_return": "triggered",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function waits for a command interface trigger event.",
            "details": "This function waits up to timeout seconds for a trigger on the active command interface. A command interface trigger occurs when:If one or more of these trigger events were previously detected, this function returns immediately.After waiting for a trigger with this function, the event detector is automatically reset and rearmed. This is true regardless of the number of events detected.",
            "param_info": [
                {
                    "name": "triggered",
                    "description": "true",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "timeout",
                    "description": "Maximum amount of time in seconds to wait for the trigger",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "triggered = trigger.wait(timeout)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "triggered = trigger.wait(10);print(triggered);",
                    "description": "Waits up to 10 seconds for a trigger.\n--- --If false is returned, no trigger was detected during the 10\u2011second timeout.\n--- --If true is returned, a trigger was detected.\n"
                }
            ],
            "related_commands": [
                "trigger.clear()"
            ]
        },
        {
            "name": "trigger.timer[N].count",
            "webhelpfile": "15820.htm",
            "signature": "",
            "command_return": "count",
            "type": "Attribute (RW)\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the number of events to generate each time the timer generates a trigger event.",
            "details": "If the count is set to a number greater than 1, the timer automatically starts the next trigger timer delay at the expiration of the previous delay.Set the count to zero (0) to cause the timer to generate trigger events indefinitely.If you use the trigger timer with a trigger model, make sure the count value is the same or more than any count values expected in the trigger model.",
            "param_info": [
                {
                    "name": "count",
                    "description": "Number of times to repeat the trigger (0 to 1,048,575)",
                    "enum": "",
                    "type": "number",
                    "range": "(0 to 1,048,575)"
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "count = trigger.timer[N].count",
                "trigger.timer[N].count = count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(trigger.timer[1].count);",
                    "description": "Read trigger count for timer number 1.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].clear()",
                "trigger.timer[N].delay",
                "trigger.timer[N].reset()"
            ]
        },
        {
            "name": "status.condition",
            "webhelpfile": "15822.htm",
            "signature": "",
            "command_return": "statusByte",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the status byte condition register.",
            "details": "This attribute is used to read the status byte, which is returned as a numeric value. The binary equivalent of the value of this attribute indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B7. For example, if a value of 1.29000e+02 (which is 129) is read as the value of this register, the binary equivalent is 1000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitThe returned value can indicate one or more status events occurred. When an enabled status event occurs, a summary bit is set in this register to indicate the event occurrence.The individual bits of this register have the meanings described in the following table.In addition to the above constants, when more than one bit of the register is set, statusByte equals the sum of their decimal weights. For example, if 129 is returned, bits B0 and B7 are set (1 + 128).",
            "param_info": [
                {
                    "name": "statusByte",
                    "description": "The status byte; a zero (0) indicates no bits set; other values indicate various bit\u00a0settings",
                    "enum": "",
                    "type": "number",
                    "range": "(0)"
                }
            ],
            "usage": [
                "statusByte = status.condition"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "statusByte = status.condition;print(statusByte);",
                    "description": "Returns statusByte.\n--- --Sample output:\n--- --1.29000e+02\n--- --Converting this output (129) to its binary equivalent yields 1000 0001 \n--- --Therefore, this output indicates that the set bits of the status byte condition register are presently B0 (MSS) and B7 (OSB).\n"
                }
            ],
            "related_commands": [
                "Status byte and service request (SRQ)"
            ]
        },
        {
            "name": "status.measurement.condition",
            "webhelpfile": "15823.htm",
            "signature": "",
            "command_return": "measurementRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes contain the measurement event register set.",
            "details": "These attributes read or write the measurement event registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, assume value 384 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a01000\u00a00000. This value indicates that bit B7 (ROF) and bit B8 (BAV) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.For example, assume value 257 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a00000\u00a00001. This value indicates that bit B0 (VLMT) and bit B8 (BAV) are set.* Least significant bit** Most significant bitIn addition to the above constants, measurementRegister can be set to the decimal equivalent of the bit to set. To set more than one bit of the register, set measurementRegister to the sum of their decimal weights. For example, to set bits B1 and B8, set measurementRegister to 258 (which is the sum of 2 + 256). ",
            "param_info": [
                {
                    "name": "measurementRegister",
                    "description": "The status of the measurement event register; a zero (0) indicates no bits set (also send 0 to clear all bits);the only valid value other than 0 is 8",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "measurementRegister = status.measurement.condition",
                "measurementRegister = status.measurement.enable",
                "measurementRegister = status.measurement.event",
                "measurementRegister = status.measurement.ntr",
                "measurementRegister = status.measurement.ptr",
                "status.measurement.enable = measurementRegister",
                "status.measurement.ntr = measurementRegister",
                "status.measurement.ptr = measurementRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "status.measurement.enable = status.measurement.BAV;",
                    "description": "Sets the BAV bit of the measurement event enable register.\n"
                }
            ],
            "related_commands": [
                "Measurement summary bit (Measurement event register)"
            ]
        },
        {
            "name": "status.measurement.enable",
            "webhelpfile": "15823.htm",
            "signature": "",
            "command_return": "measurementRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes contain the measurement event register set.",
            "details": "These attributes read or write the measurement event registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, assume value 384 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a01000\u00a00000. This value indicates that bit B7 (ROF) and bit B8 (BAV) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.For example, assume value 257 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a00000\u00a00001. This value indicates that bit B0 (VLMT) and bit B8 (BAV) are set.* Least significant bit** Most significant bitIn addition to the above constants, measurementRegister can be set to the decimal equivalent of the bit to set. To set more than one bit of the register, set measurementRegister to the sum of their decimal weights. For example, to set bits B1 and B8, set measurementRegister to 258 (which is the sum of 2 + 256). ",
            "param_info": [
                {
                    "name": "measurementRegister",
                    "description": "The status of the measurement event register; a zero (0) indicates no bits set (also send 0 to clear all bits);the only valid value other than 0 is 8",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "measurementRegister = status.measurement.condition",
                "measurementRegister = status.measurement.enable",
                "measurementRegister = status.measurement.event",
                "measurementRegister = status.measurement.ntr",
                "measurementRegister = status.measurement.ptr",
                "status.measurement.enable = measurementRegister",
                "status.measurement.ntr = measurementRegister",
                "status.measurement.ptr = measurementRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "status.measurement.enable = status.measurement.BAV;",
                    "description": "Sets the BAV bit of the measurement event enable register.\n"
                }
            ],
            "related_commands": [
                "Measurement summary bit (Measurement event register)"
            ]
        },
        {
            "name": "status.measurement.event",
            "webhelpfile": "15823.htm",
            "signature": "",
            "command_return": "measurementRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes contain the measurement event register set.",
            "details": "These attributes read or write the measurement event registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, assume value 384 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a01000\u00a00000. This value indicates that bit B7 (ROF) and bit B8 (BAV) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.For example, assume value 257 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a00000\u00a00001. This value indicates that bit B0 (VLMT) and bit B8 (BAV) are set.* Least significant bit** Most significant bitIn addition to the above constants, measurementRegister can be set to the decimal equivalent of the bit to set. To set more than one bit of the register, set measurementRegister to the sum of their decimal weights. For example, to set bits B1 and B8, set measurementRegister to 258 (which is the sum of 2 + 256). ",
            "param_info": [
                {
                    "name": "measurementRegister",
                    "description": "The status of the measurement event register; a zero (0) indicates no bits set (also send 0 to clear all bits);the only valid value other than 0 is 8",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "measurementRegister = status.measurement.condition",
                "measurementRegister = status.measurement.enable",
                "measurementRegister = status.measurement.event",
                "measurementRegister = status.measurement.ntr",
                "measurementRegister = status.measurement.ptr",
                "status.measurement.enable = measurementRegister",
                "status.measurement.ntr = measurementRegister",
                "status.measurement.ptr = measurementRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "status.measurement.enable = status.measurement.BAV;",
                    "description": "Sets the BAV bit of the measurement event enable register.\n"
                }
            ],
            "related_commands": [
                "Measurement summary bit (Measurement event register)"
            ]
        },
        {
            "name": "status.measurement.ntr",
            "webhelpfile": "15823.htm",
            "signature": "",
            "command_return": "measurementRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes contain the measurement event register set.",
            "details": "These attributes read or write the measurement event registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, assume value 384 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a01000\u00a00000. This value indicates that bit B7 (ROF) and bit B8 (BAV) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.For example, assume value 257 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a00000\u00a00001. This value indicates that bit B0 (VLMT) and bit B8 (BAV) are set.* Least significant bit** Most significant bitIn addition to the above constants, measurementRegister can be set to the decimal equivalent of the bit to set. To set more than one bit of the register, set measurementRegister to the sum of their decimal weights. For example, to set bits B1 and B8, set measurementRegister to 258 (which is the sum of 2 + 256). ",
            "param_info": [
                {
                    "name": "measurementRegister",
                    "description": "The status of the measurement event register; a zero (0) indicates no bits set (also send 0 to clear all bits);the only valid value other than 0 is 8",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "measurementRegister = status.measurement.condition",
                "measurementRegister = status.measurement.enable",
                "measurementRegister = status.measurement.event",
                "measurementRegister = status.measurement.ntr",
                "measurementRegister = status.measurement.ptr",
                "status.measurement.enable = measurementRegister",
                "status.measurement.ntr = measurementRegister",
                "status.measurement.ptr = measurementRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "status.measurement.enable = status.measurement.BAV;",
                    "description": "Sets the BAV bit of the measurement event enable register.\n"
                }
            ],
            "related_commands": [
                "Measurement summary bit (Measurement event register)"
            ]
        },
        {
            "name": "status.measurement.ptr",
            "webhelpfile": "15823.htm",
            "signature": "",
            "command_return": "measurementRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes contain the measurement event register set.",
            "details": "These attributes read or write the measurement event registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, assume value 384 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a01000\u00a00000. This value indicates that bit B7 (ROF) and bit B8 (BAV) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.For example, assume value 257 is returned for the enable register. The binary equivalent is 0000\u00a00001\u00a00000\u00a00001. This value indicates that bit B0 (VLMT) and bit B8 (BAV) are set.* Least significant bit** Most significant bitIn addition to the above constants, measurementRegister can be set to the decimal equivalent of the bit to set. To set more than one bit of the register, set measurementRegister to the sum of their decimal weights. For example, to set bits B1 and B8, set measurementRegister to 258 (which is the sum of 2 + 256). ",
            "param_info": [
                {
                    "name": "measurementRegister",
                    "description": "The status of the measurement event register; a zero (0) indicates no bits set (also send 0 to clear all bits);the only valid value other than 0 is 8",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "measurementRegister = status.measurement.condition",
                "measurementRegister = status.measurement.enable",
                "measurementRegister = status.measurement.event",
                "measurementRegister = status.measurement.ntr",
                "measurementRegister = status.measurement.ptr",
                "status.measurement.enable = measurementRegister",
                "status.measurement.ntr = measurementRegister",
                "status.measurement.ptr = measurementRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "status.measurement.enable = status.measurement.BAV;",
                    "description": "Sets the BAV bit of the measurement event enable register.\n"
                }
            ],
            "related_commands": [
                "Measurement summary bit (Measurement event register)"
            ]
        },
        {
            "name": "status.node_enable",
            "webhelpfile": "15830.htm",
            "signature": "",
            "command_return": "nodeEnableRegister",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the system node enable register. ",
            "details": "This attribute is used to read or write to the system node enable register. Reading the system node enable register returns a value. The binary equivalent of the value of this attribute indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B7. For example, if a value of 1.29000e+02 (which is 129) is read as the value of this register, the binary equivalent is 1000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitAssigning a value to this attribute enables one or more status events. When an enabled status event occurs, a summary bit is set in the appropriate system summary register. The register and bit that is set depends on the TSP-Link node number assigned to this instrument.For information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set the B0 bit of the system node enable register, set status.node_enable\u00a0=\u00a0status.MSB.In addition to the above values, nodeEnableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set nodeEnableRegister to the sum of their decimal weights. For example, to set bits B0 and B7, set nodeEnableRegister to 129 (1 + 128).",
            "param_info": [
                {
                    "name": "nodeEnableRegister",
                    "description": "The status of the system node enable register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "nodeEnableRegister = node_enable",
                "node_enable = nodeEnableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "nodeEnableRegister = status.MSB + status.OSB;status.node_enable = nodeEnableRegister;",
                    "description": "Use constants to set the MSB and OSB bits of the system node enable register.\n"
                },
                {
                    "example": "-- decimal 129 = binary 10000001;nodeEnableRegister = 129;status.node_enable = nodeEnableRegister;",
                    "description": "Sets the MSB and OSB bits of the system node enable register using a decimal value.\n"
                }
            ],
            "related_commands": [
                "status.condition",
                "status.system.*",
                "Status byte and service request (SRQ)"
            ]
        },
        {
            "name": "status.node_event",
            "webhelpfile": "15831.htm",
            "signature": "",
            "command_return": "nodeEventRegister",
            "type": "Attribute (R)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the status node event register.",
            "details": "This attribute is used to read the status node event register, which is returned as a numeric value (reading this register returns a value). The binary equivalent of the value of this attribute indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B7. For example, if a value of 1.29000e+02 (which is 129) is read as the value of this register, the binary equivalent is 1000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitThe returned value can indicate one or more status events occurred.In addition to the above constants, nodeEventRegister can be set to the decimal equivalent of the bits set. When more than one bit of the register is set, nodeEventRegister contains the sum of their decimal weights. For example, if 129 is returned, bits B0 and B7 are set (1 + 128).",
            "param_info": [
                {
                    "name": "nodeEventRegister",
                    "description": "The status of the node event register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "nodeEventRegister = node_event"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "nodeEventRegister = status.node_event;print(nodeEventRegister);",
                    "description": "Reads the status node event register.\n--- --Sample output:\n--- --1.29000e+02\n--- --Converting this output (129) to its binary equivalent yields 1000 0001. Therefore, this output indicates that the set bits of the status byte condition register are presently B0 (MSB) and B7 (OSB).\n"
                }
            ],
            "related_commands": [
                "Status byte and service request (SRQ)",
                "status.condition",
                "status.system.*"
            ]
        },
        {
            "name": "status.operation.condition",
            "webhelpfile": "15833.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status register set of the status model.",
            "details": "These attributes read or write the operation status registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 2.04800e+04 (which is 20,480) is read as the value of the condition register, the binary equivalent is 0101\u00a00000\u00a00000\u00a00000. This value indicates that bit B14 (PROGRAM_RUNNING) and bit B12 (USER) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B12 of the operation status enable register, set status.operation.enable = status.operation.USER.In addition to the above constants, operationRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal weights. For example, to set bits B12 and B14, set operationRegister to 20,480 (which is the sum of 4,096 + 16,384). The used bits of the operation event registers are:",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.condition",
                "operationRegister = status.operation.enable",
                "operationRegister = status.operation.event",
                "operationRegister = status.operation.ntr",
                "operationRegister = status.operation.ptr",
                "status.operation.enable = operationRegister",
                "status.operation.ntr = operationRegister",
                "status.operation.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.USER + status.operation.PROG;status.operation.enable = operationRegister;",
                    "description": "Uses constants to set the USER and PROG bits of the operation status enable register.\n"
                },
                {
                    "example": "-- decimal 20480 = binary 0101 0000 0000 0000;operationRegister = 20480;status.operation.enable = operationRegister;",
                    "description": "Uses a decimal value to set the USER and PROG bits of the operation status enable register.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "status.operation.enable",
            "webhelpfile": "15833.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status register set of the status model.",
            "details": "These attributes read or write the operation status registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 2.04800e+04 (which is 20,480) is read as the value of the condition register, the binary equivalent is 0101\u00a00000\u00a00000\u00a00000. This value indicates that bit B14 (PROGRAM_RUNNING) and bit B12 (USER) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B12 of the operation status enable register, set status.operation.enable = status.operation.USER.In addition to the above constants, operationRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal weights. For example, to set bits B12 and B14, set operationRegister to 20,480 (which is the sum of 4,096 + 16,384). The used bits of the operation event registers are:",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.condition",
                "operationRegister = status.operation.enable",
                "operationRegister = status.operation.event",
                "operationRegister = status.operation.ntr",
                "operationRegister = status.operation.ptr",
                "status.operation.enable = operationRegister",
                "status.operation.ntr = operationRegister",
                "status.operation.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.USER + status.operation.PROG;status.operation.enable = operationRegister;",
                    "description": "Uses constants to set the USER and PROG bits of the operation status enable register.\n"
                },
                {
                    "example": "-- decimal 20480 = binary 0101 0000 0000 0000;operationRegister = 20480;status.operation.enable = operationRegister;",
                    "description": "Uses a decimal value to set the USER and PROG bits of the operation status enable register.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "status.operation.event",
            "webhelpfile": "15833.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status register set of the status model.",
            "details": "These attributes read or write the operation status registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 2.04800e+04 (which is 20,480) is read as the value of the condition register, the binary equivalent is 0101\u00a00000\u00a00000\u00a00000. This value indicates that bit B14 (PROGRAM_RUNNING) and bit B12 (USER) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B12 of the operation status enable register, set status.operation.enable = status.operation.USER.In addition to the above constants, operationRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal weights. For example, to set bits B12 and B14, set operationRegister to 20,480 (which is the sum of 4,096 + 16,384). The used bits of the operation event registers are:",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.condition",
                "operationRegister = status.operation.enable",
                "operationRegister = status.operation.event",
                "operationRegister = status.operation.ntr",
                "operationRegister = status.operation.ptr",
                "status.operation.enable = operationRegister",
                "status.operation.ntr = operationRegister",
                "status.operation.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.USER + status.operation.PROG;status.operation.enable = operationRegister;",
                    "description": "Uses constants to set the USER and PROG bits of the operation status enable register.\n"
                },
                {
                    "example": "-- decimal 20480 = binary 0101 0000 0000 0000;operationRegister = 20480;status.operation.enable = operationRegister;",
                    "description": "Uses a decimal value to set the USER and PROG bits of the operation status enable register.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "status.operation.ntr",
            "webhelpfile": "15833.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status register set of the status model.",
            "details": "These attributes read or write the operation status registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 2.04800e+04 (which is 20,480) is read as the value of the condition register, the binary equivalent is 0101\u00a00000\u00a00000\u00a00000. This value indicates that bit B14 (PROGRAM_RUNNING) and bit B12 (USER) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B12 of the operation status enable register, set status.operation.enable = status.operation.USER.In addition to the above constants, operationRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal weights. For example, to set bits B12 and B14, set operationRegister to 20,480 (which is the sum of 4,096 + 16,384). The used bits of the operation event registers are:",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.condition",
                "operationRegister = status.operation.enable",
                "operationRegister = status.operation.event",
                "operationRegister = status.operation.ntr",
                "operationRegister = status.operation.ptr",
                "status.operation.enable = operationRegister",
                "status.operation.ntr = operationRegister",
                "status.operation.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.USER + status.operation.PROG;status.operation.enable = operationRegister;",
                    "description": "Uses constants to set the USER and PROG bits of the operation status enable register.\n"
                },
                {
                    "example": "-- decimal 20480 = binary 0101 0000 0000 0000;operationRegister = 20480;status.operation.enable = operationRegister;",
                    "description": "Uses a decimal value to set the USER and PROG bits of the operation status enable register.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "status.operation.ptr",
            "webhelpfile": "15833.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status register set of the status model.",
            "details": "These attributes read or write the operation status registers.Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 2.04800e+04 (which is 20,480) is read as the value of the condition register, the binary equivalent is 0101\u00a00000\u00a00000\u00a00000. This value indicates that bit B14 (PROGRAM_RUNNING) and bit B12 (USER) are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B12 of the operation status enable register, set status.operation.enable = status.operation.USER.In addition to the above constants, operationRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal weights. For example, to set bits B12 and B14, set operationRegister to 20,480 (which is the sum of 4,096 + 16,384). The used bits of the operation event registers are:",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.condition",
                "operationRegister = status.operation.enable",
                "operationRegister = status.operation.event",
                "operationRegister = status.operation.ntr",
                "operationRegister = status.operation.ptr",
                "status.operation.enable = operationRegister",
                "status.operation.ntr = operationRegister",
                "status.operation.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.USER + status.operation.PROG;status.operation.enable = operationRegister;",
                    "description": "Uses constants to set the USER and PROG bits of the operation status enable register.\n"
                },
                {
                    "example": "-- decimal 20480 = binary 0101 0000 0000 0000;operationRegister = 20480;status.operation.enable = operationRegister;",
                    "description": "Uses a decimal value to set the USER and PROG bits of the operation status enable register.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "status.operation.user.condition",
            "webhelpfile": "15852.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status user register set of the status model.",
            "details": "These attributes are used to read or write to the operation status user registers. Reading a status register returns a value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bits B0 and B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the operation status user enable register, set status.operation.user.enable = status.operation.user.BIT0.In addition to the above constants, operationRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal values. For example, to set bits B11 and B14, set operationRegister to 18,432 (which is the sum of 2,048\u00a0+\u00a016,384). ",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status user register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.user.condition",
                "operationRegister = status.operation.user.enable",
                "operationRegister = status.operation.user.event",
                "operationRegister = status.operation.user.ntr",
                "operationRegister = status.operation.user.ptr",
                "status.operation.user.condition = operationRegister",
                "status.operation.user.enable = operationRegister",
                "status.operation.user.ntr = operationRegister",
                "status.operation.user.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.user.BIT11 + status.operation.user.BIT14;status.operation.user.enable = operationRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the operation status user enable register.\n"
                },
                {
                    "example": "-- 18432 = binary 0100 1000 0000 0000;operationRegister = 18432;status.operation.enable = operationRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the operation status user enable register.\n"
                }
            ],
            "related_commands": [
                "status.operation.*"
            ]
        },
        {
            "name": "status.operation.user.enable",
            "webhelpfile": "15852.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status user register set of the status model.",
            "details": "These attributes are used to read or write to the operation status user registers. Reading a status register returns a value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bits B0 and B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the operation status user enable register, set status.operation.user.enable = status.operation.user.BIT0.In addition to the above constants, operationRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal values. For example, to set bits B11 and B14, set operationRegister to 18,432 (which is the sum of 2,048\u00a0+\u00a016,384). ",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status user register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.user.condition",
                "operationRegister = status.operation.user.enable",
                "operationRegister = status.operation.user.event",
                "operationRegister = status.operation.user.ntr",
                "operationRegister = status.operation.user.ptr",
                "status.operation.user.condition = operationRegister",
                "status.operation.user.enable = operationRegister",
                "status.operation.user.ntr = operationRegister",
                "status.operation.user.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.user.BIT11 + status.operation.user.BIT14;status.operation.user.enable = operationRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the operation status user enable register.\n"
                },
                {
                    "example": "-- 18432 = binary 0100 1000 0000 0000;operationRegister = 18432;status.operation.enable = operationRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the operation status user enable register.\n"
                }
            ],
            "related_commands": [
                "status.operation.*"
            ]
        },
        {
            "name": "status.operation.user.event",
            "webhelpfile": "15852.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status user register set of the status model.",
            "details": "These attributes are used to read or write to the operation status user registers. Reading a status register returns a value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bits B0 and B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the operation status user enable register, set status.operation.user.enable = status.operation.user.BIT0.In addition to the above constants, operationRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal values. For example, to set bits B11 and B14, set operationRegister to 18,432 (which is the sum of 2,048\u00a0+\u00a016,384). ",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status user register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.user.condition",
                "operationRegister = status.operation.user.enable",
                "operationRegister = status.operation.user.event",
                "operationRegister = status.operation.user.ntr",
                "operationRegister = status.operation.user.ptr",
                "status.operation.user.condition = operationRegister",
                "status.operation.user.enable = operationRegister",
                "status.operation.user.ntr = operationRegister",
                "status.operation.user.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.user.BIT11 + status.operation.user.BIT14;status.operation.user.enable = operationRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the operation status user enable register.\n"
                },
                {
                    "example": "-- 18432 = binary 0100 1000 0000 0000;operationRegister = 18432;status.operation.enable = operationRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the operation status user enable register.\n"
                }
            ],
            "related_commands": [
                "status.operation.*"
            ]
        },
        {
            "name": "status.operation.user.ntr",
            "webhelpfile": "15852.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status user register set of the status model.",
            "details": "These attributes are used to read or write to the operation status user registers. Reading a status register returns a value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bits B0 and B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the operation status user enable register, set status.operation.user.enable = status.operation.user.BIT0.In addition to the above constants, operationRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal values. For example, to set bits B11 and B14, set operationRegister to 18,432 (which is the sum of 2,048\u00a0+\u00a016,384). ",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status user register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.user.condition",
                "operationRegister = status.operation.user.enable",
                "operationRegister = status.operation.user.event",
                "operationRegister = status.operation.user.ntr",
                "operationRegister = status.operation.user.ptr",
                "status.operation.user.condition = operationRegister",
                "status.operation.user.enable = operationRegister",
                "status.operation.user.ntr = operationRegister",
                "status.operation.user.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.user.BIT11 + status.operation.user.BIT14;status.operation.user.enable = operationRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the operation status user enable register.\n"
                },
                {
                    "example": "-- 18432 = binary 0100 1000 0000 0000;operationRegister = 18432;status.operation.enable = operationRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the operation status user enable register.\n"
                }
            ],
            "related_commands": [
                "status.operation.*"
            ]
        },
        {
            "name": "status.operation.user.ptr",
            "webhelpfile": "15852.htm",
            "signature": "",
            "command_return": "operationRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the operation status user register set of the status model.",
            "details": "These attributes are used to read or write to the operation status user registers. Reading a status register returns a value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bits B0 and B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the operation status user enable register, set status.operation.user.enable = status.operation.user.BIT0.In addition to the above constants, operationRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set operationRegister to the sum of their decimal values. For example, to set bits B11 and B14, set operationRegister to 18,432 (which is the sum of 2,048\u00a0+\u00a016,384). ",
            "param_info": [
                {
                    "name": "operationRegister",
                    "description": "The status of the operation status user register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "operationRegister = status.operation.user.condition",
                "operationRegister = status.operation.user.enable",
                "operationRegister = status.operation.user.event",
                "operationRegister = status.operation.user.ntr",
                "operationRegister = status.operation.user.ptr",
                "status.operation.user.condition = operationRegister",
                "status.operation.user.enable = operationRegister",
                "status.operation.user.ntr = operationRegister",
                "status.operation.user.ptr = operationRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "operationRegister = status.operation.user.BIT11 + status.operation.user.BIT14;status.operation.user.enable = operationRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the operation status user enable register.\n"
                },
                {
                    "example": "-- 18432 = binary 0100 1000 0000 0000;operationRegister = 18432;status.operation.enable = operationRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the operation status user enable register.\n"
                }
            ],
            "related_commands": [
                "status.operation.*"
            ]
        },
        {
            "name": "status.questionable.condition",
            "webhelpfile": "15853.htm",
            "signature": "",
            "command_return": "questionableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the questionable status register set of the status model.",
            "details": "These attributes are used to read or write to the questionable status registers. Reading a status register returns a value. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.22880e+04 (which is 12,288) is read as the value of the condition register, the binary equivalent is 0011\u00a00000\u00a00000\u00a00000. This value indicates that bits B12 and B13 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B9 of the questionable status enable register, set status.questionable.enable = status.questionable.SLOT1_THERMAL.In addition to the above constants, questionableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set questionableRegister to the sum of their decimal weights. For example, to set bits B12 and B13, set questionableRegister to 12,288 (which is the sum of 4,096 + 8,192). ",
            "param_info": [
                {
                    "name": "questionableRegister",
                    "description": "The status of the questionable status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "questionableRegister = status.questionable.condition",
                "questionableRegister = status.questionable.enable",
                "questionableRegister = status.questionable.event",
                "questionableRegister = status.questionable.ntr",
                "questionableRegister = status.questionable.ptr",
                "status.questionable.enable = questionableRegister",
                "status.questionable.ntr = questionableRegister",
                "status.questionable.ptr = questionableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "questionableRegister = status.questionable.S1INL + status.questionable.S6INL;status.questionable.enable = questionableRegister;",
                    "description": "Uses constants to set bits B1 and B6 of the status questionable enable register.\n"
                },
                {
                    "example": "-- decimal 66 = binary 0100 0010;questionableRegister = 66;status.questionable.enable = questionableRegister;",
                    "description": "Uses a decimal value to set bits B1 and B6 of the status questionable enable register.\n"
                }
            ],
            "related_commands": [
                "Questionable summary bit (Questionable event register)"
            ]
        },
        {
            "name": "status.questionable.enable",
            "webhelpfile": "15853.htm",
            "signature": "",
            "command_return": "questionableRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the questionable status register set of the status model.",
            "details": "These attributes are used to read or write to the questionable status registers. Reading a status register returns a value. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.22880e+04 (which is 12,288) is read as the value of the condition register, the binary equivalent is 0011\u00a00000\u00a00000\u00a00000. This value indicates that bits B12 and B13 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B9 of the questionable status enable register, set status.questionable.enable = status.questionable.SLOT1_THERMAL.In addition to the above constants, questionableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set questionableRegister to the sum of their decimal weights. For example, to set bits B12 and B13, set questionableRegister to 12,288 (which is the sum of 4,096 + 8,192). ",
            "param_info": [
                {
                    "name": "questionableRegister",
                    "description": "The status of the questionable status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "questionableRegister = status.questionable.condition",
                "questionableRegister = status.questionable.enable",
                "questionableRegister = status.questionable.event",
                "questionableRegister = status.questionable.ntr",
                "questionableRegister = status.questionable.ptr",
                "status.questionable.enable = questionableRegister",
                "status.questionable.ntr = questionableRegister",
                "status.questionable.ptr = questionableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "questionableRegister = status.questionable.S1INL + status.questionable.S6INL;status.questionable.enable = questionableRegister;",
                    "description": "Uses constants to set bits B1 and B6 of the status questionable enable register.\n"
                },
                {
                    "example": "-- decimal 66 = binary 0100 0010;questionableRegister = 66;status.questionable.enable = questionableRegister;",
                    "description": "Uses a decimal value to set bits B1 and B6 of the status questionable enable register.\n"
                }
            ],
            "related_commands": [
                "Questionable summary bit (Questionable event register)"
            ]
        },
        {
            "name": "status.questionable.event",
            "webhelpfile": "15853.htm",
            "signature": "",
            "command_return": "questionableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the questionable status register set of the status model.",
            "details": "These attributes are used to read or write to the questionable status registers. Reading a status register returns a value. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.22880e+04 (which is 12,288) is read as the value of the condition register, the binary equivalent is 0011\u00a00000\u00a00000\u00a00000. This value indicates that bits B12 and B13 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B9 of the questionable status enable register, set status.questionable.enable = status.questionable.SLOT1_THERMAL.In addition to the above constants, questionableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set questionableRegister to the sum of their decimal weights. For example, to set bits B12 and B13, set questionableRegister to 12,288 (which is the sum of 4,096 + 8,192). ",
            "param_info": [
                {
                    "name": "questionableRegister",
                    "description": "The status of the questionable status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "questionableRegister = status.questionable.condition",
                "questionableRegister = status.questionable.enable",
                "questionableRegister = status.questionable.event",
                "questionableRegister = status.questionable.ntr",
                "questionableRegister = status.questionable.ptr",
                "status.questionable.enable = questionableRegister",
                "status.questionable.ntr = questionableRegister",
                "status.questionable.ptr = questionableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "questionableRegister = status.questionable.S1INL + status.questionable.S6INL;status.questionable.enable = questionableRegister;",
                    "description": "Uses constants to set bits B1 and B6 of the status questionable enable register.\n"
                },
                {
                    "example": "-- decimal 66 = binary 0100 0010;questionableRegister = 66;status.questionable.enable = questionableRegister;",
                    "description": "Uses a decimal value to set bits B1 and B6 of the status questionable enable register.\n"
                }
            ],
            "related_commands": [
                "Questionable summary bit (Questionable event register)"
            ]
        },
        {
            "name": "status.questionable.ntr",
            "webhelpfile": "15853.htm",
            "signature": "",
            "command_return": "questionableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the questionable status register set of the status model.",
            "details": "These attributes are used to read or write to the questionable status registers. Reading a status register returns a value. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.22880e+04 (which is 12,288) is read as the value of the condition register, the binary equivalent is 0011\u00a00000\u00a00000\u00a00000. This value indicates that bits B12 and B13 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B9 of the questionable status enable register, set status.questionable.enable = status.questionable.SLOT1_THERMAL.In addition to the above constants, questionableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set questionableRegister to the sum of their decimal weights. For example, to set bits B12 and B13, set questionableRegister to 12,288 (which is the sum of 4,096 + 8,192). ",
            "param_info": [
                {
                    "name": "questionableRegister",
                    "description": "The status of the questionable status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "questionableRegister = status.questionable.condition",
                "questionableRegister = status.questionable.enable",
                "questionableRegister = status.questionable.event",
                "questionableRegister = status.questionable.ntr",
                "questionableRegister = status.questionable.ptr",
                "status.questionable.enable = questionableRegister",
                "status.questionable.ntr = questionableRegister",
                "status.questionable.ptr = questionableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "questionableRegister = status.questionable.S1INL + status.questionable.S6INL;status.questionable.enable = questionableRegister;",
                    "description": "Uses constants to set bits B1 and B6 of the status questionable enable register.\n"
                },
                {
                    "example": "-- decimal 66 = binary 0100 0010;questionableRegister = 66;status.questionable.enable = questionableRegister;",
                    "description": "Uses a decimal value to set bits B1 and B6 of the status questionable enable register.\n"
                }
            ],
            "related_commands": [
                "Questionable summary bit (Questionable event register)"
            ]
        },
        {
            "name": "status.questionable.ptr",
            "webhelpfile": "15853.htm",
            "signature": "",
            "command_return": "questionableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the questionable status register set of the status model.",
            "details": "These attributes are used to read or write to the questionable status registers. Reading a status register returns a value. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.22880e+04 (which is 12,288) is read as the value of the condition register, the binary equivalent is 0011\u00a00000\u00a00000\u00a00000. This value indicates that bits B12 and B13 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B9 of the questionable status enable register, set status.questionable.enable = status.questionable.SLOT1_THERMAL.In addition to the above constants, questionableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set questionableRegister to the sum of their decimal weights. For example, to set bits B12 and B13, set questionableRegister to 12,288 (which is the sum of 4,096 + 8,192). ",
            "param_info": [
                {
                    "name": "questionableRegister",
                    "description": "The status of the questionable status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "questionableRegister = status.questionable.condition",
                "questionableRegister = status.questionable.enable",
                "questionableRegister = status.questionable.event",
                "questionableRegister = status.questionable.ntr",
                "questionableRegister = status.questionable.ptr",
                "status.questionable.enable = questionableRegister",
                "status.questionable.ntr = questionableRegister",
                "status.questionable.ptr = questionableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "questionableRegister = status.questionable.S1INL + status.questionable.S6INL;status.questionable.enable = questionableRegister;",
                    "description": "Uses constants to set bits B1 and B6 of the status questionable enable register.\n"
                },
                {
                    "example": "-- decimal 66 = binary 0100 0010;questionableRegister = 66;status.questionable.enable = questionableRegister;",
                    "description": "Uses a decimal value to set bits B1 and B6 of the status questionable enable register.\n"
                }
            ],
            "related_commands": [
                "Questionable summary bit (Questionable event register)"
            ]
        },
        {
            "name": "status.reset()",
            "webhelpfile": "15861.htm",
            "signature": "status.reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets all bits in the status model.",
            "details": "This function clears all status data structure registers (enable, event, NTR, and PTR) to their default values. For information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers.",
            "param_info": [],
            "usage": [
                "status.reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "status.reset();",
                    "description": "Resets the instrument status model.\n"
                }
            ],
            "related_commands": [
                "Status model"
            ]
        },
        {
            "name": "status.standard.condition",
            "webhelpfile": "15862.htm",
            "signature": "",
            "command_return": "standardRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the standard event status register set of the status model.",
            "details": "These attributes are used to read or write to the standard event status registers. Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the standard event status enable register, set status.standard.enable = status.standard.OPC.In addition to the above constants, standardRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set standardRegister to the sum of their decimal weights. For example, to set bits B0 and B4, set standardRegister to 17 (which is the sum of 1 + 16).",
            "param_info": [
                {
                    "name": "standardRegister",
                    "description": "The status of the standard event status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "standardRegister = status.standard.condition",
                "standardRegister = status.standard.enable",
                "standardRegister = status.standard.event",
                "standardRegister = status.standard.ntr",
                "standardRegister = status.standard.ptr",
                "status.standard.enable = standardRegister",
                "status.standard.ntr = standardRegister",
                "status.standard.ptr = standardRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "standardRegister = status.standard.OPC + status.standard.EXE;status.standard.enable = standardRegister;",
                    "description": "Uses constants to set the OPC and EXE bits of the standard event status enable register.\n"
                },
                {
                    "example": "-- decimal 17 = binary 0001 0001;standardRegister = 17;status.standard.enable = standardRegister;",
                    "description": "Uses the decimal value to set the OPC and EXE bits of the standard event status enable register.\n"
                }
            ],
            "related_commands": [
                "Event summary bit (ESB register)"
            ]
        },
        {
            "name": "status.standard.enable",
            "webhelpfile": "15862.htm",
            "signature": "",
            "command_return": "standardRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the standard event status register set of the status model.",
            "details": "These attributes are used to read or write to the standard event status registers. Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the standard event status enable register, set status.standard.enable = status.standard.OPC.In addition to the above constants, standardRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set standardRegister to the sum of their decimal weights. For example, to set bits B0 and B4, set standardRegister to 17 (which is the sum of 1 + 16).",
            "param_info": [
                {
                    "name": "standardRegister",
                    "description": "The status of the standard event status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "standardRegister = status.standard.condition",
                "standardRegister = status.standard.enable",
                "standardRegister = status.standard.event",
                "standardRegister = status.standard.ntr",
                "standardRegister = status.standard.ptr",
                "status.standard.enable = standardRegister",
                "status.standard.ntr = standardRegister",
                "status.standard.ptr = standardRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "standardRegister = status.standard.OPC + status.standard.EXE;status.standard.enable = standardRegister;",
                    "description": "Uses constants to set the OPC and EXE bits of the standard event status enable register.\n"
                },
                {
                    "example": "-- decimal 17 = binary 0001 0001;standardRegister = 17;status.standard.enable = standardRegister;",
                    "description": "Uses the decimal value to set the OPC and EXE bits of the standard event status enable register.\n"
                }
            ],
            "related_commands": [
                "Event summary bit (ESB register)"
            ]
        },
        {
            "name": "status.standard.event",
            "webhelpfile": "15862.htm",
            "signature": "",
            "command_return": "standardRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the standard event status register set of the status model.",
            "details": "These attributes are used to read or write to the standard event status registers. Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the standard event status enable register, set status.standard.enable = status.standard.OPC.In addition to the above constants, standardRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set standardRegister to the sum of their decimal weights. For example, to set bits B0 and B4, set standardRegister to 17 (which is the sum of 1 + 16).",
            "param_info": [
                {
                    "name": "standardRegister",
                    "description": "The status of the standard event status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "standardRegister = status.standard.condition",
                "standardRegister = status.standard.enable",
                "standardRegister = status.standard.event",
                "standardRegister = status.standard.ntr",
                "standardRegister = status.standard.ptr",
                "status.standard.enable = standardRegister",
                "status.standard.ntr = standardRegister",
                "status.standard.ptr = standardRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "standardRegister = status.standard.OPC + status.standard.EXE;status.standard.enable = standardRegister;",
                    "description": "Uses constants to set the OPC and EXE bits of the standard event status enable register.\n"
                },
                {
                    "example": "-- decimal 17 = binary 0001 0001;standardRegister = 17;status.standard.enable = standardRegister;",
                    "description": "Uses the decimal value to set the OPC and EXE bits of the standard event status enable register.\n"
                }
            ],
            "related_commands": [
                "Event summary bit (ESB register)"
            ]
        },
        {
            "name": "status.standard.ntr",
            "webhelpfile": "15862.htm",
            "signature": "",
            "command_return": "standardRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the standard event status register set of the status model.",
            "details": "These attributes are used to read or write to the standard event status registers. Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the standard event status enable register, set status.standard.enable = status.standard.OPC.In addition to the above constants, standardRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set standardRegister to the sum of their decimal weights. For example, to set bits B0 and B4, set standardRegister to 17 (which is the sum of 1 + 16).",
            "param_info": [
                {
                    "name": "standardRegister",
                    "description": "The status of the standard event status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "standardRegister = status.standard.condition",
                "standardRegister = status.standard.enable",
                "standardRegister = status.standard.event",
                "standardRegister = status.standard.ntr",
                "standardRegister = status.standard.ptr",
                "status.standard.enable = standardRegister",
                "status.standard.ntr = standardRegister",
                "status.standard.ptr = standardRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "standardRegister = status.standard.OPC + status.standard.EXE;status.standard.enable = standardRegister;",
                    "description": "Uses constants to set the OPC and EXE bits of the standard event status enable register.\n"
                },
                {
                    "example": "-- decimal 17 = binary 0001 0001;standardRegister = 17;status.standard.enable = standardRegister;",
                    "description": "Uses the decimal value to set the OPC and EXE bits of the standard event status enable register.\n"
                }
            ],
            "related_commands": [
                "Event summary bit (ESB register)"
            ]
        },
        {
            "name": "status.standard.ptr",
            "webhelpfile": "15862.htm",
            "signature": "",
            "command_return": "standardRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the standard event status register set of the status model.",
            "details": "These attributes are used to read or write to the standard event status registers. Reading a status register returns a value. The binary equivalent of the returned value indicates which register bits are set. The least significant bit of the binary number is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the standard event status enable register, set status.standard.enable = status.standard.OPC.In addition to the above constants, standardRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set standardRegister to the sum of their decimal weights. For example, to set bits B0 and B4, set standardRegister to 17 (which is the sum of 1 + 16).",
            "param_info": [
                {
                    "name": "standardRegister",
                    "description": "The status of the standard event status register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "standardRegister = status.standard.condition",
                "standardRegister = status.standard.enable",
                "standardRegister = status.standard.event",
                "standardRegister = status.standard.ntr",
                "standardRegister = status.standard.ptr",
                "status.standard.enable = standardRegister",
                "status.standard.ntr = standardRegister",
                "status.standard.ptr = standardRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "standardRegister = status.standard.OPC + status.standard.EXE;status.standard.enable = standardRegister;",
                    "description": "Uses constants to set the OPC and EXE bits of the standard event status enable register.\n"
                },
                {
                    "example": "-- decimal 17 = binary 0001 0001;standardRegister = 17;status.standard.enable = standardRegister;",
                    "description": "Uses the decimal value to set the OPC and EXE bits of the standard event status enable register.\n"
                }
            ],
            "related_commands": [
                "Event summary bit (ESB register)"
            ]
        },
        {
            "name": "status.system.condition",
            "webhelpfile": "15863.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 1 through 14. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary status enable register, set status.system.enable = status.system.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = status.system.condition",
                "enableRegister = status.system.enable",
                "enableRegister = status.system.event",
                "enableRegister = status.system.ntr",
                "enableRegister = status.system.ptr",
                "status.system.enable = enableRegister",
                "status.system.ntr = enableRegister",
                "status.system.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system.NODE11 + status.system.NODE14;status.system.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system.enable",
            "webhelpfile": "15863.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 1 through 14. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary status enable register, set status.system.enable = status.system.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = status.system.condition",
                "enableRegister = status.system.enable",
                "enableRegister = status.system.event",
                "enableRegister = status.system.ntr",
                "enableRegister = status.system.ptr",
                "status.system.enable = enableRegister",
                "status.system.ntr = enableRegister",
                "status.system.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system.NODE11 + status.system.NODE14;status.system.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system.event",
            "webhelpfile": "15863.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 1 through 14. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary status enable register, set status.system.enable = status.system.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = status.system.condition",
                "enableRegister = status.system.enable",
                "enableRegister = status.system.event",
                "enableRegister = status.system.ntr",
                "enableRegister = status.system.ptr",
                "status.system.enable = enableRegister",
                "status.system.ntr = enableRegister",
                "status.system.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system.NODE11 + status.system.NODE14;status.system.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system.ntr",
            "webhelpfile": "15863.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 1 through 14. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary status enable register, set status.system.enable = status.system.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = status.system.condition",
                "enableRegister = status.system.enable",
                "enableRegister = status.system.event",
                "enableRegister = status.system.ntr",
                "enableRegister = status.system.ptr",
                "status.system.enable = enableRegister",
                "status.system.ntr = enableRegister",
                "status.system.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system.NODE11 + status.system.NODE14;status.system.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system.ptr",
            "webhelpfile": "15863.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 1 through 14. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary status enable register, set status.system.enable = status.system.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = status.system.condition",
                "enableRegister = status.system.enable",
                "enableRegister = status.system.event",
                "enableRegister = status.system.ntr",
                "enableRegister = status.system.ptr",
                "status.system.enable = enableRegister",
                "status.system.ntr = enableRegister",
                "status.system.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system.NODE11 + status.system.NODE14;status.system.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system2.condition",
            "webhelpfile": "15864.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 15 through 28. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 2 enable register, set status.system2.enable = status.system2.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 2 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system2.condition",
                "enableRegister = system2.enable",
                "enableRegister = system2.event",
                "enableRegister = system2.ntr",
                "enableRegister = system2.ptr",
                "system2.enable = enableRegister",
                "system2.ntr = enableRegister",
                "system2.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system2.NODE25 + status.system2.NODE28;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 2 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system2.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 2 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system.*",
                "status.system3.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system2.enable",
            "webhelpfile": "15864.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 15 through 28. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 2 enable register, set status.system2.enable = status.system2.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 2 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system2.condition",
                "enableRegister = system2.enable",
                "enableRegister = system2.event",
                "enableRegister = system2.ntr",
                "enableRegister = system2.ptr",
                "system2.enable = enableRegister",
                "system2.ntr = enableRegister",
                "system2.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system2.NODE25 + status.system2.NODE28;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 2 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system2.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 2 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system.*",
                "status.system3.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system2.event",
            "webhelpfile": "15864.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 15 through 28. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 2 enable register, set status.system2.enable = status.system2.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 2 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system2.condition",
                "enableRegister = system2.enable",
                "enableRegister = system2.event",
                "enableRegister = system2.ntr",
                "enableRegister = system2.ptr",
                "system2.enable = enableRegister",
                "system2.ntr = enableRegister",
                "system2.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system2.NODE25 + status.system2.NODE28;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 2 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system2.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 2 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system.*",
                "status.system3.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system2.ntr",
            "webhelpfile": "15864.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 15 through 28. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 2 enable register, set status.system2.enable = status.system2.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 2 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system2.condition",
                "enableRegister = system2.enable",
                "enableRegister = system2.event",
                "enableRegister = system2.ntr",
                "enableRegister = system2.ptr",
                "system2.enable = enableRegister",
                "system2.ntr = enableRegister",
                "system2.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system2.NODE25 + status.system2.NODE28;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 2 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system2.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 2 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system.*",
                "status.system3.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system2.ptr",
            "webhelpfile": "15864.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 15 through 28. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 2 enable register, set status.system2.enable = status.system2.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 2 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system2.condition",
                "enableRegister = system2.enable",
                "enableRegister = system2.event",
                "enableRegister = system2.ntr",
                "enableRegister = system2.ptr",
                "system2.enable = enableRegister",
                "system2.ntr = enableRegister",
                "system2.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system2.NODE25 + status.system2.NODE28;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 2 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system2.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 2 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system.*",
                "status.system3.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system3.condition",
            "webhelpfile": "15865.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 29 through 42. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0 and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 3 enable register, set status.system3.enable = status.system3.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 3 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system3.condition",
                "enableRegister = system3.enable",
                "enableRegister = system3.event",
                "enableRegister = system3.ntr",
                "enableRegister = system3.ptr",
                "system3.enable = enableRegister",
                "system3.ntr = enableRegister",
                "system3.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system3.NODE39 + status.system3.NODE42;status.system3.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 3 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system3.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 3 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system3.enable",
            "webhelpfile": "15865.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 29 through 42. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0 and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 3 enable register, set status.system3.enable = status.system3.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 3 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system3.condition",
                "enableRegister = system3.enable",
                "enableRegister = system3.event",
                "enableRegister = system3.ntr",
                "enableRegister = system3.ptr",
                "system3.enable = enableRegister",
                "system3.ntr = enableRegister",
                "system3.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system3.NODE39 + status.system3.NODE42;status.system3.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 3 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system3.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 3 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system3.event",
            "webhelpfile": "15865.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 29 through 42. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0 and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 3 enable register, set status.system3.enable = status.system3.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 3 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system3.condition",
                "enableRegister = system3.enable",
                "enableRegister = system3.event",
                "enableRegister = system3.ntr",
                "enableRegister = system3.ptr",
                "system3.enable = enableRegister",
                "system3.ntr = enableRegister",
                "system3.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system3.NODE39 + status.system3.NODE42;status.system3.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 3 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system3.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 3 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system3.ntr",
            "webhelpfile": "15865.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 29 through 42. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0 and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 3 enable register, set status.system3.enable = status.system3.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 3 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system3.condition",
                "enableRegister = system3.enable",
                "enableRegister = system3.event",
                "enableRegister = system3.ntr",
                "enableRegister = system3.ptr",
                "system3.enable = enableRegister",
                "system3.ntr = enableRegister",
                "system3.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system3.NODE39 + status.system3.NODE42;status.system3.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 3 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system3.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 3 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system3.ptr",
            "webhelpfile": "15865.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 29 through 42. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0 and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 3 enable register, set status.system3.enable = status.system3.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 3 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system3.condition",
                "enableRegister = system3.enable",
                "enableRegister = system3.event",
                "enableRegister = system3.ntr",
                "enableRegister = system3.ptr",
                "system3.enable = enableRegister",
                "system3.ntr = enableRegister",
                "system3.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system3.NODE39 + status.system3.NODE42;status.system3.enable = enableRegister;",
                    "description": "Uses constants to set bits B11 and B14 of the system summary 3 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system3.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B11 and B14 of the system summary 3 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system2.*",
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system4.condition",
            "webhelpfile": "15866.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 43 through 56. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 4 enable register, set status.system4.enable = status.system4.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 4 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system4.condition",
                "enableRegister = system4.enable",
                "enableRegister = system4.event",
                "enableRegister = system4.ntr",
                "enableRegister = system4.ptr",
                "system4.enable = enableRegister",
                "system4.ntr = enableRegister",
                "system4.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system4.NODE53 + status.system4.NODE56;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system4.enable = enableRegister;",
                    "description": "Uses a decimal value to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system3.*",
                "status.system5.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system4.enable",
            "webhelpfile": "15866.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 43 through 56. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 4 enable register, set status.system4.enable = status.system4.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 4 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system4.condition",
                "enableRegister = system4.enable",
                "enableRegister = system4.event",
                "enableRegister = system4.ntr",
                "enableRegister = system4.ptr",
                "system4.enable = enableRegister",
                "system4.ntr = enableRegister",
                "system4.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system4.NODE53 + status.system4.NODE56;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system4.enable = enableRegister;",
                    "description": "Uses a decimal value to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system3.*",
                "status.system5.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system4.event",
            "webhelpfile": "15866.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 43 through 56. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 4 enable register, set status.system4.enable = status.system4.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 4 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system4.condition",
                "enableRegister = system4.enable",
                "enableRegister = system4.event",
                "enableRegister = system4.ntr",
                "enableRegister = system4.ptr",
                "system4.enable = enableRegister",
                "system4.ntr = enableRegister",
                "system4.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system4.NODE53 + status.system4.NODE56;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system4.enable = enableRegister;",
                    "description": "Uses a decimal value to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system3.*",
                "status.system5.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system4.ntr",
            "webhelpfile": "15866.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 43 through 56. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 4 enable register, set status.system4.enable = status.system4.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 4 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system4.condition",
                "enableRegister = system4.enable",
                "enableRegister = system4.event",
                "enableRegister = system4.ntr",
                "enableRegister = system4.ptr",
                "system4.enable = enableRegister",
                "system4.ntr = enableRegister",
                "system4.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system4.NODE53 + status.system4.NODE56;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system4.enable = enableRegister;",
                    "description": "Uses a decimal value to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system3.*",
                "status.system5.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system4.ptr",
            "webhelpfile": "15866.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 43 through 56. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.29000e+02 (which is 129) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00001. This value indicates that bit B0 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the system summary 4 enable register, set status.system4.enable = status.system4.enable.EXT.In addition to the above constants, enableRegister can be set to the decimal value of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal values. For example, to set bits B11 and B14, set enableRegister to 18,432 (which is the sum of 2,048 + 16,384). ",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 4 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system4.condition",
                "enableRegister = system4.enable",
                "enableRegister = system4.event",
                "enableRegister = system4.ntr",
                "enableRegister = system4.ptr",
                "system4.enable = enableRegister",
                "system4.ntr = enableRegister",
                "system4.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system4.NODE53 + status.system4.NODE56;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                },
                {
                    "example": "-- decimal 18432 = binary 0100 1000 0000 0000;enableRegister = 18432;status.system4.enable = enableRegister;",
                    "description": "Uses a decimal value to set bit B11 and bit B14 of the system summary 4 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system3.*",
                "status.system5.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system5.condition",
            "webhelpfile": "15867.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 57 through 64. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value, but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.30000e+02 (which is 130) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00010. This value indicates that bit B1 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B1 of the system summary 5 enable register, set status.system5.enable = status.system5.NODE57.In addition to the above constants, enableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal weights. For example, to set bits B1 and B4, set enableRegister to 18 (which is the sum of 2 + 16).",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 5 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system5.condition",
                "enableRegister = system5.enable",
                "enableRegister = system5.event",
                "enableRegister = system5.ntr",
                "enableRegister = system5.ptr",
                "system5.enable = enableRegister",
                "system5.ntr = enableRegister",
                "system5.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system5.NODE57 + status.system5.NODE60;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B1 and B4 of the system summary 5 enable register.\n"
                },
                {
                    "example": "-- decimal 18 = binary 0000 0000 0001 0010;enableRegister = 18;status.system5.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B1 and B4 of the system summary 5 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system5.enable",
            "webhelpfile": "15867.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (Rw)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 57 through 64. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value, but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.30000e+02 (which is 130) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00010. This value indicates that bit B1 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B1 of the system summary 5 enable register, set status.system5.enable = status.system5.NODE57.In addition to the above constants, enableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal weights. For example, to set bits B1 and B4, set enableRegister to 18 (which is the sum of 2 + 16).",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 5 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system5.condition",
                "enableRegister = system5.enable",
                "enableRegister = system5.event",
                "enableRegister = system5.ntr",
                "enableRegister = system5.ptr",
                "system5.enable = enableRegister",
                "system5.ntr = enableRegister",
                "system5.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system5.NODE57 + status.system5.NODE60;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B1 and B4 of the system summary 5 enable register.\n"
                },
                {
                    "example": "-- decimal 18 = binary 0000 0000 0001 0010;enableRegister = 18;status.system5.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B1 and B4 of the system summary 5 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system5.event",
            "webhelpfile": "15867.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (R)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 57 through 64. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value, but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.30000e+02 (which is 130) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00010. This value indicates that bit B1 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B1 of the system summary 5 enable register, set status.system5.enable = status.system5.NODE57.In addition to the above constants, enableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal weights. For example, to set bits B1 and B4, set enableRegister to 18 (which is the sum of 2 + 16).",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 5 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system5.condition",
                "enableRegister = system5.enable",
                "enableRegister = system5.event",
                "enableRegister = system5.ntr",
                "enableRegister = system5.ptr",
                "system5.enable = enableRegister",
                "system5.ntr = enableRegister",
                "system5.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system5.NODE57 + status.system5.NODE60;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B1 and B4 of the system summary 5 enable register.\n"
                },
                {
                    "example": "-- decimal 18 = binary 0000 0000 0001 0010;enableRegister = 18;status.system5.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B1 and B4 of the system summary 5 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system5.ntr",
            "webhelpfile": "15867.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 57 through 64. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value, but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.30000e+02 (which is 130) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00010. This value indicates that bit B1 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B1 of the system summary 5 enable register, set status.system5.enable = status.system5.NODE57.In addition to the above constants, enableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal weights. For example, to set bits B1 and B4, set enableRegister to 18 (which is the sum of 2 + 16).",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 5 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system5.condition",
                "enableRegister = system5.enable",
                "enableRegister = system5.event",
                "enableRegister = system5.ntr",
                "enableRegister = system5.ptr",
                "system5.enable = enableRegister",
                "system5.ntr = enableRegister",
                "system5.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system5.NODE57 + status.system5.NODE60;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B1 and B4 of the system summary 5 enable register.\n"
                },
                {
                    "example": "-- decimal 18 = binary 0000 0000 0001 0010;enableRegister = 18;status.system5.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B1 and B4 of the system summary 5 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "status.system5.ptr",
            "webhelpfile": "15867.htm",
            "signature": "",
            "command_return": "enableRegister",
            "type": "Attribute (RW)",
            "default_value": "- -\n",
            "tsp_link": "- -\n",
            "description": "These attributes manage the TSP-Link\u00ae system summary register of the status model for nodes 57 through 64. ",
            "details": "In an expanded system (TSP-Link), these attributes are used to read or write to the system summary registers. They are set using a constant or a numeric value, but are returned as a numeric value. The binary equivalent of the value indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B15. For example, if a value of 1.30000e+02 (which is 130) is read as the value of the condition register, the binary equivalent is 0000\u00a00000\u00a01000\u00a00010. This value indicates that bit B1 and bit B7 are\u00a0set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B1 of the system summary 5 enable register, set status.system5.enable = status.system5.NODE57.In addition to the above constants, enableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set enableRegister to the sum of their decimal weights. For example, to set bits B1 and B4, set enableRegister to 18 (which is the sum of 2 + 16).",
            "param_info": [
                {
                    "name": "enableRegister",
                    "description": "The status of the system summary 5 register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "enableRegister = system5.condition",
                "enableRegister = system5.enable",
                "enableRegister = system5.event",
                "enableRegister = system5.ntr",
                "enableRegister = system5.ptr",
                "system5.enable = enableRegister",
                "system5.ntr = enableRegister",
                "system5.ptr = enableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "enableRegister = status.system5.NODE57 + status.system5.NODE60;status.system2.enable = enableRegister ;",
                    "description": "Uses constants to set bits B1 and B4 of the system summary 5 enable register.\n"
                },
                {
                    "example": "-- decimal 18 = binary 0000 0000 0001 0010;enableRegister = 18;status.system5.enable = enableRegister;",
                    "description": "Uses the decimal value to set bits B1 and B4 of the system summary 5 enable register.\n"
                }
            ],
            "related_commands": [
                "status.system4.*",
                "System summary bit (System register)"
            ]
        },
        {
            "name": "channel.getbackplane()",
            "webhelpfile": "15918.htm",
            "signature": "channel.getbackplane(channelList)",
            "command_return": "analogBusList",
            "type": "Function\n",
            "default_value": "None or nil\n",
            "tsp_link": "Yes\n",
            "description": "This function returns a string that lists the analog backplane relays that are controlled when the specified channels are used with switching operations.",
            "details": "The response indicates the analog backplane relays that are used during processing of the command:The response will be changed by channel.setbackplane(), replacing the analog backplane relays with the new specified list.The response will be cleared if channel.setpole() sets a new pole selection.The analog backplane relays indicated by this response are not used or affected by:The parameter string can contain \"slotX\", where X equals 1 to 6, or \"allslots\".An error is generated if:When channelList contains multiple items, the string returned includes the analog backplane relay channels of a single channel separated by a comma. A semicolon is used to delineate channels.For channel patterns, the analog backplane relays must be specified when creating the pattern in the channel list parameter \u2014 see channel.pattern.setimage() or channel.pattern.snapshot(). Therefore, to see the channels and analog backplane relays associated with a channel pattern, use the channel.pattern.getimage() function.Command processing stops as soon as an error is detected and a nil response is then returned. No partial list is returned.For digital I/O, DAC, and totalizer channels, nothing is returned.",
            "param_info": [
                {
                    "name": "analogBusList",
                    "description": "A string listing analog backplane relays associated with items in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "A string listing the channels being queried",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "analogBusList = channel.getbackplane(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setpole(\"slot5\", 4);channel.setbackplane(\"slot5\", \"5911, 5922\");print(channel.getbackplane(\"slot5\"));",
                    "description": "Assume a Model 3720 in slot 5.\n--- --Set all channels on the card in slot 5 to be 4-pole, which makes the card have 30 4-pole channels.\n--- --Set all channels in slot 5 to have associated analog backplane relays 911 and 922 on slot 5.\n--- --Get the associated analog backplane relays for channels on slot 5.\n--- --Output:\n--- --5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922,5911,5922\n"
                }
            ],
            "related_commands": [
                "Data retrieval commands",
                "channel.close()",
                "channel.exclusiveclose()",
                "channel.open()",
                "channel.pattern.getimage()",
                "channel.pattern.setimage()",
                "channel.pattern.snapshot()",
                "channel.setbackplane()",
                "channel.setpole()",
                "dmm.close()",
                "dmm.open()",
                "scan.background()",
                "scan.execute()"
            ]
        },
        {
            "name": "channel.getmatchtype()",
            "webhelpfile": "15926.htm",
            "signature": "channel.getmatchtype(channelList)",
            "command_return": "matchType",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the match type for digital I/O and totalizer channels.",
            "details": "The channel match types are:Digital analog converter, backplane, and switch channels are not supported. If these channels are included in a range or slot specifier, they are ignored; otherwise, an error is generated.",
            "param_info": [
                {
                    "name": "matchType",
                    "description": "The comma-delimited states for channels in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String specifying the digital I/O or totalizer channels to query, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "matchType = channel.getmatchtype(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(channel.getmatchtype(\"6001:6009\"));",
                    "description": "Query the match type for digital I/O channels 1 through 5 and totalizer channels 6 through 9 on slot 6 (assuming a 3750 card). \n--- --Output: \n--- --4,4,4,4,4,4,4,4,4\n"
                }
            ],
            "related_commands": [
                "channel.setmatch()",
                "channel.setmatchtype()"
            ]
        },
        {
            "name": "channel.getmode()",
            "webhelpfile": "15927.htm",
            "signature": "channel.getmode(channelList)",
            "command_return": "mode",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the present mode of digital and totalizer channels.",
            "details": "For digital I/O channels, the following modes are supported:For totalizer channels, the following modes are supported:For DAC channels, the following modes are supported:Switch and analog backplane channels do not have modes. If included in a range or slot specifier, they are ignored. If they are specified directly, an error is generated.",
            "param_info": [
                {
                    "name": "mode",
                    "description": "Return string of a comma-delimited list of modes",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String that specifies the channels to query, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "mode = channel.getmode(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(channel.getmode(\"slot6\"));",
                    "description": "Query the configuration of the channels on slot 6. Assuming a 3750, channels 1 to 5 are digital I/O, channels 6 to 9 are totalizers, and channels 10 to 11 are DACs.\n--- --Output:\n--- --0,0,0,0,0,3,3,3,3,49,49\n"
                }
            ],
            "related_commands": [
                "channel.setmode()"
            ]
        },
        {
            "name": "channel.getoutputenable()",
            "webhelpfile": "15928.htm",
            "signature": "channel.getoutputenable(channelList)",
            "command_return": "outputEnable",
            "type": "Function\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This function gets the present output enable attribute for a channel.",
            "details": "For DAC channels, output enable indicates whether or not the DAC is driving the output. Response values are:Switch, digital I/O, totalizer, and backplane channels do not have modes. If they included in a range or slot specifier, they are ignored. If they are specified directly, an error is generated.",
            "param_info": [
                {
                    "name": "outputEnable",
                    "description": "Return string of a comma-delimited list of output enable values",
                    "enum": "",
                    "type": "boolean",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String specifying the DAC channels to query, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "outputEnable = channel.getoutputenable(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(channel.getoutputenable(\"slot1\"));",
                    "description": "Query the state of all DAC channels on slot\u00a01 (assuming a Model 3750 card, this would be channels 10 and 11).\n--- --Output:\n--- --0,0\n"
                }
            ],
            "related_commands": [
                "channel.setoutputenable()"
            ]
        },
        {
            "name": "channel.getpole()",
            "webhelpfile": "15929.htm",
            "signature": "channel.getpole(channelList)",
            "command_return": "poles",
            "type": "Function\n",
            "default_value": "Card dependent, typically 2\n",
            "tsp_link": "Yes\n",
            "description": "This function queries the pole settings for the specified channels.",
            "details": "channelList can contain \"slotX\", where X is 1 to 6, or \"allslots\".When the channel list parameter for this function is \"slotX\", the response first lists the channels starting from lowest to highest. When the channel list parameter for this function is \"allslots\", the response starts with slot 1 and increases to slot 6. Each slot is processed completely before going to the next. All slot\u00a01 channels are listed before slot\u00a02 channels.The response is the numeric value representing the pole selection and not the text. For example, 4-pole selection is 4 and not channel.POLES_FOUR.An error message is generated if:Command processing stops as soon as an error is detected. No partial list is returned. If an error is detected or the slot is empty, the response is nil. Digital I/O, DAC, backplane, and totalizer channels are not supported.",
            "param_info": [
                {
                    "name": "poles",
                    "description": "Returns a comma\u2011separated string of the poles, based on channelList; can be",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "A string listing the channels to query for their pole settings",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "poles = channel.getpole(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.reset(\"slot5\");channel.setpole(\"5003, 5007\", 4);polesSlot5 = channel.getpole(\"5001, 5003, 5005, 5007\");print(polesSlot5);",
                    "description": "Reset the channels on slot 5 only.\n--- --Set the pole attribute for channels 3 and 7 on slot 5 to be 4.\n--- --Query channels 1, 3, 5, and 7 on slot 5 for pole settings.\n--- --View the pole attribute for the specified channels.\n--- --Output:\n--- --2,4,2,4\n"
                }
            ],
            "related_commands": [
                "Data retrieval commands",
                "channel.setpole()"
            ]
        },
        {
            "name": "channel.getpowerstate()",
            "webhelpfile": "15930.htm",
            "signature": "channel.getpowerstate(channelList)",
            "command_return": "states",
            "type": "Function\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This function gets the current power state attribute for a totalizer or DAC channel.",
            "details": "See card-specific documentation for important potential implications (warm-up times, effective coverage, use cases, and so on) when disabling or enabling power to a channel.Not all channels can be disabled. If a channel that cannot be disabled is included in a range, it is ignored. If it is specified directly, an error is generated.",
            "param_info": [
                {
                    "name": "states",
                    "description": "Return string of a comma-delimited list of power states",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String specifying the channels to query, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "states = channel.getpowerstate(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(channel.getpowerstate(\"1006\"));",
                    "description": "Get the current power state attribute for a totalizer channel 6 of slot 1 (assuming a Model\u00a03750 card).\n--- --Output (assuming defaults):\n--- --1\n"
                }
            ],
            "related_commands": [
                "channel.setpowerstate()"
            ]
        },
        {
            "name": "channel.pattern.catalog()",
            "webhelpfile": "15934.htm",
            "signature": "for name in channel.pattern.catalog() do",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function creates a list of the user-created channel patterns.",
            "details": "This function allows you to print or delete all user-created channel patterns in the runtime environment. The entries that are returned are listed in random order.",
            "param_info": [
                {
                    "name": "name",
                    "description": "The user\u2011defined name of the channel pattern that is assigned by the catalog function during the for loop",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "for name in channel.pattern.catalog() do",
                "   ...",
                "end"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.pattern.setimage(\"3001,3031\", \"patternA\");channel.pattern.setimage(\"3002,3032\", \"patternB\");channel.pattern.setimage(\"3003,3033\",\"patternC\");for name in channel.pattern.catalog() do;   print(name .. \" = \" ..;      channel.pattern.getimage(name));   channel.pattern.delete(name);end;",
                    "description": "This example prints the names and items associated with all user-created channel patterns. It then deletes the channel pattern.\n--- --patternC = 3003,3033\n--- --patternA = 3001,3031\n--- --patternB = 3002,3032\n"
                }
            ],
            "related_commands": [
                "channel.pattern.delete()",
                "channel.pattern.getimage()",
                "channel.pattern.setimage()",
                "channel.pattern.snapshot()"
            ]
        },
        {
            "name": "channel.pattern.delete()",
            "webhelpfile": "15935.htm",
            "signature": "channel.pattern.delete(name)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function deletes a channel pattern.",
            "details": "An error is generated if the name does not exist as a channel pattern.",
            "param_info": [
                {
                    "name": "name",
                    "description": "A string representing the name of the channel pattern to delete",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.pattern.delete(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.pattern.delete(\"Channels\");",
                    "description": "Deletes a channel pattern called Channels.\n"
                }
            ],
            "related_commands": [
                "channel.pattern.catalog()",
                "channel.pattern.getimage()",
                "channel.pattern.setimage()",
                "channel.pattern.snapshot()"
            ]
        },
        {
            "name": "channel.resetstatelatch()",
            "webhelpfile": "15940.htm",
            "signature": "channel.resetstatelatch(channelList, state)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets the channel state.",
            "details": "This function is applicable to digital I/O, totalizer, and DAC channels only.The values for state are:Multiple states can be set by performing a logical OR operation on the values.For channelList, use channel.ALL to reset all states.States can be latched or unlatched, depending on other system settings. Latched states indicate that the condition occurred since the last reset (or power cycle). Unlatched states indicate that the condition has occurred when the channel.getstate() command was issued. The Overflow and Overload states default to latched.If states are not cleared using channel.resetstatelatch(), you may not be reading the present state of the channel.If the state is reset but the condition that caused the channel state to latch still exists, the state is reset, but a second event is generated through the channel trigger model.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String that specifies the channels that need to have their states reset, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "state",
                    "description": "The comma-delimited states for channels in channelList that are to have their states reset",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "channel.resetstatelatch(channelList, state)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.resetstatelatch(\"1001\", channel.IND_MATCH);",
                    "description": "Clears out a match indicator that was latched on digital I/O channel 1 of slot 1, assuming a Model 3750.\n"
                }
            ],
            "related_commands": [
                "channel.getstate()",
                "channel.getstatelatch()",
                "channel.setstatelatch()"
            ]
        },
        {
            "name": "channel.setbackplane()",
            "webhelpfile": "15941.htm",
            "signature": "channel.setbackplane(channelList, abuslist)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "None\n",
            "tsp_link": "Yes\n",
            "description": "This function specifies the list of analog backplane relays to use with the specified channels when they are used in switching applications.",
            "details": "The parameter string channelList can contain slotX, where X is 1 to 6, or allslots. The abuslist parameter must specify the entire list of analog backplane relays that are needed. The analog backplane relays specified in the abuslist parameter are used or affected by:The analog backplane relays specified in the abuslist parameter are not used or affected by:For channel patterns, the analog backplane relays are specified when the pattern is created (see channel.pattern.getimage() and channel.pattern.snapshot()). Channel patterns do not have a poles setting associated with them.If this command is updated, the previous list is replaced with the new specified analog backplane relays in the abuslist parameter.For channels, as their pole setting change, the list of analog backplane relays gets cleared. Therefore, after changing the pole settings, send channel.setbackplane() with the appropriate analog backplane relay channels. When clearing the backplane channels, this can involve clearing the paired channel, whether pairing or un-pairing channels. For example, on a 40\u2011channel card, channels 1 and 21 are paired when the poles for channel 1 is set to 4. Therefore, setting the poles setting on channel 1 to 4 clears the backplane channels for channels 1 and 21. Likewise, they are both cleared when the poles setting is set back to 2 on channel 1.Calling this function on an existing channel involved in scanning invalidates the existing scan list.An error is generated if:If a syntax error occurs, command processing stops and no changes are made.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the channels to change",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "abuslist",
                    "description": "A string that lists the analog backplane relays to set for the channels specified in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setbackplane(channelList, abuslist)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setbackplane(\"2002\", \"2913, 2914\");channel.open(\"allslots\");channel.close(\"2002\");print(channel.getclose(\"allslots\"));",
                    "description": "Use analog backplane relays 3 and 4 in bank\u00a01 of slot 2 for a switching application on channel 2 of slot 2.\n--- --Open all channels in the instrument.\n--- --Close channel 2 on slot 2.\n--- --Query for all closed channels in the instrument.\n--- --Output (assuming channel 2002 is configured for 2-pole operation):\n--- --2002;2913;2914\n"
                },
                {
                    "example": "print(channel.getbackplane(\"2002\"));\u00a0;\u00a0;\u00a0;\u00a0;\u00a0;channel.open(\"slot2\");channel.setpole(\"2002\", 4);\u00a0;channel.close(\"2002\");print(channel.getclose(\"slot2\"));\u00a0;\u00a0;\u00a0;channel.open(\"slot2\");channel.setbackplane(\"2002\", \"2911, 2922\");\u00a0;channel.close(\"2002\");print(channel.getclose(\"slot2\"));",
                    "description": "Query the analog backplane relays for channel\u00a02 of slot 2, assuming the configuration of the previous example.\n--- --Output:\n--- --2913,2914\n--- --\u00a0\n--- --Open all channels on slot 2 only.\n--- --Change the poles on channel 2 of slot 2 to 4 (this clears previously assigned backplanes to the channel).\n--- --Close channel 2 on slot 2.\n--- --Query for closed channels on slot 2 (note that the backplane relays have been cleared and the paired channel, 2022, is in parentheses)\n--- --Output:\n--- --2002(2022)\n--- --Open all channels on slot 2 only.\n--- --Assign analog backplane relay 1 of bank 1 and relay 1 of bank 2 of slot 2 to channel 2 of slot 2.\n--- --\u00a0\n--- --Close channel 2 on slot 2.\n--- --Query for closed channels on slot 2.\n--- --Output:\n--- --2002(2022);2911;2922\n"
                }
            ],
            "related_commands": [
                "channel.close()",
                "channel.exclusiveclose()",
                "channel.getbackplane()",
                "channel.open()",
                "channel.setpole()",
                "scan.background()",
                "scan.execute()"
            ]
        },
        {
            "name": "channel.setlabel()",
            "webhelpfile": "15944.htm",
            "signature": "channel.setlabel(channelList, labelname)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "No label\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the label associated with a channel.",
            "details": "This command sets the label of the specified channel to the label value. The channel attributes associated with the channel remain unchanged except for the label.The label must be unique. In addition, it cannot be the same as the name of a channel pattern. If you specify a label that already exists, an error message is generated that indicates a parameter error and channel that that is already associated the specified label. For example, channel one on slot 4 has a label of start. If you send channel.setlabel(\"5001\", \"start\"), error code 1115, \"Parameter error label already used with channel 4001,\" is generated.To clear a label, set it to an empty string (\"\").After defining a label, you can use it to specify the channel instead of using the channel specifier.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the channel to which to set the label; the string cannot contain spaces",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "labelname",
                    "description": "A string that contains the label for the channel in channelList, up to 19 characters",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setlabel(channelList, labelname)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setlabel(\"3001\", \"start\");channel.close(\"start\");print(channel.getclose(\"allslots\"));",
                    "description": "Sets the label for channel 1 on slot 3 to start and closes start.\n--- --Output:\n--- --3001\n"
                },
                {
                    "example": "channel.setlabel(\"3001\", \"\");",
                    "description": "Clears the label for channel 1 on slot 3 back to 3001.\n"
                },
                {
                    "example": "channel.setlabel(\"3001\", \" \");",
                    "description": "Also clears the label for channel 1 slot 3 back to 3001.\n"
                }
            ],
            "related_commands": [
                "Channel"
            ]
        },
        {
            "name": "channel.setmatchtype()",
            "webhelpfile": "15946.htm",
            "signature": "channel.setmatchtype(channelList, type)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "channel.MATCH_NONE\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the match type on a channel.",
            "details": "The types of match values include:For an exact match, the state match indicator only becomes true when the match value and match mask value equal the channel read value.For an any match, the state match indicator only becomes true when the match value or match mask value equals the channel read value.For a not exact match, the state match indicator only becomes true when the match value and match mask value and channel read value are not equal to the match value and match mask value and last channel read value. In other words, the match value should be the present value, and if the value changes at all away from the original value, a match is declared.For none, matching is disabled.For totalizer channels, only match exact and match none are supported.This command is not supported on DAC, backplane, and switch channels.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying the channels to set, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "type",
                    "description": "A value for setting the match operation used on this specific channel",
                    "enum": "",
                    "type": "channelMatchType",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setmatchtype(channelList, type)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setmatchtype(\"1001\", channel.MATCH_EXACT);",
                    "description": "Assuming a 3750, defines the match type for digital I/O channel 1 to be a MATCH_EXACT type.\n"
                }
            ],
            "related_commands": [
                "channel.getmatchtype()",
                "channel.setmatch()"
            ]
        },
        {
            "name": "channel.setmode()",
            "webhelpfile": "15947.htm",
            "signature": "channel.setmode(channelList, mode)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "Digital I/O: 0 (channel.MODE_INPUT)Totalizer: 3 (channel.MODE_RISING_TTL_EDGE)DAC: 49 (channel.MODE_PROTECT_VOLTAGE_1)\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the mode of operation of a channel.",
            "details": "Different channel types contain additional configurable settings. These settings are grouped together by channel type as described in the following paragraphs.For digital I/O channels, the mode indicates the direction of the channel (input or output). The following modes are supported:For totalizer channels, the mode indicates the configuration of the channel (edge and reset). The following modes are supported:For DAC channels, the mode indicates the output of the channel (function and range). The output is switched off before any mode change is made, and remains off after the mode has changed. The following modes are supported:Changing the mode setting can impact the power consumption of the card. The instrument verifies that power is available before changing the mode. If an insufficient power capability exists, the command generates an error.Consult the card-specific documentation for more detailed information on mode settings and functionality.For digital I/O channels, changing the mode from input to output adds an additional channel delay if the channel.setdelay() function was used to set a user delay.For switch and backplane channels, there is no valid mode setting. Setting a mode on a specific switch or backplane channel generates an error. If the switch or backplane channel is in the range of channels, the switch or backplane channel is ignored.The specified channel list must use only one channel type. For example, channel list \"1001:1004\" is only valid if channels 1, 2, 3, and 4 are of the same type. If channel 3 is a different type of channel, the channel list is invalid and an error is generated.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying the channels to set, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "mode",
                    "description": "The value that sets the mode of operation for a channel; see Details",
                    "enum": "",
                    "type": "channelsetmodemode",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setmode(channelList, mode)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setmode(\"6003:6005\", channel.MODE_OUTPUT);\u00a0;\u00a0;\u00a0;channel.setmode(\"6007\", channel.MODE_FALLING_TTL_EDGE);",
                    "description": "Assuming a 3750, set digital I/O channels 3 to 5 to be configured for output on slot 6.\n--- --\u00a0\n--- --Set the totalizer channel 7 on slot 6 to count the falling edges of a TTL signal.\n"
                }
            ],
            "related_commands": [
                "channel.setdelay()"
            ]
        },
        {
            "name": "channel.setoutputenable()",
            "webhelpfile": "15948.htm",
            "signature": "channel.setoutputenable(channelList, state)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "0 (channel.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the output enable attribute on a channel.",
            "details": "For DAC channels, output enable indicates whether or not the DAC is driving the output. The following possible states are supported:For DAC channels, changing the output state to on adds an additional channel delay to channel.setdelay().Channels with output set to off consume less power.Changing the output setting impacts the power consumption of the card. The instrument verifies that power is available before changing the mode. If there is insufficient power capability, the command generates an error. Consult the specific card documentation for information on a channel\u2019s output characteristics.For switch, backplane, digital I/O, and totalizer channels, there is no valid output enable value. Setting output enable on a specific channel generates an error. If one of these channels is in the range of channels, the channel is ignored.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying the channels to set, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "state",
                    "description": "A value representing the state of the output of the channel",
                    "enum": "",
                    "type": "channelState",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setoutputenable(channelList, state)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setoutputenable(\"1010\", channel.OFF);",
                    "description": "Assuming a 3750, turns the output off on the first DAC channel (channel 10) in slot 1.\n"
                }
            ],
            "related_commands": [
                "channel.getoutputenable()",
                "channel.setdelay()"
            ]
        },
        {
            "name": "channel.setpole()",
            "webhelpfile": "15949.htm",
            "signature": "channel.setpole(channelList, value)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "Card dependent, but typically 2 (channel.POLES_TWO)\n",
            "tsp_link": "Yes\n",
            "description": "This function specifies the pole setting for a list of channels.",
            "details": "The parameter string can contain allslots or slotX, where X is 1 to 6.Channel patterns do not have a pole setting associated with them. For channel patterns, the pole setting indicates if the paired channel should be used when the pattern is created and the analog backplane relays must be specified when creating the pattern (with channel.pattern.setimage() and channel.pattern.snapshot()). Channel patterns get deleted as the pole settings of the channels in the pattern image get changed.You manipulate the analog backplane relays after setting the pole setting by using the channel.setbackplane() function for channels. For channels, as the pole setting changes, their analog backplane relays, specified by channel.setbackplane(), get cleared. Therefore, after a pole setting change, you need to add the analog backplane relays for the pole setting by using channel.setbackplane(). When clearing the backplane channels, this can involve clearing the paired channel, whether pairing or unpairing channels. For example, on a 40-channel card, channels 1 and 21 are paired when the pole setting for channel 1 is set to 4. Therefore, when changing the pole setting on channel 1 to 4, the backplane channels for channels 1 and 21 are cleared. Likewise, they both are cleared when the pole setting is set back to 2 on channel 1.Calling this function on an existing channel involved in scanning invalidates the existing scan list.An error message is generated for the following reasons:Command processing stops as soon as an error is detected and no pole settings are modified.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying the channels to set, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "Pole setting for the channels in channelList. Use the following",
                    "enum": "channel.POLES_ONE 1|channel.POLES_TWO 2|channel.POLES_FOUR 4",
                    "type": "channelsetpolevalue",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setpole(channelList, value)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setpole(channel.POLES_FOUR);",
                    "description": "Sets channels on slot 5 to four-pole.\n"
                },
                {
                    "example": "channel.reset(\"slot2\");\u00a0;channel.setpole(channel.POLES_FOUR);channel.close(\"2001, 2003\");print(channel.getclose(\"slot2\")); ;\u00a0;\u00a0;\u00a0;\u00a0;channel.open(\"slot2\");\u00a0;channel.setbackplane(\"2001\", \"2915\");\u00a0;channel.setbackplane(\"2003\", \"2925\");\u00a0;channel.close(\"2001, 2003\");print(channel.getclose(\"slot2\"));\u00a0;\u00a0;\u00a0;\u00a0;print(channel.getimage(\"2001, 2003\"));\u00a0;\u00a0;\u00a0;channel.open(\"slot2\");channel.setpole(\"slot2\", 2);print(channel.getimage(\"2001, 2003\"));",
                    "description": "Assuming a 3721, reset channels on slot 2 only.\n--- --Set channels on slot 2 to 4-pole.\n--- --Close channels 1 and 3 on slot 2.\n--- --Query slot 2 for closed channels and analog backplane relays.\n--- --Output:\n--- --2001(2021);2003(2023)\n--- --Note that the channels in parentheses are the paired channels because they are in a 4-pole configuration.\n--- --\u00a0\n--- --Open all channels and analog backplane relays on slot 2.\n--- --Associate analog backplane relay 5 in bank 1 of slot 2 with channel 1 on slot 2.\n--- --Associate analog backplane relay 5 in bank 2 of slot 2 with channel 3 on slot 2.\n--- --\u00a0\n--- --Close channels 1 and 3 on slot 2.\n--- --Query slot 2 for closed channels and analog backplane relays.\n--- --Output:\n--- --2001(2021);2003(2023);2915;2925\n--- --\u00a0\n--- --Query for channels and analog backplane relays that are manipulated when open and close channels 1 and 3 on slot 2.\n--- --Output:\n--- --2001(2021),2915;2003(2023),2925 \n--- --\u00a0\n--- --Clear paired channels and analog backplane relays.\n--- --Output:\n--- --2001;2003\n--- --\u00a0\n--- --Note that channels are no longer paired or have analog backplane relays associated with them.\n"
                }
            ],
            "related_commands": [
                "channel.getbackplane()",
                "channel.getpole()",
                "channel.pattern.setimage()",
                "channel.pattern.snapshot())",
                "channel.setbackplane() "
            ]
        },
        {
            "name": "channel.setstatelatch()",
            "webhelpfile": "15950.htm",
            "signature": "channel.setstatelatch(channelList, stateLatchMask)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "14 for overload, match, and overflow\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the state indicators to either latching or nonlatching.",
            "details": "Applicable to digital I/O, totalizer, and DAC channels only.Each indicator is represented by a bit in the mask.For nonlatching applications, the state indicator clears automatically when the causing condition clears itself. For latching applications, the condition is cleared using the channel.resetstatelatch() command.When using the trigger model, events are always nonlatching (or pulse oriented). However, in latching operation, the event is only generated once at the beginning. In nonlatching operation, the event is generated anytime the condition begins.Set multiple states by performing a logical OR operation on the values.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "The channels to set, using standard channel naming",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "stateLatchMask",
                    "description": "A value specifying the indicators to latch",
                    "enum": "channel.IND_MATCH 4|channel.IND_OVERFLOW 8|channel.IND_OVERLOAD 2",
                    "type": "channelsetstatelatchstateLatchMask",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setstatelatch(channelList, stateLatchMask)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setstatelatch(\"1001\", channel.IND_MATCH);",
                    "description": "Generate only a match state event on digital I/O channel 1 in slot 1, assuming a \u00a03750.\n"
                },
                {
                    "example": "channel.setstatelatch(\"6010\", bit.bitor(channel.IND_OVERFLOW, channel.IND_OVERLOAD));print(channel.getstatelatch(\"6010\"));",
                    "description": "Generate either an overflow or overload event on DAC channel 10 in slot 6, assuming a Model\u00a03750.\n--- --Query for the state latch for channel 10 on slot 6.\n--- --Output:\n--- --10\n"
                }
            ],
            "related_commands": [
                "channel.getstate()",
                "channel.getstatelatch()",
                "channel.resetstatelatch()"
            ]
        },
        {
            "name": "channel.trigger[N].clear()",
            "webhelpfile": "15951.htm",
            "signature": "channel.trigger[N].clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears any pending events.",
            "details": "This function clears any pending events for the channel trigger specified by N.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Number indicating the trigger line to clear (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "channel.trigger[N].clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.trigger[1].clear();",
                    "description": "Clears any pending events on channel trigger 1.\n"
                }
            ],
            "related_commands": [
                "channel.trigger[N].set()"
            ]
        },
        {
            "name": "channel.trigger[N].EVENT_ID",
            "webhelpfile": "15952.htm",
            "signature": "",
            "command_return": "X",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant indicates the trigger event generated by the channel trigger N.",
            "details": "",
            "param_info": [
                {
                    "name": "X",
                    "description": "The trigger event number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Number indicating the channel trigger event ID (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "X = channel.trigger[N].EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.channel.stimulus = channel.trigger[1].EVENT_ID;",
                    "description": "Use channel trigger 1 events to pace the channel action of the scanning or set the trigger stimulus of the channel event detector to channel trigger 1.\n"
                }
            ],
            "related_commands": [
                "channel.trigger[N].set()"
            ]
        },
        {
            "name": "channel.trigger[N].get()",
            "webhelpfile": "15953.htm",
            "signature": "channel.trigger[N].get()",
            "command_return": "channelList, stateMatch",
            "type": "Function\n",
            "default_value": "Empty channel listState match 0\n",
            "tsp_link": "Yes\n",
            "description": "This function gets the channel status trigger information that is used to watch the state of a specific channel.",
            "details": "This command is available for DAC, digital I/O, and totalizer channels. Switch channels are not supported.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "Returns a string specifying the channels watched by this trigger",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "stateMatch",
                    "description": "Returns a value specifying the state to match when triggering an event",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Number indicating the channel trigger to get (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "channelList, stateMatch = channel.trigger[N].get()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.trigger[1].set(\"1010\", channel.IND_MATCH);chan_list, state_match = channel.trigger[1].get();print(chan_list, state_match);",
                    "description": "Assuming a 3750, defines channel trigger event 1 to occur when totalizer channel 10 matches its defined match value.\n--- --Query for the channels and state conditions associated with channel trigger 1.\n--- --Output:\n--- --1010    4.000000000e+00\n"
                },
                {
                    "example": "channel.trigger[5].set(\"6003, 6005\", channel.IND_MATCH)    ;print(channel.trigger[5].get());",
                    "description": "Assuming a Model 3750 card, define a channel trigger event 5 to occur when either digital I/O channel 3 or 5 on slot 6 match their defined values.\n--- --View the trigger information associated with channel trigger 5.\n--- --Output:\n--- --6003,6005       4.000000000e+00\n"
                }
            ],
            "related_commands": [
                "channel.trigger[N].set()"
            ]
        },
        {
            "name": "channel.trigger[N].set()",
            "webhelpfile": "15954.htm",
            "signature": "channel.trigger[N].set(channelList, stateMatch)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "Empty channel listState match 0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the channel status trigger model to watch the state of a specific channel.",
            "details": "If the channel list contains more than one channel, the trigger acts as a logical OR. When any one of the channels in the list matches the specified state, a trigger event is generated. Therefore, if an indicator is present in both the match and the actual state, an event is triggered. If the match contains more than one state indicator, only one of those indicators needs to be present to trigger the event.There are a total of eight channel trigger events for each Series 3700A, defined by N. Using this mechanism, a trigger can be generated when a pattern is matched on an I/O, a totalizer matches a defined count, or an I/O has an overcurrent condition.Latching functionality is not supported. This command works for DAC, digital I/O and totalizer channels. Switch channels are not supported.To clear a trigger that is no longer needed, pass an empty channel list (\"\" or \" \") .",
            "param_info": [
                {
                    "name": "N",
                    "description": "Number indicating the channel trigger to set (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                },
                {
                    "name": "channelList",
                    "description": "The channels to set, using standard channel naming",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "stateMatch",
                    "description": "Value specifying the status to match when triggering an event",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "channel.trigger[N].set(channelList, stateMatch)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.trigger[1].set(\"1001\", channel.IND_MATCH);",
                    "description": "Assuming a 3750, defines a channel trigger event 1 to occur when digital I/O channel 1 matches its defined match value.\n"
                },
                {
                    "example": "channel.trigger[5].set(\"6003, 6005\", channel.IND_MATCH)    ;print(channel.trigger[5].get());\u00a0;channel.trigger[5].set(\" \", channel.IND_MATCH);print(channel.trigger[5].get());",
                    "description": "Assuming a 3750 card, define channel trigger event 5 to occur when either digital I/O channel 3 or 5 on slot 6 match their defined values.\n--- --View the trigger information associated with channel trigger 5.\n--- --Clear the trigger information associated with channel trigger 5.\n--- --View the trigger information associated with channel trigger 5.\n--- --Output:\n--- --6003,6005  4.000000000e+000  0.000000000e+000\n"
                }
            ],
            "related_commands": [
                "channel.trigger[N].get()"
            ]
        },
        {
            "name": "channel.trigger[N].wait()",
            "webhelpfile": "15955.htm",
            "signature": "channel.trigger[N].wait(timeout)",
            "command_return": "triggered",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function waits for the specified trigger or timeout period, whichever comes first.",
            "details": "If one or more trigger events were detected since the last time channel.trigger[N].wait or channel.trigger[N].clear was called, this function returns immediately.After waiting for a trigger with this function, the event detector is automatically reset and rearmed. This is true regardless of the number of events detected.The value for timeout must be greater than zero and less than 10,000.",
            "param_info": [
                {
                    "name": "triggered",
                    "description": "Returns an indication that a trigger occurred",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Number indicating the channel trigger to wait for (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                },
                {
                    "name": "timeout",
                    "description": "The number of seconds to wait",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "triggered = channel.trigger[N].wait(timeout)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.trigger[1].wait(5);",
                    "description": "Wait 5 seconds for channel trigger event 1 to occur or timeout if trigger event is not detected in 5 seconds.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "channel.write()",
            "webhelpfile": "15956.htm",
            "signature": "channel.write(channelList, value, width)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function writes a value to a channel.",
            "details": "For widths greater than 1, the specified channel occupies the least significant byte. For example, writing the value of 4278255360 (hexadecimal FF00FF00) to channel 1 with a width of 4 sets channel 1 to 0, channel 2 to 255 (hexadecimal FF), channel 3 to 0, and channel 4 to 255 (hexadecimal FF). Writing the value of 4278255360 to channel 1 with a width of 1 sets channel 1 to 0 and leaves other channels untouched.For digital I/O channels, only widths of 1, 2, 3, or 4 are supported. All other widths are ignored. Values written to inputs are ignored. If no specified channel is set for output, then an error is generated. If a width crosses channels, then only the channels set to output are affected.Totalizers, DACs, and switch channels do not support a width other than 1. Specifying a width greater than 1 results in an error.For a channel with a power state of OFF, an error is generated. No action is taken on any channel in the specified channel list.For DAC channels, the value is expected to be the set floating\u2011point voltage or current. Also, an error is generated if the value is out of range. No action is taken on any channel in the specified channel list.For digital I/O channels, the value becomes the setting of the digital output.The time it takes to execute the write command is affected by the channel delay setting.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "The channels to set, using standard channel naming",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "The value to be written to the channel (must be decimal value)",
                    "enum": "",
                    "type": "number",
                    "range": "(must be decimal value)"
                },
                {
                    "name": "width",
                    "description": "Value that specifies the channel width of the write",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "channel.write(channelList, value)",
                "channel.write(channelList, value, width)"
            ],
            "overloads": [
                "channel.write(channelList, value)"
            ],
            "examples": [
                {
                    "example": "channel.write(\"1001\", 33);channel.write(\"1006\", 0);",
                    "description": "Output a value of 33 to digital I/O channel 1.\n--- --Set totalizer channel 6 on slot 1 (assuming a 3750 card) to 0.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "dmm.adjustment.count",
            "webhelpfile": "15967.htm",
            "signature": "",
            "command_return": "calibrationCount",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates the number of times the instrument has been adjusted (calibrated).",
            "details": "Calibration (adjustment) may or may not be unlocked for this attribute to read and return a value.",
            "param_info": [
                {
                    "name": "calibrationCount",
                    "description": "The number of times the instrument has been adjusted or calibrated",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "calibrationCount = dmm.adjustment.count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "adjustmentCount = dmm.adjustment.count;",
                    "description": "Queries for the adjustment count.\n"
                }
            ],
            "related_commands": [
                "dmm.adjustment.date",
                "dmm.calibration.unlock()"
            ]
        },
        {
            "name": "dmm.adjustment.date",
            "webhelpfile": "15968.htm",
            "signature": "",
            "command_return": "calibrationDate",
            "type": "Attribute (RW)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets or queries the calibration adjustment date in Coordinated Universal Time (UTC) format (number of seconds since January 1, 1970).",
            "details": "This attribute can only be set when calibration is unlocked.For more information about formatting options with os.time or os.date, see the Lua documentation. ",
            "param_info": [
                {
                    "name": "calibrationDate",
                    "description": "The number of seconds since January 1, 1970",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "os.time{year=yyyy, month=m, day=d}",
                    "description": "Specifies the date; if a value is not specified, sets the adjustment date to the present date of the instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "calibrationDate = dmm.adjustment.date",
                "dmm.adjustment.date = os.time({year=yyyy, month=m, day=d})"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.adjustment.date = os.time{year=2007, month=7, day = 4};",
                    "description": "Sets the adjustment date to July 4, 2007.\n"
                },
                {
                    "example": "print(os.date(\"%m/%d/%Y\", dmm.adjustment.date));",
                    "description": "Queries the date and formats the response as mm/dd/yyyy:\n--- --07/04/2007\n"
                },
                {
                    "example": "print(os.date(\"%x\", dmm.adjustment.date));",
                    "description": "Queries the date and formats the response as  mm/dd/yy:02/24/09\n"
                }
            ],
            "related_commands": [
                "dmm.adjustment.count",
                "dmm.calibration.unlock()"
            ]
        },
        {
            "name": "dmm.aperture",
            "webhelpfile": "15969.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "See Details\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines the aperture setting for the selected function.",
            "details": "The dmm.aperture attribute is available for the following functions.The aperture setting is not available for the functions \"continuity\" and \"nofunction\". If you query the aperture when either of these functions is selected, nil is returned. If you write the command when either of these functions is selected, an error is generated.The aperture value is saved with the dmm.func function setting, so if you use another function, then return to the previous setting, such as \"dcvolts\" or \"frequency\", the aperture value you set previously is retained.The setting for aperture may be automatically adjusted based on what the DMM supports. Therefore, after setting the aperture, query the value to see if it was adjusted.If the detector bandwidth (dmm.detectorbandwidth) setting is 30 or less for \"acvolts\" or \"accurrent\", an error message is generated if you try to set the aperture for these functions.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Represents the aperture",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.aperture",
                "dmm.aperture = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.aperture = 16.67e-3;",
                    "description": "Set the aperture to 16.67 milliseconds for DC volts.\n"
                }
            ],
            "related_commands": [
                "dmm.dbreference",
                "dmm.func",
                "dmm.nplc"
            ]
        },
        {
            "name": "dmm.appendbuffer()",
            "webhelpfile": "15970.htm",
            "signature": "dmm.appendbuffer(bufferVar, fileName, timeFormat)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function appends data from the reading buffer to a file on the USB flash drive. If no file exists, this function creates a file.",
            "details": "For options that save more than one item of time information, each item is comma delimited. For example, the default format is <date>, <time>, and <fractional seconds> for each reading, separated by commas.The file extension .csv is appended to the filename if necessary. Any file extension other than .csv generates errors.Because dmm.appendbuffer() appends data, it does not include header information. The dmm.savebuffer() function does included header information.The index column entry starts at 1 for each append operation, which is also what the dmm.savebuffer() command does.Errors are generated:Examples of valid destination file names:Invalid destination filename examples:\u2014 The period is not followed by the .csv extension.\u2014 The only allowed extension is .csv. If .csv is not assigned, it is automatically added.\u2014 Two periods in the file name (myData_txt.csv would be correct).",
            "param_info": [
                {
                    "name": "bufferVar",
                    "description": "A string with the name of a DMM reading buffer from which you want to append data to the specified file",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "fileName",
                    "description": "A string with the file name of the file on the USB flash drive to which reading buffer data will be appended",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "timeFormat",
                    "description": "How the date and time information should be saved. The values for timeFormat are",
                    "enum": "buffer.SAVE_RELATIVE_TIME nil|buffer.SAVE_FORMAT_TIME nil|buffer.SAVE_RAW_TIME nil|buffer.SAVE_TIMESTAMP_TIME nil",
                    "type": "dmmappendbuffertimeFormat",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.appendbuffer(bufferVar, fileName)",
                "dmm.appendbuffer(bufferVar, fileName, timeFormat)"
            ],
            "overloads": [
                "dmm.appendbuffer(bufferVar, fileName)"
            ],
            "examples": [
                {
                    "example": "dmm.appendbuffer(\"bufferVar\", \"/usb1/myData.csv\");",
                    "description": "Appends readings from a valid DMM buffer named bufferVar with default time information to a file named myData.csv on the USB flash drive.\n"
                }
            ],
            "related_commands": [
                "dmm.makebuffer()",
                "dmm.savebuffer()"
            ]
        },
        {
            "name": "dmm.buffer.catalog()",
            "webhelpfile": "15971.htm",
            "signature": "for name in dmm.buffer.catalog() do...end",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates an iterator for the user-created reading buffers.",
            "details": "You can access the catalog for the user-created local reading buffers so that you can print the names of all reading buffers in the system. The entries are enumerated in no particular order. From this list, you may selectively delete reading buffers from the system.",
            "param_info": [
                {
                    "name": "name",
                    "description": "A string representing the name of a user created DMM reading buffer",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "for name in dmm.buffer.catalog() do...end"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "for name in dmm.buffer.catalog() do print(name) end;",
                    "description": "Print all user-created local reading buffers in the system.\n--- --Assume the return is:\n--- --buf3\n--- --buf5\n--- --buf1\n"
                }
            ],
            "related_commands": [
                "dmm.buffer.info()"
            ]
        },
        {
            "name": "dmm.buffer.info()",
            "webhelpfile": "15972.htm",
            "signature": "dmm.buffer.info(bufferVar)",
            "command_return": "size, capacity",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the size and capacity of the reading buffer parameter.",
            "details": "This function uses the specified reading buffer input parameter name to find the corresponding size and capacity to return. Use this function with the dmm.buffer.catalog() function to output the size and capacity for all reading buffers in the system.",
            "param_info": [
                {
                    "name": "size",
                    "description": "Number representing the N (presently stored) attribute of the reading buffer parameter",
                    "enum": "",
                    "type": "number",
                    "range": "(presently stored)"
                },
                {
                    "name": "capacity",
                    "description": "Number representing the overall capacity attribute of the reading buffer parameter",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "bufferVar",
                    "description": "String representing the reading buffer name that you want to query for size and capacity",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "size, capacity = dmm.buffer.info(bufferVar)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "for n in dmm.buffer.catalog() do;   print(dmm.buffer.info(n));end;",
                    "description": "Assume the system has the following reading buffers created: buffer1, buffer2, buffer3, buffer4, and buffer5.\n--- --Query the system for the size and capacity of each reading buffer without formatting the results.\n--- --The output is:\n--- --0.000000000e+00 2.000000000e+03\n--- --0.000000000e+00 4.000000000e+03\n--- --0.000000000e+00 5.000000000e+03\n--- --0.000000000e+00 3.000000000e+03\n--- --0.000000000e+00 1.000000000e+03\n"
                }
            ],
            "related_commands": [
                "dmm.buffer.catalog()"
            ]
        },
        {
            "name": "dmm.buffer.maxcapacity",
            "webhelpfile": "15973.htm",
            "signature": "",
            "command_return": "maximumCapacity",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the overall maximum capacity for reading buffers in the instrument.",
            "details": "Determines the maximum capacity of the instrument for reading buffer storage. This value represents the total system reading buffer storage size. A single reading buffer may be created with this as its size, or several reading buffers may be created in the instrument that are smaller in size. However, the sum total of all reading buffer sizes in the instrument cannot exceed this maximum.",
            "param_info": [
                {
                    "name": "maximumCapacity",
                    "description": "A number that represents the overall maximum capacity for the reading buffers",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maximumCapacity = dmm.buffer.maxcapacity"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "MaxBuffCap = dmm.buffer.maxcapacity;print(MaxBuffCap);",
                    "description": "Reads the maximum reading buffer capacity for the instrument, which is 650,000 readings.\n--- --Output:\n--- --6.500000000e+05\n"
                }
            ],
            "related_commands": [
                "dmm.buffer.info()",
                "dmm.buffer.usedcapacity",
                "dmm.makebuffer()"
            ]
        },
        {
            "name": "dmm.buffer.usedcapacity",
            "webhelpfile": "15974.htm",
            "signature": "",
            "command_return": "usedCapacity",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates how much of the maximum capacity for reading buffers in the instrument is used.",
            "details": "This value represents the sum total capacity of all reading buffers in the instrument. ",
            "param_info": [
                {
                    "name": "usedCapacity",
                    "description": "The presently used capacity for reading buffers in the instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "usedCapacity = dmm.buffer.usedcapacity"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "buf1 = dmm.makebuffer(300000);buf2 = dmm.makebuffer(300000);print(dmm.buffer.usedcapacity);print(dmm.buffer.maxcapacity - dmm.buffer.usedcapacity);\u00a0;",
                    "description": "Create buffers.\n--- --Reads the used reading buffer capacity for the system.\n--- --6.000000000e+05\n--- --5.000000000e+04\n--- --This shows that there is a capacity of 50,000 available for creating additional reading buffers.\n"
                }
            ],
            "related_commands": [
                "dmm.buffer.info()",
                "dmm.buffer.maxcapacity"
            ]
        },
        {
            "name": "dmm.autodelay",
            "webhelpfile": "15975.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "2 (dmm.AUTODELAY_ONCE)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables the automatic delay that occurs before each measurement.",
            "details": "The autodelay setting applies to the function selected by dmm.func. It is available for all functions except \"nofunction\".To have the DMM include a delay before each measurement, set autodelay to dmm.ON or 1.To have the DMM take a measurement without an automatic delay, set autodelay to dmm.OFF or 0.When this is enabled, a delay is added after a range or function change to allow the instrument to settle.   An error is generated if you try to set autodelay for \"nofunction\". Error code 1114, \"Setting conflicts with function selected,\" is generated. If you query autodelay for \"nofunction\", nil is returned with the same error.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Enable autodelay",
                    "enum": "dmm.ON 1|dmm.OFF 0|dmm.AUTODELAY_ONCE 2",
                    "type": "dmmautodelaystate",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.autodelay",
                "dmm.autodelay = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.autodelay = dmm.ON;dmm.measurecount = 10;ReadingBufferOne = dmm.makebuffer(1000);dmm.measure(ReadingBufferOne);",
                    "description": "An automatic delay is applied to each measurement when the DMM is measuring two-wire ohms. Take 10 measurements and store them in a reading buffer named ReadingBufferOne that can store up to 1000 readings.\n"
                },
                {
                    "example": "dmm.func = \"dcvolts\";dmm.autodelay = dmm.OFF;",
                    "description": "No delay is applied is applied to the DC volt measurements.\n"
                },
                {
                    "example": "dmm.func = \"fourwireohms\";dmm.autodelay = dmm.AUTODELAY_ONCE;dmm.measurecount = 10;ReadingBufferTwo = dmm.makebuffer(1000);dmm.measure(ReadingBufferTwo);",
                    "description": "Sets an autodelay for the first of the ten four-wire ohm readings. Readings two through ten will occur as quickly as possible, with readings stored in a reading buffer called ReadingBufferTwo that can store up to 1000 readings.\n"
                }
            ],
            "related_commands": [
                "Autodelay",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.measurecount"
            ]
        },
        {
            "name": "dmm.autorange",
            "webhelpfile": "15976.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1 (dmm.ON)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the autorange setting for the active function",
            "details": "Autorange selects the best range in which to measure the signal that is applied to the input terminals of the instrument. When autorange is enabled, the range increases at percent of range. The range decreases occur when the reading is <10\u00a0percent of nominal range.The autorange setting applies to the function selected by dmm.func. Autorange is available for the following functions:Autorange is not available for any other functions. If you try to set autorange for any other function, an error is returned. If you query the autorange for any other function, nil is returned and an error is generated.The autorange value is saved with the dmm.func function setting, so if you use another function, then return to the previous setting, such as \"dcvolts\" or \"fourwireohms\", the autorange setting you set previously is retained. With autorange enabled, you can use the dmm.range command to view the range that is presently being used. Using dmm.range to select a fixed range disables autorange.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Autorange",
                    "enum": "dmm.ON 1|dmm.OFF 0",
                    "type": "dmmautorangevalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.autorange",
                "dmm.autorange = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.autorange = dmm.ON;",
                    "description": "Enable autoranging for 2-wire ohms.\n"
                },
                {
                    "example": "dmm.func = \"dcvolts\";dmm.reset(\"active\");print(dmm.autorange, dmm.range);dmm.range = 50e-3;print(dmm.autorange, dmm.range);",
                    "description": "Set DMM function to be DC volts.\n--- --Reset only the active DMM function (DC volts).\n--- --View the default autorange and range selection.\n--- --Select a range suitable for a 50\u00a0mV reading.\n--- --View the default autorange and range selection.\n--- --Output:\n--- --1.000000000e+00        1.000000000e+01\n--- --0.000000000e+00        1.000000000e-01\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.range"
            ]
        },
        {
            "name": "dmm.autozero",
            "webhelpfile": "15977.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "dmm.ON (1)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables automatic updates to the internal reference measurements (autozero) of the instrument",
            "details": "The autozero setting applies to the function selected by dmm.func. It is available for all functions except \"continuity\" and \"nofunction\".You can send dmm.AUTOZERO_ONCE or 2 to refresh the reference points once. When this command is sent, the reference points are refreshed, and then autozero is set to disabled (dmm.OFF or 0). Querying dmm.autozero after sending dmm.AUTOZERO_ONCE generates a response of 0.For dmm.nplc settings that are less than 0.2\u00a0plc, sending dmm.AUTOZERO_ONCE or 2 results in significant delays. For example, the delay time at a NPLC of 0.0005 is 2.75\u00a0s. The delay time at 0.199 is 5.45\u00a0s.An error is generated if:",
            "param_info": [
                {
                    "name": "state",
                    "description": "Enable autozero",
                    "enum": "dmm.ON 1|dmm.OFF 0|dmm.AUTOZERO_ONCE 2",
                    "type": "dmmautozerostate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.autozero",
                "dmm.autozero = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.autozero = dmm.ON;dmm.autozero = dmm.AUTOZERO_ONCE;print(dmm.autozero);\u00a0;\u00a0;timer.reset()dmm.autozero=2time=timer.measure.t()print(time);",
                    "description": "Enables autozero for DC volts.\n--- --\u00a0\n--- --Refreshes the reference points once and sets autozero to dmm.OFF or 0.\n--- --Output:\n--- --0.000000000e+00\n--- --Determines the time delay when autozero is selected.\n"
                }
            ],
            "related_commands": [
                "Autozero",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.nplc",
                "dmm.reset()",
                "reset()"
            ]
        },
        {
            "name": "dmm.calibration.ac()",
            "webhelpfile": "15978.htm",
            "signature": "dmm.calibration.ac(step, value)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function begins the specified AC adjustment step on the DMM.",
            "details": "This command generates an error if the:For detail on how to use dmm.calibration.ac(), see AC volts adjustment, AC current adjustment, and Frequency adjustment.",
            "param_info": [
                {
                    "name": "step",
                    "description": "The AC adjustment step to perform",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "The value for this adjustment step (if the adjustment step has a value)",
                    "enum": "",
                    "type": "number",
                    "range": "(if the adjustment step has a value)"
                }
            ],
            "usage": [
                "dmm.calibration.ac(step)",
                "dmm.calibration.ac(step, value)"
            ],
            "overloads": [
                "dmm.calibration.ac(step)"
            ],
            "examples": [
                {
                    "example": "step;",
                    "description": "The AC adjustment step to perform\n"
                }
            ],
            "related_commands": [
                "dmm.calibration.dc()",
                "dmm.calibration.lock()",
                "dmm.calibration.unlock()"
            ]
        },
        {
            "name": "dmm.calibration.dc()",
            "webhelpfile": "15979.htm",
            "signature": "dmm.calibration.dc(step, value)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function begins a DC adjustment step on the DMM.",
            "details": "This command generates an error if the:For example of use, see DC volts adjustment, Resistance adjustment, and DC current adjustment.",
            "param_info": [
                {
                    "name": "step",
                    "description": "The DC adjustment step to perform",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "value",
                    "description": "The value for this adjustment step (if the adjustment step has a value)",
                    "enum": "",
                    "type": "number",
                    "range": "(if the adjustment step has a value)"
                }
            ],
            "usage": [
                "dmm.calibration.dc(step)",
                "dmm.calibration.dc(step, value)"
            ],
            "overloads": [
                "dmm.calibration.dc(step)"
            ],
            "examples": [
                {
                    "example": "step;",
                    "description": "The DC adjustment step to perform\n"
                }
            ],
            "related_commands": [
                "dmm.calibration.ac()",
                "dmm.calibration.lock()",
                "dmm.calibration.unlock()"
            ]
        },
        {
            "name": "dmm.calibration.lock()",
            "webhelpfile": "15980.htm",
            "signature": "dmm.calibration.lock()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function locks calibration to prevent unintended changes.",
            "details": "Use this command to lock an unlocked calibration. An error is generated if this command is issued when calibration is already locked.Once locked, you must unlock calibration before you can perform calibration again.",
            "param_info": [
                {
                    "name": "dmm.calibration.save()dmm.calibration.lock()",
                    "description": "Save calibration, then lock it.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.calibration.lock()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.calibration.save();dmm.calibration.lock();",
                    "description": "Save calibration, then lock it.\n"
                }
            ],
            "related_commands": [
                "dmm.calibration.unlock()",
                "dmm.calibration.save()"
            ]
        },
        {
            "name": "dmm.calibration.password",
            "webhelpfile": "16010.htm",
            "signature": "",
            "command_return": "password",
            "type": "Attribute (W)\n",
            "default_value": "KI003706\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the password that must be entered before you can unlock calibration.",
            "details": "This attribute can only be set when calibration is unlocked.This attribute generates an error if calibration is locked or if the password string length is greater than ten characters.",
            "param_info": [
                {
                    "name": "password",
                    "description": "A string that represents the valid password to unlock calibration",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.calibration.password = password"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.calibration.unlock(\"KI003706\");dmm.calibration.password = \"myUnlock\";dmm.calibration.lock();",
                    "description": "To change the default calibration password, unlock the calibration with the default password.\n--- --Saves the password as myUnlock.\n--- --Lock calibration. Subsequent unlocks will use the password myUnlock.\n"
                }
            ],
            "related_commands": [
                "dmm.calibration.unlock()"
            ]
        },
        {
            "name": "dmm.calibration.save()",
            "webhelpfile": "16011.htm",
            "signature": "dmm.calibration.save()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function saves calibration data.",
            "details": "This command saves the calibration constants and adjustment date and increases the adjustment count by 1. The adjustment count is the number of times calibration has been saved.This command does not check for errors in calibration data. Calibration data is saved regardless of calibration data errors.The calibration date can be specified with dmm.adjustment.date. If it is not specified, the date is based on the system date.To prevent data loss, you need to send the save command before locking calibration.An error is generated if this command is issued when calibration is already locked. ",
            "param_info": [
                {
                    "name": "dmm.calibration.save()",
                    "description": "Saves calibration data.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.calibration.save()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.calibration.save();",
                    "description": "Saves calibration data.\n"
                }
            ],
            "related_commands": [
                "dmm.adjustment.date",
                "dmm.calibration.lock()",
                "dmm.calibration.unlock()"
            ]
        },
        {
            "name": "dmm.calibration.unlock()",
            "webhelpfile": "16012.htm",
            "signature": "dmm.calibration.unlock(password)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function unlocks calibration if calibration was locked.",
            "details": "If the password does not match the saved password, an error is generated. The default password from the factory is \"KI003706\". You can change the default with dmm.calibration.password.",
            "param_info": [
                {
                    "name": "password",
                    "description": "A string representing the password to unlock calibration",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.calibration.unlock(password)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.calibration.unlock(\"KI003706\");",
                    "description": "Unlocks calibration using the default password.\n"
                }
            ],
            "related_commands": [
                "dmm.calibration.lock()",
                "dmm.calibration.password"
            ]
        },
        {
            "name": "dmm.calibration.verifydate",
            "webhelpfile": "16013.htm",
            "signature": "",
            "command_return": "calibrationVerificationDate",
            "type": "Attribute (RW)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets or queries the calibration verification date in UTC format (number of seconds since January 1, 1970).",
            "details": "When using the os.time() function:See Lua documentation for the formatting options that are available for os.date. This command can only be set when calibration is unlocked.",
            "param_info": [
                {
                    "name": "calibrationVerificationDate",
                    "description": "The number of seconds since January 1, 1970 when the last calibration verify date was set",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "os.time({year=yyyy, month=m, day=d})",
                    "description": "Specifies the date; if a value is not specified, sets the verification date to the present date of the instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "calibrationVerificationDate = dmm.calibration.verifydate",
                "dmm.calibration.verifydate = os.time()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(os.date(\"%m/%d/%Y\", dmm.calibration.verifydate));",
                    "description": "Assume the system date is July 4, 2007 for this example; queries the calibration verification date and formats the response as mm/dd/yyyy:\n--- --07/04/2007\n"
                },
                {
                    "example": "print(os.date(\"%x\", dmm.calibration.verifydate));",
                    "description": "Assume the system date is July 4, 2007 for this example; queries the date and formats the response as mm/dd/yy:\n--- --07/04/07\n"
                },
                {
                    "example": "dmm.calibration.verifydate = os.time{year=2007, month=7, day = 4};",
                    "description": "Set the calibration verification date to July 4, 2007.\n"
                },
                {
                    "example": "dmm.calibration.verifydate = os.time();",
                    "description": "Set the calibration verification to the present date of the instrument.\n"
                }
            ],
            "related_commands": [
                "dmm.adjustment.date",
                "dmm.calibration.unlock()",
                "Lua documentation"
            ]
        },
        {
            "name": "dmm.close()",
            "webhelpfile": "16014.htm",
            "signature": "dmm.close(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function closes the specified channel or channel pattern to prepare for a measurement.",
            "details": "When you close a channel or channel pattern:The DMM configuration is determined by the configuration associated with the channel or channel pattern being closed. If the configuration is a default name, the function of that configuration will be reset to factory default settings. You must create a unique DMM configuration to avoid using factory default settings when assigning to a channel. For more information on setting DMM configuration, see dmm.configure.set(), dmm.setconfig(), and dmm.getconfig().This command allows you to separate the closing of channels from measuring. Therefore, you may execute any number of commands between the close and measure commands to satisfy your application needs.An error is generated if:Once an error is detected, the command stops processing. Channels and DMM settings remain unchanged.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the channel or channel pattern to close",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.close(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.setconfig(\"3003\", \"tempMeasure\");dmm.close('3003');",
                    "description": "Close channel 3 on slot 3 and prepare the DMM for measuring temperature with tempMeasure settings.\n"
                }
            ],
            "related_commands": [
                "channel.exclusiveslotclose()",
                "channel.getclose()",
                "channel.getstate()",
                "channel.setbackplane()",
                "dmm.getconfig()",
                "dmm.open()"
            ]
        },
        {
            "name": "dmm.configure.catalog()",
            "webhelpfile": "16015.htm",
            "signature": "for name in dmm.configure.catalog() do \u2026 end",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates an iterator for user-created DMM configurations.",
            "details": "You can access the catalog for user DMM configurations to print or delete all configurations in the runtime environment.The entries are enumerated in no particular order. This only lists user-created DMM configurations. It does not list the factory default configurations.",
            "param_info": [
                {
                    "name": "name",
                    "description": "A string representing the name of a user-created DMM configuration.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "for name in dmm.configure.catalog() do \u2026 end"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "for name in dmm.configure.catalog() do; print(name);end;",
                    "description": "Prints the names of all user-created DMM configurations in the instrument.\n--- --The output will look similar to:\n--- --TestDcv\n--- --TestTemperature\n--- --TestTwoWire\n--- --\u00a0\n--- --This indicates there are three user-created DMM configurations in the instrument with the names TestDCV, TestTemperature, and TestTwoWire.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.delete()",
                "dmm.configure.query() ",
                "dmm.configure.recall()",
                "dmm.configure.set()"
            ]
        },
        {
            "name": "dmm.configure.delete()",
            "webhelpfile": "16016.htm",
            "signature": "dmm.configure.delete(name)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function deletes a user-created DMM configuration from memory.",
            "details": "If you delete a DMM configuration that is assigned to channels or channel patterns, those channels and patterns revert back to the factory default DMM configuration of \"nofunction\" (dmm.setconfig()).If you delete a DMM configuration that is used in a scan list, the scan list is modified and the channel is set to \"nofunction\" for that configuration.You cannot delete a DMM configuration on a closed channel. If you attempt to delete it, error code 1114, \"Settings conflict with deleting DMM configuration assigned to closed channel,\" is generated.An error is generated if the name specified does not exist as a user configuration.",
            "param_info": [
                {
                    "name": "name",
                    "description": "String that contains the name of the DMM configuration to delete",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.configure.delete(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.configure.delete(\"DCVDMMConfig\");",
                    "description": "Deletes a user configuration called DCVDMMConfig.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.catalog()",
                "dmm.configure.set()",
                "dmm.configure.query()",
                "dmm.configure.recall()"
            ]
        },
        {
            "name": "dmm.configure.query()",
            "webhelpfile": "16017.htm",
            "signature": "dmm.configure.query(userConfiguration, userSeparator)",
            "command_return": "config",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function lists DMM settings associated with a configuration.",
            "details": "For the specified configuration, this function lists the settings and the corresponding DMM attributes.If the specified configuration does not exist, a nil response is generated, along with an error message stating that the referenced name does not exist.If userSeparator is specified, the attributes are delimited by this two-character separator. If more than two characters are specified, an error message is generated.To query the factory default settings for a function, use the function, such as \"dvolts\" or \"temperature\", for the userConfiguration parameter. See dmm.func for valid functions.",
            "param_info": [
                {
                    "name": "config",
                    "description": "An output string that represents the DMM attribute settings of userConfiguration",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "userConfiguration",
                    "description": "A string that contains the name for the DMM configuration to be listed; to query the settings for the active function, set this parameter to \"active\"",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "userSeparator",
                    "description": "A string that represents the two-character separator that is inserted between items; the default value is a comma followed by a space (, )",
                    "enum": "",
                    "type": "string",
                    "range": "(, )"
                }
            ],
            "usage": [
                "config = dmm.configure.query(userConfiguration)",
                "config = dmm.configure.query(userConfiguration, userSeparator)"
            ],
            "overloads": [
                "config = dmm.configure.query(userConfiguration)"
            ],
            "examples": [
                {
                    "example": "ActiveFunc = dmm.configure.query(\"active\", \"\\n\");print(ActiveFunc);",
                    "description": "Lists the DMM attributes for the active function separated by new lines.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.catalog()",
                "dmm.configure.delete()",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.configure.recall()",
            "webhelpfile": "16018.htm",
            "signature": "dmm.configure.recall(configuration)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function recalls a user or factory DMM configuration and replaces attributes in the present configuration with attributes from the recalled version.",
            "details": "This command recalls the DMM configuration for one function.When a configuration is recalled, the function associated with the configuration becomes active.When you recall a DMM configuration, the existing DMM configuration settings for the function are replaced by the settings in the recalled configuration. Settings for other functions are not affected. For example, if the function associated with the configuration was temperature, only temperature settings are recalled. If a factory configuration is recalled, the function's attributes are set to their factory default values.The DMM configuration can be user-defined or factory-defined.User-defined DMM configurations are set with dmm.configure.set(). The factory-defined DMM configurations are:",
            "param_info": [
                {
                    "name": "configuration",
                    "description": "A string that represents the name of the DMM configuration to recall",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.configure.recall(configuration)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.reset(\"active\") ;dmm.nplc = 0.5;dmm.range = 10;dmm.configure.set(\"TestDcv\");dmm.configure.recall(\"dcvolts\");print(dmm.func, dmm.autorange, dmm.range, dmm.nplc);dmm.configure.recall(\"TestDcv\");print(dmm.func, dmm.autorange, dmm.range, dmm.nplc);dmm.setconfig(\"slot1\", \"TestDcv\");dmm.setconfig(\"2001:2015\", \"TestDcv\");dmm.setconfig(\"3005\", \"TestDcv\");",
                    "description": "Set the DMM to the dc voltage function.\n--- --Reset DC volts back to factory defaults.\n--- --Set the NPLC for dc voltage volts to 0.5.\n--- --Select the 10 V range for dc voltage and disable autorange.\n--- --Save a user DMM configuration for dc voltage called \"TestDcv\".\n--- --Recall and configure the DMM for factory dc voltage.\n--- --Output the settings for factory-defined dc voltage.\n--- --Recall the user DMM configuration called \"TestDcv\".\n--- --Output the settings for TestDcv.\n--- --Set the DMM configuration for slot 1, channels 2001 to 2005, and channel 3005 to TestDcv.\n--- --Output:\n--- --dcvolts\t1.000000000e+00\t1.000000000e+01\t1.000000000e+00\n--- --dcvolts\t0.000000000e+00\t1.000000000e+01\t5.000000000e-01\n"
                }
            ],
            "related_commands": [
                "dmm.configure.delete()",
                "dmm.configure.query()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.configure.set()",
            "webhelpfile": "16019.htm",
            "signature": "dmm.configure.set(name)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "See Details\n",
            "tsp_link": "Yes\n",
            "description": "This function creates a named DMM configuration for the selected function. The configuration includes pertinent attributes for that function.",
            "details": "This command saves the selected function and its pertinent settings. You can recall this configuration using dmm.configure.recall(). You can also apply the configuration using dmm.setconfig() to channels or channel patterns.dmm.configure.set() stores only pertinent settings. For example, if dmm.func is set to \"dcvolts\", temperature settings are not stored.DMM configurations are not saved through a power cycle. To save the configuration through a power cycle, use setup.save() or  createconfigscript(). These options save all DMM user configurations.If the name of the configuration:Some DMM configurations are preset. The factory default configuration names are:If you change the settings for an existing DMM configuration, the existing scan list will be updated to use the new settings for the existing DMM configuration. However, if the function or a setting is not valid for a channel in the scan list, the scan list will be reset to the default configuration of \"nofunction\".",
            "param_info": [
                {
                    "name": "name",
                    "description": "A string that contains the name of the DMM configuration that you are creating",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.configure.set(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.reset(\"active\") ;dmm.nplc = 0.5;dmm.range = 10;dmm.configure.set(\"TestDcv\");dmm.configure.recall(\"dcvolts\");print(dmm.func, dmm.autorange, dmm.range, dmm.nplc);dmm.configure.recall(\"TestDcv\");print(dmm.func, dmm.autorange, dmm.range, dmm.nplc) ;",
                    "description": "Set the DMM to the dc voltage function.\n--- --Reset DC volts back to factory defaults.\n--- --Set the NPLC for dc voltage to 0.5.\n--- --Select the 10 V range for dc voltage and disable autorange.\n--- --Save a user DMM configuration for dc voltage called \"TestDcv\".\n--- --Recall and configure the DMM for factory dc voltage.\n--- --Output the settings for factory dc voltage.\n--- --Recall the user DMM configuration called \"TestDcv\".\n--- --Output the settings for the TestDcv configuration.\n--- --Output:\n--- --dcvolts\t1.000000000e+00\t1.000000000e+01\t1.000000000e+00\n--- --dcvolts\t0.000000000e+00\t1.000000000e+01\t5.000000000e-01\n"
                }
            ],
            "related_commands": [
                "createconfigscript()",
                "dmm.configure.catalog() ",
                "dmm.configure.delete()",
                "dmm.configure.query() ",
                "dmm.configure.recall()",
                "dmm.func",
                "dmm.setconfig()",
                "setup.save()"
            ]
        },
        {
            "name": "dmm.connect",
            "webhelpfile": "16020.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "7 (dmm.CONNECT_ALL)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates how the DMM relays should be connected to the analog backplane.",
            "details": "This setting affects all DMM functions. Valid values are shown in the table below.The relays are bitmapped into the lower 3 bits of the value as shown in the following table.To close a relay, set the appropriate bit to 1.To open a relay, set the appropriate bit to 0.An error is generated if:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The DMM relay connection setting. See Details for valid values",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.connect",
                "dmm.connect = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.connect = dmm.CONNECT_TWO_WIRE_AMPS;",
                    "description": "Connects the DMM 2-wire and amp relays to the analog backplane.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "dmm.dbreference",
            "webhelpfile": "16021.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.000000E+00\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the decibel (dB) reference setting for the DMM in volts.",
            "details": "The dB reference setting applies only when dmm.func is set to \"dcvolts\" or \"acvolts\". If you query this value for any other function, nil is returned.An error is generated:The dB reference setting is saved with the dmm.func function setting, so if you use another function, then return to \"dcvolts\" or \"acvolts\", the dB reference setting you set previously are retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The dB reference in volts (1e-7 to 1000)",
                    "enum": "",
                    "type": "any",
                    "range": "(1e-7 to 1000)"
                }
            ],
            "usage": [
                "value = dmm.dbreference",
                "dmm.dbreference = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.dbreference = 5;",
                    "description": "Sets the dB reference to 5 volts for DC volts.\n"
                }
            ],
            "related_commands": [
                "Express DC or AC voltage in decibels",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.aperture"
            ]
        },
        {
            "name": "dmm.detectorbandwidth",
            "webhelpfile": "16022.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "300\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the AC detector bandwidth setting for the DMM in Hertz.",
            "details": "Only applies when dmm.func is set to \"acvolts\" or \"accurrent\".If you query this value for any other function, nil is returned.When you send this value, the input value is adjusted as follows:An error is generated:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The detector bandwidth in Hertz",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.detectorbandwidth",
                "dmm.detectorbandwidth = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset();dmm.func = \"acvolts\";print(dmm.func, dmm.detectorbandwidth);dmm.detectorbandwidth = 35;print(dmm.func, dmm.detectorbandwidth);dmm.func = \"accurrent\";print(dmm.func, dmm.detectorbandwidth);dmm.func = \"acvolts\";print(dmm.func, dmm.detectorbandwidth);\u00a0;",
                    "description": "Sets the detector bandwidth to 35 Hz for AC\u00a0volts. 35 is adjusted to 30. AC current is still at 300\u00a0Hz.\n--- --Output:\n--- --acvolts     3.000000000e+02\n--- --acvolts     3.000000000e+01\n--- --accurrent   3.000000000e+02\n--- --acvolts     3.000000000e+01\n"
                }
            ],
            "related_commands": [
                "dmm.aperture",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.displaydigits",
            "webhelpfile": "16023.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "See Details\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines the number of digits that are displayed for measurements on the front panel.",
            "details": "This is not available for \"nofunction\". This command affects how the reading for a measurement is displayed on the front panel of the instrument. It does not affect the number of digits returned in a remote command reading. It also does not affect the accuracy or speed of measurements.The display digits setting is saved with the function setting, so if you use another function, then return to the function for which you set display digits, the display digits setting you set previously is retained.The change in digits occurs the next time a measurement is made.To change the number of digits returned in a remote command reading, use format.asciiprecision.An error is generated:",
            "param_info": [
                {
                    "name": "value",
                    "description": "7\u00bd display digits",
                    "enum": "dmm.DIGITS_7_5 7|dmm.DIGITS_6_5 6|dmm.DIGITS_5_5 5|dmm.DIGITS_4_5 4|dmm.DIGITS_3_5 3",
                    "type": "dmmdisplaydigitsvalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.displaydigits",
                "dmm.displaydigits = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.displaydigits = dmm.DIGITS_7_5;",
                    "description": "Enables display digits to 7\u00bd for DC volts.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "format.asciiprecision"
            ]
        },
        {
            "name": "dmm.drycircuit",
            "webhelpfile": "16024.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables the dry circuit feature of the 4\u2011wire resistance measure function.",
            "details": "The dry circuit setting only applies when dmm.func is set to \"fourwireohms\" or \"commonsideohms\". Enabling dry circuit limits the open-circuit voltage to below 20\u00a0mV, which is often required with low\u2011glitch measurements, such as measuring switch and relay contact resistance.When dry circuit is enabled, offset compensation is automatically enabled.An error is generated if:The dry circuit setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the dry circuit setting you set previously is retained.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Enable dry circuit",
                    "enum": "dmm.ON 1|dmm.OFF 0",
                    "type": "dmmdrycircuitstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.drycircuit",
                "dmm.drycircuit = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"fourwireohms\";dmm.drycircuit = dmm.ON;",
                    "description": "Enable dry circuit for 4-wire ohms.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.offsetcompensation"
            ]
        },
        {
            "name": "dmm.filter.count",
            "webhelpfile": "16025.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "10\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the filter count setting for the selected DMM function.",
            "details": "The number of measured readings that will yield one filtered measurement when filtered measurements are enabled.The filter count setting only applies when dmm.func is set to one of the following:If you query the setting for any other function, nil is returned.The filter count setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the filter count setting you set previously is retained.An error is generated if:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The filter count setting from 1 to 100",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.filter.count",
                "dmm.filter.count = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.filter.count = 5;dmm.filter.enable = dmm.ON;",
                    "description": "Sets the filter count for 2-wire ohms to 5 and enables filtered measurements.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.set()",
                "dmm.configure.recall()",
                "dmm.filter.enable",
                "dmm.filter.type"
            ]
        },
        {
            "name": "dmm.filter.enable",
            "webhelpfile": "16026.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables the averaging filter for measurements of the selected function.",
            "details": "The filter enable setting only applies when dmm.func is set to one of the following:Querying the setting for any other function will return nil and an error message.The filter enable setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the filter enable setting you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Filter measurements setting",
                    "enum": "dmm.ON 1|dmm.OFF 0",
                    "type": "dmmfilterenablevalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.filter.enable",
                "dmm.filter.enable = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.filter.type = dmm.FILTER_MOVING_AVG;dmm.filter.count = 3;dmm.filter.enable = dmm.ON;",
                    "description": "Enable filtered measurements for 2-wire ohms using a moving average filter type with a count of 3 for each measurement.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.filter.count",
                "dmm.filter.type",
                "dmm.filter.window",
                "dmm.func",
                "dmm.reset()"
            ]
        },
        {
            "name": "dmm.filter.type",
            "webhelpfile": "16027.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1 (dmm.FILTER_REPEAT_AVG)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the type of averaging filter that is used for the selected measure function when the measurement filter is enabled.",
            "details": "The filter type setting only applies when dmm.func is set to one of the following:Querying the setting for any other function returns nil. An error is generated if this setting is written or read for any other function.You can choose from two averaging filter types: Repeating and moving.When the repeating average filter is selected, a set of measurements are made. These measurements are stored in a measurement stack and averaged together to produce the averaged sample. Once the averaged sample is produced, the stack is flushed, and the next set of data is used to produce the next averaged sample. This type of filter is the slowest, since the stack must be completely filled before an averaged sample can be produced, but it provides more stable results.When the moving average filter is selected, the measurements are added to the stack continuously on a first-in, first-out basis. As each measurement is made, the oldest measurement is removed from the stack. A new averaged sample is produced using the new measurement and the data that is now in the stack.The filter type setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the filter type setting you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The filter type setting",
                    "enum": "dmm.FILTER_MOVING_AVG 0|dmm.FILTER_REPEAT_AVG 1",
                    "type": "dmmfiltertypevalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.filter.type",
                "dmm.filter.type = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.filter.type = dmm.FILTER_MOVING_AVG;dmm.filter.enable = dmm.ON;",
                    "description": "Set the filter type for 2-wire ohms to moving average and enable filtered measurements.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.filter.count",
                "dmm.filter.enable",
                "dmm.filter.window",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.filter.window",
            "webhelpfile": "16028.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.000000E-01 (0.1)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the window for the averaging filter that is used for measurements for the selected function.",
            "details": "The filter window setting only applies when dmm.func is set to one of the following:Querying the setting for any other function returns nil. An error is generated if this setting is written or read for any other function.An error is generated if the value is out of range.The filter window setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the filter window setting you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The filter window setting; the range is between 0 and 10 to indicate percent of range",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.filter.window",
                "dmm.filter.window = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.filter.window = 0.25;dmm.filter.enable = dmm.ON;",
                    "description": "Set the filter window for 2-wire ohms to 0.25 and enable filtered measurements.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.filter.enable",
                "dmm.filter.count",
                "dmm.filter.type"
            ]
        },
        {
            "name": "dmm.fourrtd",
            "webhelpfile": "16029.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.RTD_PT100)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the type of 4-wire RTD that is being used.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\" and dmm.transducer is set to dmm.TEMP_FOURRTD. For all other transducer types, the attribute is set but is not used until the transducer type is set for four-wire RTD.All other functions generate an error and return nil when queried. An illegal parameter value error message is generated if the value specified is not a supported RTD type value as listed in the usage table.The four-wire RTD setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the four-wire RTD settings you set previously are retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The type of four-wire RTD",
                    "enum": "dmm.RTD_PT100 0|dmm.RTD_D100 1|dmm.RTD_F100 2|dmm.RTD_PT385 3|dmm.RTD_PT3916 4|dmm.RTD_USER 5",
                    "type": "dmmfourrtdvalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.fourrtd",
                "dmm.fourrtd = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_FOURRTD;dmm.fourrtd = dmm.RTD_PT3916;",
                    "description": "Sets the type of four-wire RTD for PT3916.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.transducer"
            ]
        },
        {
            "name": "dmm.func",
            "webhelpfile": "16030.htm",
            "signature": "",
            "command_return": "function",
            "type": "Attribute (RW)\n",
            "default_value": "dmm.DC_VOLTS\n",
            "tsp_link": "Yes\n",
            "description": "This attribute selects the active measure function.",
            "details": "This attribute determines the selected DMM function and indicates how the other DMM attributes are to be processed.When the DMM functionality changes, the attributes for the new DMM function become active. Unless you update these attributes, they will be the factory defaults or the values that were used the last time the function was used. If you want to see settings for a particular function, change to that function with dmm.func, then write or read the settings specifically. To see all attributes at once, use dmm.configure.query with a first parameter value of \"active\" as shown in the example below.An error is generated:If an error is found, no change is made to the function.",
            "param_info": [
                {
                    "name": "measFunction",
                    "description": "One of the following DMM functions",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "function = dmm.func",
                "dmm.func = function"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";",
                    "description": "Makes \"temperature\" the active DMM function.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.query()",
                "dmm.configure.recall()",
                "dmm.configure.set()"
            ]
        },
        {
            "name": "dmm.getconfig()",
            "webhelpfile": "16031.htm",
            "signature": "dmm.getconfig(channelList)",
            "command_return": "DMMconfiguration",
            "type": "Function\n",
            "default_value": "\"nofunction\"\n",
            "tsp_link": "Yes\n",
            "description": "This function queries for the DMM configurations that are associated with the specified channels or channel patterns.",
            "details": "The response is a comma-delimited string that lists the user-defined and factory-defined configurations. They are listed in the same order in which they are specified in channelList.The configurations indicate how the DMM will be configured when the corresponding channel or channel pattern is closed with the dmm.close() function or used in a scan list without an overriding DMM configuration.An error is generated if:",
            "param_info": [
                {
                    "name": "DMMconfiguration",
                    "description": "A comma-delimited string that lists the DMM configurations associated with items in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "The channels or channel patterns to query",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "DMMconfiguration = dmm.getconfig(channelList) "
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "slot1_2Configs = dmm.getconfig(\"slot1, slot2\");print(slot1_2Configs);",
                    "description": "Queries channels on slots 1 and 2.\n"
                }
            ],
            "related_commands": [
                "dmm.close()",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.setconfig()",
                "scan.add()",
                "scan.create()"
            ]
        },
        {
            "name": "dmm.inputdivider",
            "webhelpfile": "16032.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines when the 10\u00a0M\u03a9 input divider is enabled.",
            "details": "This attribute is only valid when dmm.func is set to DC volts.The input divider setting is saved with the dmm.func function setting, so if you use another function, then return to \"dcvolts\", the input divider setting you set previously is retained.An error is generated if you try to set input divider for any DMM function other than \"dcvolts\". Error code 1114, \"Setting conflicts with function selected,\" is generated. If you query any DMM function other than \"dcvolts\" for input divider, nil is returned with the same error.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Disable input divider",
                    "enum": "dmm.OFF 0|dmm.ON 1",
                    "type": "dmminputdividerstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.inputdivider",
                "dmm.inputdivider = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.inputdivider = dmm.ON;",
                    "description": "Enables the input divider for DC volts.\n"
                }
            ],
            "related_commands": [
                "DC volts input divider",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.limit[Y].autoclear",
            "webhelpfile": "16034.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1 (dmm.ON)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if the test result for limit Y should be cleared automatically or not.",
            "details": "This attribute is valid for all functions except \"continuity\" and \"nofunction\". A nil response and an error are generated if the command is received when dmm.func is set to either of these functions.When auto clear is set to on, limit conditions are cleared automatically after each measurement. If you are making a series of measurements, the instrument shows the limit test result of the last measurement for the pass or fail indication for the limit.If you want to know if any of a series of measurements failed the limit, set the auto clear setting to off. When this is set to off, a failed indication is not cleared automatically. It remains set until it is cleared with the clear command.The auto clear setting affects both the high and low limits.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The auto clear setting",
                    "enum": "dmm.OFF 0|dmm.ON 1",
                    "type": "dmmlimitautoclearvalue",
                    "range": ""
                },
                {
                    "name": "Y",
                    "description": "Limit number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.limit[Y].autoclear",
                "dmm.limit[Y].autoclear = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.limit[2].autoclear = dmm.ON;",
                    "description": "Enables auto clear on limit 2 for two-wire ohms.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.limit[Y].clear()",
                "dmm.measure()"
            ]
        },
        {
            "name": "dmm.limit[Y].clear()",
            "webhelpfile": "16035.htm",
            "signature": "dmm.limit[Y].clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the results of the limit test defined by Y.",
            "details": "Use this command to clear the test results of limit Y when the limit auto clear option is turned off. Both the high and low test results are cleared.To avoid the need to manually clear the test results for a limit, turn the auto clear option on.",
            "param_info": [
                {
                    "name": "Y",
                    "description": "Limit number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.limit[Y].clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.limit[2].clear();",
                    "description": "Clears the test results for the high and low limit 2 for two-wire ohms.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.limit[Y].autoclear",
                "dmm.limit[Y].high.fail",
                "dmm.limit[Y].low.fail"
            ]
        },
        {
            "name": "dmm.limit[Y].enable",
            "webhelpfile": "16036.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables a limit test on the measurement from the selected measure function.",
            "details": "This attribute is valid for all functions except \"continuity\" and \"nofunction\". A nil response and an error are generated if the command is received when dmm.func is set to either of these functions.When this attribute is enabled, the limit Y testing occurs on each measurement taken by the DMM. Limit Y testing compares the measurements to the high and low limit values. If a measurement falls outside these limits, the test fails. The low limit is specified by dmm.limit[Y].low.value and the high limit is specified by dmm.limit[Y].high.value.When this is enabled, limit testing occurs whether it is requested by the dmm.measure function or as part of a scan sequence. However, if events are not assigned to a trigger stimulus for a digital I/O line, there is no hardware indication of limits. The events that can be assigned to a trigger stimulus include:To see the test results, use the dmm.limit[Y].low.fail and dmm.limit[Y].high.fail attributes.When limit testing is disabled, no measurements are tested and the status bits are not updated, the fail indication does not get updated, and hardware lines are not generated.This example enables limits 1 and 2 for DC volt, measurements. Limit 1 is checking for readings to be between 3 and 5 volts while limit 2 is checking for the readings to be between 1 and 7 volts. The auto clear feature is disabled, so if any reading is outside these limits, the corresponding fail will be 1 afterwards. Therefore, if any one of the fails is 1, analyze the reading buffer data to find out which reading failed the limits.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Limit Y testing",
                    "enum": "dmm.OFF 0|dmm.ON 1",
                    "type": "dmmlimitenablevalue",
                    "range": ""
                },
                {
                    "name": "Y",
                    "description": "Limit number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.limit[Y].enable",
                "dmm.limit[Y].enable = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\"                 -- set the DMM for DC volts functionality ;dmm.reset(\"active\")                  -- reset DC volts to default settings ;dmm.range = 10                       -- set the range to 10 volts ;dmm.nplc = 0.1                       -- set the nplc to 0.1 ;dmm.limit[1].autoclear = dmm.OFF     -- disable auto clearing for limit 1 ;dmm.limit[1].high.value = 5          -- set high limit on 1 to fail if reading                                     -- exceeds 5 volts ;dmm.limit[1].low.value = 3           -- set low limit on 1 to fail if reading                                     -- is less than 3 volts ;dmm.limit[1].enable = dmm.ON         -- enable limit 1 checking for DC volt                                     -- measurements ;dmm.limit[2].autoclear = dmm.OFF     -- disable auto clearing for limit 2 ;dmm.limit[2].high.value = 7          -- set high limit on 2 to fail if reading                                     -- exceeds 7 volts ;dmm.limit[2].low.value = 1           -- set low limit on 2 to fail if reading                                     -- is less than 1 volts ;dmm.limit[2].enable = dmm.ON         -- enable limit 2 checking for DC volt                                     -- measurements ;dmm.measurecount = 50                -- set the measure count to 50 ;LimitBuffer = dmm.makebuffer(100)    -- create a reading buffer that can store                                     -- 100 readings ;dmm.measure(LimitBuffer)             -- take 50 readings and store them in                                     -- LimitBuffer ;                                     -- then check if any of the 50 readings                                     -- were outside of the limits ;print(\"limit 1 high fail = \" .. dmm.limit[1].high.fail) ;print(\"limit 1 low fail = \" .. dmm.limit[1].low.fail) ;print(\"limit 2 high fail = \" .. dmm.limit[2].high.fail) ;print(\"limit 2 low fail = \" .. dmm.limit[2].low.fail) ;dmm.limit[1].clear()                 -- clear limit 1 conditions;dmm.limit[2].clear()                 -- clear limit 2 conditions;",
                    "description": "Sample output that shows all readings are within limit values (all readings between 3 and 5 volts):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 high values (a 6 volt reading would cause this condition or a reading greater than 5 but less than 7.):\n--- --limit 1 high fail = 1\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 and 2 low values (a 0.5 volts reading would cause this condition or a reading less than 1):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 1\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 1\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.limit[Y].high.fail",
                "dmm.limit[Y].high.value",
                "dmm.limit[Y].low.fail",
                "dmm.limit[Y].low.value",
                "dmm.measure()"
            ]
        },
        {
            "name": "dmm.limit[Y].high.fail",
            "webhelpfile": "16037.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute queries for the high test results of limit Y.",
            "details": "This attribute is valid for all functions except \"continuity\" and \"nofunction\". A nil response and an error are generated if the command is received when dmm.func is set to either of these functions.This attribute returns the results of high limit Y testing. If this is 1 (failed), the measurement was above the high limit (dmm.limit[Y].high.value).Note that if you are scanning or taking a series of measurements with auto clear (dmm.limit[Y].autoclear) enabled for a limit, the last measurement limit dictates the fail indication for the limit. If autoclear is disabled, you can take a series of readings and read fails to see if any of one of the readings failed.To use this attribute, you must set the limit to enable.If autoclear and limit are not set, the high fail value indicates the results of the last limit test that occurred when limits were enabled.In addition to this attribute, you can see the fail indication by reading the measurement event register of the status model. If the readings are stored in a reading buffer, the values are associated with bufferVar.statuses for the readings.You can use the digital I/O line trigger stimulus commands to generate a pulse when a limit fails. The events that can be assigned to a trigger stimulus include:This example enables limits 1 and 2 for DC volt, measurements. Limit 1 is checking for readings to be between 3 and 5 volts while limit 2 is checking for the readings to be between 1 and 7 volts. The auto clear feature is disabled, so if any reading is outside these limits, the corresponding fail will be 1 afterwards. Therefore, if any one of the fails is 1, analyze the reading buffer data to find out which reading failed the limits.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The high fail indication for limit Y",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "Y",
                    "description": "Limit number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.limit[Y].high.fail"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\"                 -- set the DMM for DC volts functionality ;dmm.reset(\"active\")                  -- reset DC volts to default settings ;dmm.range = 10                       -- set the range to 10 volts ;dmm.nplc = 0.1                       -- set the nplc to 0.1 ;dmm.limit[1].autoclear = dmm.OFF     -- disable auto clearing for limit 1 ;dmm.limit[1].high.value = 5          -- set high limit on 1 to fail if reading                                     -- exceeds 5 volts ;dmm.limit[1].low.value = 3           -- set low limit on 1 to fail if reading                                     -- is less than 3 volts ;dmm.limit[1].enable = dmm.ON         -- enable limit 1 checking for DC volt                                     -- measurements ;dmm.limit[2].autoclear = dmm.OFF     -- disable auto clearing for limit 2 ;dmm.limit[2].high.value = 7          -- set high limit on 2 to fail if reading                                     -- exceeds 7 volts ;dmm.limit[2].low.value = 1           -- set low limit on 2 to fail if reading                                     -- is less than 1 volts ;dmm.limit[2].enable = dmm.ON         -- enable limit 2 checking for DC volt                                     -- measurements ;dmm.measurecount = 50                -- set the measure count to 50 ;LimitBuffer = dmm.makebuffer(100)    -- create a reading buffer that can store                                     -- 100 readings ;dmm.measure(LimitBuffer)             -- take 50 readings and store them in                                     -- LimitBuffer ;                                     -- then check if any of the 50 readings                                     -- were outside of the limits ;print(\"limit 1 high fail = \" .. dmm.limit[1].high.fail) ;print(\"limit 1 low fail = \" .. dmm.limit[1].low.fail) ;print(\"limit 2 high fail = \" .. dmm.limit[2].high.fail) ;print(\"limit 2 low fail = \" .. dmm.limit[2].low.fail) ;dmm.limit[1].clear()                 -- clear limit 1 conditions;dmm.limit[2].clear()                 -- clear limit 2 conditions;",
                    "description": "Sample output that shows all readings are within limit values (all readings between 3 and 5 volts):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 high values (a 6 volt reading would cause this condition or a reading greater than 5 but less than 7.):\n--- --limit 1 high fail = 1\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 and 2 low values (a 0.5 volts reading would cause this condition or a reading less than 1):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 1\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 1\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.limit[Y].autoclear"
            ]
        },
        {
            "name": "dmm.limit[Y].high.value",
            "webhelpfile": "16038.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "limit 1: 1.000000E+00limit 2: 2.000000E+00\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the upper limit for a limit test.",
            "details": "This attribute is valid for all functions except \"continuity\" and \"nofunction\". A nil response and an error are generated if the command is received when dmm.func is set to either of these functions.This attribute specifies or queries the high limit value of limit Y. When limit Y testing is enabled (dmm.limit[Y].enable = 1), a fail indication occurs when the measurement value is greater than this value.You may set or get the value regardless if the limit is set to a digio trigger stimulus:This example enables limits 1 and 2 for DC volt, measurements. Limit 1 is checking for readings to be between 3 and 5 volts while limit 2 is checking for the readings to be between 1 and 7 volts. The auto clear feature is disabled, so if any reading is outside these limits, the corresponding fail will be 1 afterwards. Therefore, if any one of the fails is 1, analyze the reading buffer data to find out which reading failed the limits.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The high value for limit Y; range is -4294967295 to +4294967295",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "Y",
                    "description": "Limit number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.limit[Y].high.value",
                "dmm.limit[Y].high.value = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\"                 -- set the DMM for DC volts functionality ;dmm.reset(\"active\")                  -- reset DC volts to default settings ;dmm.range = 10                       -- set the range to 10 volts ;dmm.nplc = 0.1                       -- set the nplc to 0.1 ;dmm.limit[1].autoclear = dmm.OFF     -- disable auto clearing for limit 1 ;dmm.limit[1].high.value = 5          -- set high limit on 1 to fail if reading                                     -- exceeds 5 volts ;dmm.limit[1].low.value = 3           -- set low limit on 1 to fail if reading                                     -- is less than 3 volts ;dmm.limit[1].enable = dmm.ON         -- enable limit 1 checking for DC volt                                     -- measurements ;dmm.limit[2].autoclear = dmm.OFF     -- disable auto clearing for limit 2 ;dmm.limit[2].high.value = 7          -- set high limit on 2 to fail if reading                                     -- exceeds 7 volts ;dmm.limit[2].low.value = 1           -- set low limit on 2 to fail if reading                                     -- is less than 1 volts ;dmm.limit[2].enable = dmm.ON         -- enable limit 2 checking for DC volt                                     -- measurements ;dmm.measurecount = 50                -- set the measure count to 50 ;LimitBuffer = dmm.makebuffer(100)    -- create a reading buffer that can store                                     -- 100 readings ;dmm.measure(LimitBuffer)             -- take 50 readings and store them in                                     -- LimitBuffer then check if any ;                                     -- of the 50 readings were                                     -- outside of the limits ;print(\"limit 1 high fail = \" .. dmm.limit[1].high.fail) ;print(\"limit 1 low fail = \" .. dmm.limit[1].low.fail) ;print(\"limit 2 high fail = \" .. dmm.limit[2].high.fail) ;print(\"limit 2 low fail = \" .. dmm.limit[2].low.fail) ;dmm.limit[1].clear()                 -- clear limit 1 conditions;dmm.limit[2].clear()                 -- clear limit 2 conditions;",
                    "description": "Sample output that shows all readings are within limit values (all readings between 3 and 5 volts):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 high values (a 6 volt reading would cause this condition or a reading greater than 5 but less than 7.):\n--- --limit 1 high fail = 1\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 and 2 low values (a 0.5 volts reading would cause this condition or a reading less than 1):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 1\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 1\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "digio.trigger[N].stimulus",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.limit[Y].enable",
                "dmm.limit[Y].high.fail",
                "dmm.limit[Y].low.value"
            ]
        },
        {
            "name": "dmm.limit[Y].low.fail",
            "webhelpfile": "16039.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute queries for the low test results of limit Y.",
            "details": "This attribute is valid for all functions except \"continuity\" and \"nofunction\". A nil response and an error are generated if the command is received when dmm.func is set to either of these functions.This attribute returns the results of low limit Y testing. If this is 1 (failed) is returned, the measurement was below the low limit.Note that if you are scanning or taking a series of measurements with auto clear (dmm.limit[Y].autoclear) enabled for a limit, the last measurement limit dictates the fail indication for the limit. If autoclear is disabled, you can take a series of readings and read fails to see if any of one of the readings failed.To use this attribute, you must set the limit to enable.If autoclear and limit are not set, the low fail value indicates the results of the last limit test that occurred when limits were enabled.In addition to this attribute, you can see the fail indication by reading the measurement event register of the status model. If the readings are stored in a reading buffer, the values are associated with bufferVar.statuses for the readings.This example enables limits 1 and 2 for DC volt measurements. Limit 1 is checking for readings to be between 3 and 5 volts. Limit 2 is checking for the readings to be between 1 and 7 volts. The auto clear feature is disabled, so if any reading is outside these limits, the corresponding fail will be 1 afterwards. Therefore, if any one of the fails is 1, analyze the reading buffer data to find out which reading failed the limits.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The low fail indication of limit Y",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "Y",
                    "description": "1 or 2 for limit number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.limit[Y].low.fail"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\"                 -- set the DMM for DC volts functionality;dmm.reset(\"active\")                  -- reset DC volts to default settings;dmm.range = 10                       -- set the range to 10 volts;dmm.nplc = 0.1                       -- set the nplc to 0.1;dmm.limit[1].autoclear = dmm.OFF     -- disable auto clearing for limit 1;dmm.limit[1].high.value = 5          -- set high limit on 1 to fail if reading;                                     -- exceeds 5 volts;dmm.limit[1].low.value = 3           -- set low limit on 1 to fail if reading;                                     -- is less than 3 volts;dmm.limit[1].enable = dmm.ON         -- enable limit 1 checking for DC volt;                                     -- measurements;dmm.limit[2].autoclear = dmm.OFF     -- disable auto clearing for limit 2;dmm.limit[2].high.value = 7          -- set high limit on 2 to fail if reading;                                     -- exceeds 7 volts;dmm.limit[2].low.value = 1           -- set low limit on 2 to fail if reading;                                     -- is less than 1 volts;dmm.limit[2].enable = dmm.ON         -- enable limit 2 checking for DC volt;                                     -- measurements;dmm.measurecount = 50                -- set the measure count to 50;LimitBuffer = dmm.makebuffer(100)    -- create a reading buffer that can store;                                     -- 100 readings;dmm.measure(LimitBuffer)             -- take 50 readings and store them in;                                     -- LimitBuffer;                                     -- then check if any of the 50 readings;                                     -- were outside of the limits;print(\"limit 1 high fail = \" .. dmm.limit[1].high.fail);print(\"limit 1 low fail = \" .. dmm.limit[1].low.fail);print(\"limit 2 high fail = \" .. dmm.limit[2].high.fail);print(\"limit 2 low fail = \" .. dmm.limit[2].low.fail);dmm.limit[1].clear()                 -- clear limit 1 conditions;dmm.limit[2].clear()                 -- clear limit 2 conditions;",
                    "description": "Sample output that shows all readings are within limit values (all readings between 3 and 5 volts):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 high values (a 6 volt reading would cause this condition or a reading greater than 5 but less than 7.):\n--- --limit 1 high fail = 1\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 and 2 low values (a 0.5 volts reading would cause this condition or a reading less than 1):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 1\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 1\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.limit[Y].autoclear"
            ]
        },
        {
            "name": "dmm.limit[Y].low.value",
            "webhelpfile": "16040.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "limit 1: -1.000000E+00limit 2: -2.000000E+00\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the lower limit for a limit test.",
            "details": "This attribute is valid for all functions except \"continuity\" and \"nofunction\". A nil response and an error are generated if the command is received when dmm.func is set to either of these functions.This command sets the lower limit for the limit Y test for the selected measure function. When limit Y testing is enabled, this causes a fail indication to occur when the measurement value is less than this value.You may set or get the value regardless if the limit is set to a digital I/O trigger stimulus:This example enables limits 1 and 2 for DC volt, measurements. Limit 1 is checking for readings to be between 3 and 5 volts while limit 2 is checking for the readings to be between 1 and 7 volts. The auto clear feature is disabled, so if any reading is outside these limits, the corresponding fail will be 1 afterwards. Therefore, if any one of the fails is 1, analyze the reading buffer data to find out which reading failed the limits.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The low limit value of limit Y; the valid range is -4294967295 to +4294967295",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "Y",
                    "description": "Limit number 1 or 2",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.limit[Y].low.value",
                "dmm.limit[Y].low.value = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\"                 -- set the DMM for DC volts functionality ;dmm.reset(\"active\")                  -- reset DC volts to default settings ;dmm.range = 10                       -- set the range to 10 volts ;dmm.nplc = 0.1                       -- set the nplc to 0.1 ;dmm.limit[1].autoclear = dmm.OFF     -- disable auto clearing for limit 1 ;dmm.limit[1].high.value = 5          -- set high limit on 1 to fail if reading                                     -- exceeds 5 volts ;dmm.limit[1].low.value = 3           -- set low limit on 1 to fail if reading                                     -- is less than 3 volts ;dmm.limit[1].enable = dmm.ON         -- enable limit 1 checking for DC volt                                     -- measurements ;dmm.limit[2].autoclear = dmm.OFF     -- disable auto clearing for limit 2 ;dmm.limit[2].high.value = 7          -- set high limit on 2 to fail if reading                                     -- exceeds 7 volts ;dmm.limit[2].low.value = 1           -- set low limit on 2 to fail if reading                                     -- is less than 1 volts ;dmm.limit[2].enable = dmm.ON         -- enable limit 2 checking for DC volt                                     -- measurements ;dmm.measurecount = 50                -- set the measure count to 50 ;LimitBuffer = dmm.makebuffer(100)    -- create a reading buffer that can store                                     -- 100 readings ;dmm.measure(LimitBuffer)             -- take 50 readings and store them in                                     -- LimitBuffer then check if any;                                     -- of the 50 readings were                                     -- outside of the limits ;print(\"limit 1 high fail = \" .. dmm.limit[1].high.fail) ;print(\"limit 1 low fail = \" .. dmm.limit[1].low.fail) ;print(\"limit 2 high fail = \" .. dmm.limit[2].high.fail) ;print(\"limit 2 low fail = \" .. dmm.limit[2].low.fail) ;dmm.limit[1].clear()                 -- clear limit 1 conditions;dmm.limit[2].clear()                 -- clear limit 2 conditions;",
                    "description": "Sample output that shows all readings are within limit values (all readings between 3 and 5 volts):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 high values (a 6 volt reading would cause this condition or a reading greater than 5 but less than 7.):\n--- --limit 1 high fail = 1\n--- --limit 1 low fail = 0\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 0\n--- --\u00a0\n--- --Sample output showing at least one reading failed limit 1 and 2 low values (a 0.5 volts reading would cause this condition or a reading less than 1):\n--- --limit 1 high fail = 0\n--- --limit 1 low fail = 1\n--- --limit 2 high fail = 0\n--- --limit 2 low fail = 1\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "digio.trigger[N].stimulus",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.limit[Y].enable",
                "dmm.limit[Y].high.value",
                "dmm.limit[Y].low.fail"
            ]
        },
        {
            "name": "dmm.linesync",
            "webhelpfile": "16041.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines if line synchronization is used during the measurement.",
            "details": "This attribute is only valid when dmm.func is set to \"commonsideohms\", \"continuity\", \"dccurrent\", \"dcvolts\", \"fourwireohms\", \"temperature\", or \"twowireohms\". All other functions generate an error when written and return nil when queried.When line synchronization is enabled, measurements are initiated at the first positive\u2011going zero crossing of the power line cycle after the trigger.The line sync setting is saved with the dmm.func function setting, so if you use another function, then return to a previous function, the line sync you set previously is retained.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Enable line sync",
                    "enum": "dmm.ON 1|dmm.OFF 0",
                    "type": "dmmlinesyncstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.linesync",
                "dmm.linesync = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"fourwireohms\";dmm.linesync = dmm.ON;",
                    "description": "Enables line sync for the \"fourwireohms\" function.\n"
                }
            ],
            "related_commands": [
                "Line cycle synchronization",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.math.enable",
            "webhelpfile": "16042.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables math operations on measurements for the selected measurement function.",
            "details": "This attribute is not available for \"nofunction\". If you write this attribute for \"nofunction\", an error message is generated.When this command is set to on, the math operation specified by the math format command is performed before completing a measurement.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The math enable setting",
                    "enum": "dmm.OFF 0|dmm.ON 1",
                    "type": "dmmmathenablevalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.math.enable",
                "dmm.math.enable = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.reset(\"active\");dmm.measurecount = 5;MathBuffer = dmm.makebuffer(100);\u00a0;MathBuffer.appendmode = 1;dmm.measure(MathBuffer);dmm.math.format = dmm.MATH_MXB;dmm.math.mxb.mfactor = 1e6;dmm.math.mxb.bfactor = 0;dmm.math.mxb.units = \"[\";dmm.math.enable = dmm.ON;",
                    "description": "Configure the DMM for DC volts.\n--- --Reset DC volts to the default settings.\n--- --Set the measure count to 5.\n--- --Create a reading buffer named MathBuffer that can store 100 readings.\n--- --\u00a0\n--- --Set the buffer to append readings.\n--- --Take 5 readings and store them in MathBuffer with no math operation.\n--- --Enable math operations for mx+b operation, with m set to 1e6 and b set to 0, with units set to micro.\n--- --\u00a0\n"
                }
            ],
            "related_commands": [
                "Math calculations",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.math.format"
            ]
        },
        {
            "name": "dmm.math.format",
            "webhelpfile": "16043.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "2 (dmm.MATH_PERCENT)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies which math operation is performed on measurements when math operations are enabled.",
            "details": "This is not available for \"nofunction\". If this command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.If you set this attribute to dmm.MATH_NONE, math operation is disabled, even if math operation (dmm.math.enable) is enabled.Use a setting of dmm.MATH_MXB to havewhere:If you are using relative offset measurement control (dmm.rel.enable), the relative offset reading is used for X.Use a setting of dmm.MATH_PERCENT to have:where:Use a setting of dmm.MATH_RECIPROCAL for 1/X operation, where X is normal or the measurement value with relative offset applied.The math operation is performed before any of the enabled limit testing.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Math operation to be performed on measurements",
                    "enum": "dmm.MATH_NONE 0|dmm.MATH_MXB 1|dmm.MATH_PERCENT 2|dmm.MATH_RECIPROCAL 3",
                    "type": "dmmmathformatstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.math.format",
                "dmm.math.format = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.math.format = dmm.MATH_RECIPROCAL;dmm.math.enable = dmm.ON;",
                    "description": "Enables the reciprocal operation on measurements.\n"
                }
            ],
            "related_commands": [
                "Math calculations",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.math.enable",
                "dmm.math.percent",
                "dmm.math.mxb.bfactor",
                "dmm.math.mxb.mfactor",
                "dmm.rel.enable"
            ]
        },
        {
            "name": "dmm.math.mxb.bfactor",
            "webhelpfile": "16044.htm",
            "signature": "",
            "command_return": "offset",
            "type": "Attribute (RW)\n",
            "default_value": "0.000000e+00\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the offset, b, for the y = mx + b operation.",
            "details": "This is not available for \"nofunction\". If command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.This attribute specifies the offset (b) for an mx + b operation.The mx + b math operation lets you manipulate normal display readings (x) mathematically based on the calculation:Where:",
            "param_info": [
                {
                    "name": "offset",
                    "description": "The valid range is -4294967295 to +4294967295",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "offset = dmm.math.mxb.bfactor",
                "dmm.math.mxb.bfactor = offset"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.math.mxb.bfactor = 50;",
                    "description": "Sets the offset for mx +b operation to 50.\n"
                }
            ],
            "related_commands": [
                "Math calculations",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.math.format",
                "dmm.math.mxb.mfactor"
            ]
        },
        {
            "name": "dmm.math.mxb.mfactor",
            "webhelpfile": "16045.htm",
            "signature": "",
            "command_return": "scaleFactor",
            "type": "Attribute (RW)\n",
            "default_value": "1.000000E+00\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the scale factor, m, for the y = mx + b math operation.",
            "details": "This is not available for \"nofunction\". If command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.This command sets the scale factor (m) for an mx + b operation for the selected measurement function.The mx + b math operation lets you manipulate normal display readings (x) mathematically according to the following calculation:Where: ",
            "param_info": [
                {
                    "name": "scaleFactor",
                    "description": "The scale factor; valid range is -4294967295 to +4294967295",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scaleFactor = dmm.math.mxb.mfactor",
                "dmm.math.mxb.mfactor = scaleFactor"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.math.mxb.mfactor = 0.80;",
                    "description": "Sets the scale factor for the mx +b operation to 0.80.\n"
                }
            ],
            "related_commands": [
                "Math calculations",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.math.format",
                "dmm.math.mxb.bfactor"
            ]
        },
        {
            "name": "dmm.math.mxb.units",
            "webhelpfile": "16046.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "X\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the unit character for the y = mX + b operation.",
            "details": "This attribute is not available for the \"nofunction\" selection. If the command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.This attribute represents the unit character to use when the math format is set for mx + b (dmm.math.format = dmm.MATH_MXB).",
            "param_info": [
                {
                    "name": "value",
                    "description": "The unit character for the y = mx + b operation. Valid values are",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.math.mxb.units",
                "dmm.math.mxb.units = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.math.mxb.units = \"Q\";",
                    "description": "Sets the units for the mX +b operation to \"Q\".\n"
                }
            ],
            "related_commands": [
                "Math calculations",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.math.format"
            ]
        },
        {
            "name": "dmm.math.percent",
            "webhelpfile": "16047.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.000000E+00\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the reference constant that is used when math operations are set to percent.",
            "details": "This is not available for \"nofunction\". If command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.This attribute represents the constant to use for percent when dmm.math.format = dmm.MATH_PERCENT.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The constant for the percent operation; the range is -4294967295 to +4294967295",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.math.percent",
                "dmm.math.percent = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.math.percent = 1250;",
                    "description": "Set constant for percent operation to 1250.\n"
                },
                {
                    "example": "dmm.func = \"dcvolts\";dmm.reset(\"active\");dmm.math.format = dmm.MATH_PERCENT;dmm.measurecount = 1;dmm.math.percent = dmm.measure();dmm.math.enable = dmm.ON  ;dmm.measurecount = 5;MathBuffer = dmm.makebuffer(100);dmm.measure(MathBuffer);printbuffer(1, MathBuffer.n, MathBuffer) ;dmm.measurecount = 1;for x = 1, 3 do ;    print(dmm.measure());end;\u00a0;",
                    "description": "Configure the DMM for dc voltage measurement and reset the dc voltage function to the default settings.\n--- --\u00a0\n--- --Set math format to percent. \n--- --Acquire 1 reading to use as the relative percent value.\n--- --Take 5 readings with percent math enabled and store them in a buffer called MathBuffer that can store 100 readings.\n--- --\u00a0\n--- --Take three additional readings without using the reading buffer.\n--- --\u00a0\n--- --Sample output assuming no load was connected to DMM:\n--- --2.717115286e+01, 1.259150986e+01, 1.259150986e+01, 9.277954635e+00, 3.313555227e+01\n--- --\u00a0\n--- --1.292338066e+01\n--- --2.452080209e+01\n--- --1.557421984e+01\n"
                }
            ],
            "related_commands": [
                "Math calculations",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.math.format"
            ]
        },
        {
            "name": "dmm.makebuffer()",
            "webhelpfile": "16048.htm",
            "signature": "dmm.makebuffer(bufferSize)",
            "command_return": "bufferVar",
            "type": "Function\n",
            "default_value": "None\n",
            "tsp_link": "Yes\n",
            "description": "This function creates a user buffer for storing readings. Reading buffers are allocated dynamically.",
            "details": "To be able to store readings, a reading buffer needs to be created. Once created, the reading buffer can be used to store readings from dmm.measure() command and from scanning (scan.execute() or scan.background())To delete a buffer, set bufferVar to nil.Once a buffer is created, the attributes that can be accessed are:The following buffer bits indicate buffer statuses:To see readings in buffer:Where x and y represent the reading numbers to be returned.To see readings, channels, and units:Where x and y represent reading numbers to be returned.To see timestamps that are in buffer:Where x and y represent readings and timestamps for elements x to y.To see seconds, fractional seconds, and relative timestamps:",
            "param_info": [
                {
                    "name": "bufferVar",
                    "description": "The variable name for the buffer being created",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "bufferSize",
                    "description": "Maximum number of readings that the buffer can store",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "bufferVar = dmm.makebuffer(bufferSize)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "bufferVar = dmm.makebuffer(300);",
                    "description": "Creates a user reading buffer named bufferVar with a capacity of 300.\n"
                },
                {
                    "example": "dmm.measurecount = 10 ;dmm.measure(bufferVar2);printbuffer(1, bufferVar2.n, bufferVar2);bufferVar2 = nil;\u00a0;\u00a0;\u00a0;",
                    "description": "Take ten measurements on the active function and store them in the reading buffer bufferVar2.\n--- --View those ten readings.\n--- --Delete bufferVar2.\n--- --Sample output (actual output depends on how the active function is configured and what you are measuring):\n--- --1.134154698e+01, 1.132708486e+01, 1.134213865e+01, 1.134037749e+01, 1.132735758e+01, 1.134099844e+01, 1.133705087e+01, 1.132571507e+01, 1.134000616e+01, 1.133721111e+01\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "dmm.measure() ",
                "printbuffer()",
                "scan.background()",
                "scan.execute()"
            ]
        },
        {
            "name": "dmm.measure()",
            "webhelpfile": "16049.htm",
            "signature": "dmm.measure(bufferVar)",
            "command_return": "reading",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the last reading of the measurement process without using the trigger model.",
            "details": "This is not available for \"nofunction\". If the command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.When you use a reading buffer with a command or action that makes multiple readings, all readings are available in the reading buffer. However, only the last reading is returned as a reading with the command.If you define a specific reading buffer, the reading buffer must exist before you make the measurement.You can also use a reading buffer to store additional information that is acquired while making a measurement.The dmm.measurecount attribute determines how many measurements are performed. When you use a buffer, it also determines if the reading buffer has enough room to store the requested readings. The amount of room is based on readings already stored in the buffer (bufferVar.n), the capacity of the buffer (bufferVar.capacity), and the append mode of the reading buffer (bufferVar.appendmode). If the append mode is set to 0, any stored readings in the buffer are cleared before new ones are stored. If append mode is set to 1, any stored readings remain in the buffer and new ones are added to the buffer after the stored ones.",
            "param_info": [
                {
                    "name": "reading",
                    "description": "The last reading of the measurement process",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "bufferVar",
                    "description": "A previously created reading buffer where all readings are stored",
                    "enum": "",
                    "type": "bufferMethods",
                    "range": ""
                }
            ],
            "usage": [
                "reading = dmm.measure()",
                "reading = dmm.measure(bufferVar)"
            ],
            "overloads": [
                "reading = dmm.measure()"
            ],
            "examples": [
                {
                    "example": "DCVBuffer = dmm.makebuffer(100);dmm.func = \"dcvolts\";dmm.measurecount = 100;dmm.measure(DCVBuffer);",
                    "description": "Performs 100 DC voltage measurements and stores them in a buffer called DCVBuffer.\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "bufferVar.appendmode",
                "bufferVar.capacity",
                "bufferVar.n",
                "dmm.makebuffer()",
                "dmm.measurecount",
                "dmm.measurewithtime()"
            ]
        },
        {
            "name": "dmm.measurecount",
            "webhelpfile": "16050.htm",
            "signature": "",
            "command_return": "count",
            "type": "Attribute (RW)\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the number of measurements to take when a measurement is requested by a DMM measure command.",
            "details": "This attribute controls the number of measurements taken any time a measurement is requested (through dmm.measure, dmm.measurewithtime, or the front panel MEASURE menu option). When using a reading buffer with a measure command, the count also controls the number of readings to be stored.It has no effect on the trigger model, and the trigger model does not affect this setting.This setting is applied to all functions (the setting is not related to a specific function).",
            "param_info": [
                {
                    "name": "count",
                    "description": "The number of measurements to take when a DMM measure function is used (maximum 450,000)",
                    "enum": "",
                    "type": "any",
                    "range": "(maximum 450,000)"
                }
            ],
            "usage": [
                "count = dmm.measurecount",
                "dmm.measurecount = count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "DMMbuffer = dmm.makebuffer(500);dmm.measure(bufferVar);dmm.measurecount = 50;",
                    "description": "Create a reading buffer called DMMbuffer that can store 500 readings.\n--- --Store 50 readings in DMMbuffer.\n--- --Set the measure count of the DMM to\u00a050.\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "dmm.autodelay",
                "dmm.makebuffer()",
                "dmm.measure()",
                "dmm.measurewithtime()"
            ]
        },
        {
            "name": "dmm.measurewithtime()",
            "webhelpfile": "16051.htm",
            "signature": "dmm.measurewithtime(bufferVar)",
            "command_return": "reading, seconds, fractional",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the last actual measurement and time information in UTC format without using the trigger model. You can also use a reading buffer to store additional information that is acquired while making a measurement.",
            "details": "This is not available for \"nofunction\". If the command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.When a reading buffer is used with a command or action that involves taking multiple readings, such as dmm.measure or scanning, all readings are available in the reading buffer. However, only the last reading and time information (seconds and fractional seconds) is returned as a reading with the command.You can also use a reading buffer to store additional information that is acquired while making a measurement.The dmm.measurecount attribute determines how many measurements are performed. When you use a buffer, it also determines if the reading buffer has enough room to store the requested readings. The amount of room is based on readings already stored in the buffer (bufferVar.n), the capacity of the buffer (bufferVar.capacity), and the append mode of the reading buffer (bufferVar.appendmode). If the append mode is set to 0, any stored readings in the buffer are cleared before new ones are stored. If append mode is set to 1, any stored readings remain in the buffer and new ones are added to the buffer after the stored ones.",
            "param_info": [
                {
                    "name": "reading",
                    "description": "The last reading of the measurement process",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "seconds",
                    "description": "Seconds in UTC format",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "fractional",
                    "description": "Fractional seconds",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "bufferVar",
                    "description": "A previously created reading buffer variable in which all readings are stored",
                    "enum": "",
                    "type": "bufferMethods",
                    "range": ""
                }
            ],
            "usage": [
                "reading, seconds, fractional = dmm.measurewithtime()",
                "reading, seconds, fractional = dmm.measurewithtime(bufferVar)"
            ],
            "overloads": [
                "reading, seconds, fractional = dmm.measurewithtime()"
            ],
            "examples": [
                {
                    "example": "DCVbuffer = dmm.makebuffer(100);dmm.func = \"dcvolts\";dmm.measurecount = 100;reading, seconds, fractional = dmm.measurewithtime(DCVbuffer);print(reading, seconds, fractional);",
                    "description": "Create a reading buffer.\n--- --Perform 100 DC voltage measurements.\n--- --Store the measurements in a buffer called DCVbuffer.\n--- --Print the last measurement and time information in UTC format, which will look similar to:\n--- ---1.064005867e-02   1.779155900e+07\u00a0\u00a0\u00a01.245658350e-01\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "dmm.makebuffer()",
                "dmm.measure()",
                "dmm.measurecount"
            ]
        },
        {
            "name": "dmm.nplc",
            "webhelpfile": "16052.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.000000E+000\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the integration rate in line cycles for the DMM for the function selected by dmm.func.",
            "details": "This attribute is not applicable for \"frequency\", \"period\", and \"nofunction\". If you query this attribute for one of these functions, nil is returned. Note that \"continuity\" is fixed at 6.000000E-003 and cannot be changed.The setting for NPLC may be adjusted based on what the DMM supports. Therefore, after setting the NPLC, query the value to see if it was adjusted.An error is generated if the command is used when dmm.func is set to \"frequency\", \"period\", \"continuity\", or \"nofunction\".The NPLC setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the NPLC setting you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The integration rate in line cycles",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.nplc",
                "dmm.nplc = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"twowireohms\";dmm.nplc = 0.5;dmm.func = \"dcvolts\";dmm.nplc = 0.1;",
                    "description": "Set the NPLC for 2-wire ohms to 0.5, then set the NPLC for DC volts to 0.1.\n"
                }
            ],
            "related_commands": [
                "dmm.aperture",
                "dmm.autozero",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.offsetcompensation",
            "webhelpfile": "16053.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF) for \"commonsideohms\" and \"fourwireohms\"\n1 (dmm.ON) for \"temperature\"\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the offset compensation setting for the DMM for the function selected by dmm.func.",
            "details": "The command applies when dmm.func is set to \"fourwireohms\", \"commonsideohms\" or \"temperature\".When dmm.func = \"temperature\", this attribute applies only when the transducer type is 3- or 4-wire RTD. Set this command as you would for 4-wire ohm measurements.This command is automatically set to dmm.ON when dmm.drycircuit is set to dmm.ON and dmm.func = \"fourwireohms\" or \"commonsideohms\".The offset compensation setting is saved with the dmm.func function setting, so if you use another function, then return to  \"fourwireohms\", \"commonsideohms\" or \"temperature\", the offset compensation setting you set previously is retained.If you query this attribute and the function is not \"fourwireohms\", \"commonsideohms\", or \"temperature\", nil is returned.",
            "param_info": [
                {
                    "name": "state",
                    "description": "The offset compensation setting",
                    "enum": "dmm.ON 1|dmm.OFF 0",
                    "type": "dmmoffsetcompensationstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.offsetcompensation",
                "dmm.offsetcompensation = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"fourwireohms\";dmm.offsetcompensation = dmm.ON;",
                    "description": "Enable offset compensation for 4-wire ohms.\n"
                },
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THREERTD;dmm.offsetcompensation = dmm.OFF;",
                    "description": "Disable offset compensation for 3-wire RTD temperature measurements.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.open()",
            "webhelpfile": "16054.htm",
            "signature": "dmm.open(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "Opens the specified channel or channel pattern.",
            "details": "This command allows you to separate the opening and closing of channels and analog backplane relays when measuring. You can execute any number of commands between the open and close commands to meet your application needs.The configuration (dmm.getconfig()) associated with the specified channel dictates whether a paired channel is open or not. For channel patterns, the channels associated with it are opened. A channel pattern includes a paired channel for multi-wire measurement if a channel is configured that way when the pattern is created (see commands channel.setpole() and channel.pattern.setimage()).The configuration (dmm.getconfig()) dictates whether analog backplane relays 1 and 2 are opened and if a paired channel is opened. The dmm.open() function does not use the analog backplane relays specified by the channel.setbackplane() function or pole settings set by the channel.setpole() function.An error is generated and the channels do not open if:",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the channel or channel pattern to open",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.open(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset()                                                         ;channel.setpole(\"slot2\" , 4)  ;channel.pattern.setimage(\"2005, 2911, 2922\", \"Chan5_4W\")  ;dmm.setconfig(\"Chan5_4W\", \"fourwireohms\")  ;dmm.open(\"Chan5_4W\")  ;print(channel.pattern.getimage(\"Chan5_4W\"));",
                    "description": "Assume a Model 3721 is installed in slot 2.\n--- --Reset the instrument.\n--- --Configure the slot 2 channels for 4-pole operation.\n--- --Create a pattern called Chan5_4W.\n--- --Assign 4-wire ohms configuration to the Chan5_4W pattern.\n--- --Open the channels associated with Chan5_4W and display image of the Chan5_4W.\n--- --Output:\n--- --2005(2025),2911,2922\n"
                },
                {
                    "example": "dmm.setconfig(\"slot3\", \"dcvolts\") ;dmm.close(\"3030\") ;print(channel.getclose(\"slot3\")) ;dmm.open(\"3030\") ;print(channel.getclose(\"slot3\")) ;dmm.close(\"3031\") ;print(channel.getclose(\"slot3\")) ;dmm.open(\"3031\") ;print(channel.getclose(\"slot3\"));",
                    "description": "Assume a 3720 installed in slot 3.\n--- --Set the configuration for DC volts.\n--- --Close and open the channels.\n--- --Output:\n--- --3030;3911\n--- --nil\n--- --3031;3921\n--- --nil\n"
                }
            ],
            "related_commands": [
                "channel.getclose()",
                "channel.pattern.getimage()",
                "channel.pattern.setimage()",
                "channel.setbackplane()",
                "channel.setpole()",
                "dmm.close()",
                "dmm.getconfig()"
            ]
        },
        {
            "name": "dmm.opendetector",
            "webhelpfile": "16055.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF) for \"commonsideohms\"\n1 (dmm.ON) for \"fourwireohms\" and \"temperature\"\n",
            "tsp_link": "Yes\n",
            "description": "This attributes determines if the detection of open leads is enabled or disabled.",
            "details": "The command applies when dmm.func is set to \"fourwireohms\", \"commonsideohms\", or \"temperature\".When dmm.func is set to temperature, the open detector setting is only used when the transducer type is thermocouple. For all other transducer types, it is set, but not used until the transducer type is set to thermocouple.The open detector setting is saved with the dmm.func function setting, so if you use another function, then return to \"fourwireohms\", \"commonsideohms\", or \"temperature\", the open detector setting you set previously is retained.An error is generated if dmm.func is set to any function other than \"fourwireohms\", \"commonsideohms\", or \"temperature\". If you query the setting for any other function, nil is returned.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Disable open lead detector",
                    "enum": "dmm.OFF 0|dmm.ON 1",
                    "type": "dmmopendetectorstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.opendetector",
                "dmm.opendetector = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THERMOCOUPLE;dmm.opendetector = dmm.ON;",
                    "description": "Enable the thermocouple open detector.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.range",
            "webhelpfile": "16056.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "See Details\n",
            "tsp_link": "Yes\n",
            "description": "Indicates the range of DMM for the selected function.",
            "details": "Set this value to the expected measurement value and the instrument will select the range appropriate to measure that value. Setting the range with this attribute will automatically disable the autorange setting (dmm.autorange command).The instrument selects the range to best match the expected measure value for the functions, as shown below.The range setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the range settings you set previously are retained.If you query the range when the selected function does not have a range associated with it, nil is returned.An error is generated if:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The range for the function selected by dmm.func",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.range",
                "dmm.range = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"dcvolts\";dmm.range = 5;dmm.func = \"twowireohms\";dmm.range = 35000;print(dmm.range);",
                    "description": "Set the range for DC volts to 10. Select a range on 2-wire\u00a0ohms suitable for measuring 35000. View the selected range.\n--- --Output:\n--- --1.000000000e+05\n"
                }
            ],
            "related_commands": [
                "dmm.autorange",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.reset()"
            ]
        },
        {
            "name": "dmm.refjunction",
            "webhelpfile": "16057.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "1 (dmm.REF_JUNCTION_INTERNAL) for \"temperature\"\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the type of the thermocouple reference junction.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried.This attribute only applies when the transducer type is set to thermocouple. For all other transducer types, the reference junction may be set, but it is not used until the transducer type is set to thermocouple.The reference junction setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the reference junction settings you set previously are retained.",
            "param_info": [
                {
                    "name": "state",
                    "description": "The reference junction type",
                    "enum": "dmm.REF_JUNCTION_SIMULATED 0|dmm.REF_JUNCTION_INTERNAL 1|dmm.REF_JUNCTION_EXTERNAL 2",
                    "type": "dmmrefjunctionstate",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.refjunction",
                "dmm.refjunction = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THERMOCOUPLE;dmm.refjunction = dmm.REF_JUNCTION_SIMULATED;",
                    "description": "Enables the simulated thermocouple reference junction.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.transducer"
            ]
        },
        {
            "name": "dmm.rel.acquire()",
            "webhelpfile": "16058.htm",
            "signature": "dmm.rel.acquire()",
            "command_return": "relativeValue",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function acquires a measurement and stores it as the relative offset value.",
            "details": "This attribute is not applicable for \"continuity\" and \"nofunction\".This command triggers the instrument to make a new measurement for the selected function. This measurement is then stored as the new relative offset level.When you send this command, the instrument does not apply any math, limit test, or filter settings to the measurement, even if they are set. It is a measurement that is made as if these settings are disabled.If an error event occurs during the measurement, nil is returned and the relative offset level remains at the last valid setting.You must change to the function for which you want to acquire a value before sending this command.The instrument must have relative offset enabled to use the acquired relative offset value.After executing this command, use the dmm.rel.level attribute to see the last relative level value that was acquired or set by the user. If error occurs during the reading, nil is returned.An error is generated if:When an error occurs, the relative offset level setting maintains the last valid setting.",
            "param_info": [
                {
                    "name": "relativeValue",
                    "description": "The internal measurement acquired for the relative offset level value",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "relativeValue = dmm.rel.acquire()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";rel_value = dmm.rel.acquire();",
                    "description": "Acquires a relative offset level value for temperature.\n"
                }
            ],
            "related_commands": [
                "dmm.func",
                "dmm.rel.level"
            ]
        },
        {
            "name": "dmm.rel.enable",
            "webhelpfile": "16059.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "Enables or disables relative measurement control for the function selected by dmm.func.",
            "details": "This attribute is not available if dmm.func is set to \"continuity\" or \"nofunction\". If you query this attribute when either of these functions is selected, nil is returned.When relative measurements are enabled, all subsequent measured readings are offset by the relative offset specified by dmm.rel.level. Each returned measured relative reading will be the result of the following calculation:Relative reading = Actual measured reading \u2013 Relative offset valueIf you change functions with dmm.func, the relative enable setting changes to the enable setting for that function.The relative enable setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the relative enable settings you set previously are retained.An error is generated if:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The setting",
                    "enum": "dmm.ON 1|dmm.OFF 0",
                    "type": "dmmrelenablevalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.rel.enable",
                "dmm.rel.enable = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"accurrent\";dmm.rel.acquire();dmm.rel.enable = dmm.ON;",
                    "description": "Enables the relative measurements for AC current and uses the acquire command to set the relative level attribute.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.rel.acquire()",
                "dmm.rel.level"
            ]
        },
        {
            "name": "dmm.rel.level",
            "webhelpfile": "16060.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0.000000E+000\n",
            "tsp_link": "Yes\n",
            "description": "The offset value for relative measurements for the function selected by dmm.func.",
            "details": "This attribute is not available if dmm.func is set to \"continuity\" or \"nofunction\". If you query this attribute when either of these functions is selected, nil is returned.When relative measurements are enabled (as set by dmm.rel.enable), all subsequent measured readings are offset by the specified relative offset value. Specifically, each returned measured relative reading is the result of the following calculation:Relative reading = Actual measured reading \u2013 Relative offset valueChanging functions with dmm.func reflects the relative level offset setting for that function.The relative offset level setting is saved with the dmm.func function setting, so if you use another function, then return to the previous function, the relative offset level settings you set previously are retained.An error is generated:",
            "param_info": [
                {
                    "name": "value",
                    "description": "The relative offset level setting",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.rel.level",
                "dmm.rel.level = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"accurrent\";dmm.rel.level = dmm.measure();rel_value = dmm.measure();dmm.rel.level = rel_value;dmm.func = \"temperature\";rel_value = dmm.rel.acquire();",
                    "description": "Perform an AC current measurement and use it as the relative offset value.\n--- --Take a measurement and store it in the variable rel_value.\n--- --Use the rel_value to set the relative level attribute.\n--- --Acquire a relative offset level value for temperature.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.measure()",
                "dmm.rel.acquire()",
                "dmm.rel.enable"
            ]
        },
        {
            "name": "dmm.reset()",
            "webhelpfile": "16061.htm",
            "signature": "dmm.reset(scope)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "Resets the DMM functions and attributes in the instrument, as indicated by the parameter.",
            "details": "When the scope is set to active, this command resets the DMM attributes for the active function to factory default values. The settings for other functions are unchanged.When the scope is set to all, this command resets the DMM functions and attributes to factory default settings.This function does not affect the DMM configurations (dmm.setconfig() and dmm.getconfig()).The factory default settings are:",
            "param_info": [
                {
                    "name": "scope",
                    "description": "A string equaling \"active\" to set the active function only to factory default settings or \"all\" to set all functions back to factory default settings",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.reset(scope)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.reset(\"active\");print(dmm.func);dmm.reset(\"all\");print(dmm.func);",
                    "description": "Set the DMM function to temperature.\n--- --Perform a reset on temperature only.\n--- --Check the function after resetting only temperature.\n--- --Perform a reset on all DMM functions.\n--- --Check the function after resetting all DMM functions.\n--- --Output:\n--- --temperature\n--- --dcvolts\n"
                }
            ],
            "related_commands": [
                "dmm.func",
                "dmm.getconfig()",
                "dmm.setconfig()",
                "reset()"
            ]
        },
        {
            "name": "dmm.rtdalpha",
            "webhelpfile": "16062.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "3.850550E-03\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the alpha value of a user-defined RTD.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried.This setting only applies when the transducer type is set to 3 or 4-wire RTD. For other transducer types, the setting is set but not used until the transducer type is set to an RTD type.The RTD alpha setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the RTD alpha setting you set previously is retained.An error is generated if the value is out of range.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The RTD alpha value; the range is 0 to 0.01",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.rtdalpha",
                "dmm.rtdalpha = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THREERTD;dmm.rtdalpha = 0.005;dmm.transducer = dmm.TEMP_FOURRTD;dmm.rtdalpha = 0.007;dmm.transducer = dmm.TEMP_THREERTD;print(dmm.rtdalpha);",
                    "description": "Set an alpha constant for RTD to 0.005 for 3-wire RTD.\n--- --Change to 4-wire RTD and change the alpha constant to 0.007.\n--- --Switch back to 3-wire RTD. The value has been updated to 0.007.\n--- --Output:\n--- --7.000000000e-03\n"
                },
                {
                    "example": "dmm.func = \"temperature\" ;dmm.transducer = dmm.TEMP_THREERTD ;dmm.rtdalpha = 0.005 ;dmm.configure.set(\"RTD_3wire\");dmm.transducer = dmm.TEMP_FOURRTD ;dmm.rtdalpha = 0.007 ;dmm.configure.set(\"RTD_4wire\");dmm.configure.recall(\"RTD_3wire\");print(dmm.transducer, dmm.rtdalpha) ;dmm.configure.recall(\"RTD_4wire\");print(dmm.transducer, dmm.rtdalpha);",
                    "description": "This example sets unique alpha constants for 3-wire and 4-wire RTDs by creating two DMM configurations with the settings.\n--- --\u00a0\n--- --Output:\n--- --3.000000000e+00\t5.000000000e-03\n--- --4.000000000e+00\t7.000000000e-03\n--- --\u00a0\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.rtdbeta",
                "dmm.rtddelta",
                "dmm.rtdzero",
                "dmm.transducer"
            ]
        },
        {
            "name": "dmm.rtdbeta",
            "webhelpfile": "16063.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.086300E-01\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the beta value of a user-defined RTD.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried.This setting only applies when the transducer type is set to 3 or 4-wire RTD. For other transducer types, the setting is set but not used until the transducer type is set to an RTD type.The RTD beta setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the RTD beta setting you set previously is retained.An error is generated if the value is out of range.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The RTD beta value",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.rtdbeta",
                "dmm.rtdbeta = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THREERTD;dmm.rtdbeta = 0.3;dmm.transducer = dmm.TEMP_FOURRTD;dmm.rtdbeta = 0.5;dmm.transducer = dmm.TEMP_THREERTD;print(dmm.rtdbeta);",
                    "description": "Set a beta constant for RTD to 0.3 for 3-wire RTD.\n--- --Change to 4-wire RTD.\n--- --Change the beta constant to 0.5.\n--- --Switch back to 3-wire RTD. The value is 0.5.\n--- --Output:\n--- --5.000000000e-01\n"
                },
                {
                    "example": "dmm.func = \"temperature\" ;dmm.transducer = dmm.TEMP_THREERTD ;dmm.rtdbeta = 0.3 ;dmm.configure.set(\"RTD_3wire\");dmm.transducer = dmm.TEMP_FOURRTD ;dmm.rtdbeta = 0.5 ;dmm.configure.set(\"RTD_4wire\");dmm.configure.recall(\"RTD_3wire\");print(dmm.transducer, dmm.rtdbeta) ;dmm.configure.recall(\"RTD_4wire\");print(dmm.transducer, dmm.rtdbeta);",
                    "description": "This example sets unique beta constants for 3-wire and 4-wire RTDs by creating two DMM configurations with the settings.\n--- --Output:\n--- --3.000000000e+00\t3.000000000e-01\n--- --4.000000000e+00\t5.000000000e-01\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.rtdalpha",
                "dmm.rtddelta",
                "dmm.rtdzero"
            ]
        },
        {
            "name": "dmm.rtddelta",
            "webhelpfile": "16064.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.499900E+00\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the delta value of a user-defined RTD.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried.This setting only applies when the transducer type is set to 3 or 4-wire RTD. For other transducer types, the setting is set but not used until the transducer type is set to an RTD type.The RTD alpha setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the RTD alpha setting you set previously is retained.An error is generated if the value is out of range.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The user type RTD delta value; valid range is 0 to 5",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.rtddelta ",
                "dmm.rtddelta = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THREERTD;dmm.rtddelta = 3;dmm.transducer = dmm.TEMP_FOURRTD;dmm.rtddelta = 5;dmm.transducer = dmm.TEMP_THREERTD;print(dmm.rtddelta);",
                    "description": "Set a delta constant for RTD to 3 for 3-wire RTD.\n--- --Change to 4-wire RTD.\n--- --Change the delta constant to 5.\n--- --Switch back to 3-wire RTD. The value is 5.\n--- --Output:\n--- --5.000000000e+00\n"
                },
                {
                    "example": "dmm.func = \"temperature\" ;dmm.transducer = dmm.TEMP_THREERTD ;dmm.rtddelta = 3 ;dmm.configure.set(\"RTD_3wire\");dmm.transducer = dmm.TEMP_FOURRTD ;dmm.rtddelta = 5 ;dmm.configure.set(\"RTD_4wire\");dmm.configure.recall(\"RTD_3wire\");print(dmm.transducer, dmm.rtddelta) ;dmm.configure.recall(\"RTD_4wire\");print(dmm.transducer, dmm.rtddelta);",
                    "description": "This example sets unique delta constants for 3-wire and 4-wire RTDs by creating two DMM configurations.\n--- --Output:\n--- --3.000000000e+00\t3.000000000e+00\n--- --4.000000000e+00\t5.000000000e+00\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.rtdalpha",
                "dmm.rtdbeta",
                "dmm.rtdzero"
            ]
        },
        {
            "name": "dmm.rtdzero",
            "webhelpfile": "16065.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.000000E+02\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the zero value of a user-defined RTD.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other configurations generate an error and return nil when queried.This setting only applies when the transducer type is set to 3 or 4-wire RTD. For other transducer types, the setting is set but not used until the transducer type is set to an RTD type.The RTD zero setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the RTD zero settings you set previously are retained.An error is generated if the value is out of range.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The zero value of the RTD",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.rtdzero",
                "dmm.rtdzero = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THREERTD;dmm.rtdzero = 300;dmm.transducer = dmm.TEMP_FOURRTD;dmm.rtdzero = 500;dmm.transducer = dmm.TEMP_THREERTD;print(dmm.rtdzero);",
                    "description": "Set a zero constant for RTD to 300 for 3-wire RTD.\n--- --Change to 4-wire RTD.\n--- --Change the zero constant to 500.\n--- --Switch back to 3-wire RTD. The value is 500.\n--- --Output:\n--- --5.000000000e+02\n"
                },
                {
                    "example": "dmm.func = \"temperature\" ;dmm.transducer = dmm.TEMP_THREERTD ;dmm.rtdzero = 300;dmm.configure.set(\"RTD_3wire\");dmm.transducer = dmm.TEMP_FOURRTD ;dmm.rtdzero = 500;dmm.configure.set(\"RTD_4wire\");dmm.configure.recall(\"RTD_3wire\");print(dmm.transducer, dmm.rtdzero) ;dmm.configure.recall(\"RTD_4wire\");print(dmm.transducer, dmm.rtdzero);",
                    "description": "This example sets unique zero constants for 3-wire and 4-wire RTDs by creating two DMM configurations.\n--- --Output:\n--- --3.000000000e+00\t3.000000000e+02\n--- --4.000000000e+00\t5.000000000e+02\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.rtdalpha",
                "dmm.rtdbeta",
                "dmm.rtddelta"
            ]
        },
        {
            "name": "dmm.savebuffer()",
            "webhelpfile": "16066.htm",
            "signature": "dmm.savebuffer(bufferVar, fileName, timeFormat)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "Saves data from the specified reading buffer to a USB flash drive using the specified filename.",
            "details": "The file name must specify the full path (including /usb1/). If included, the file extension must be set to .csv. If no file extension is specified, .csv is added.For options that save more than one item of time information, each item is comma-delimited. For example, the default format is date, time, and fractional seconds for each reading.You use dmm.makebuffer() to create a buffer.Examples of valid destination file names:Invalid destination filename examples:\u2014 The period is not followed by the csv extension.\u2014 The only allowed extension is .csv. If .csv is not assigned, it is automatically added.\u2014 Two periods in the file name (myData_txt.csv would be correct).An error is generated if:",
            "param_info": [
                {
                    "name": "bufferVar",
                    "description": "A string that specifies the name of the DMM reading buffer that was created by dmm.makebuffer()",
                    "enum": "",
                    "type": "string",
                    "range": "()"
                },
                {
                    "name": "fileName",
                    "description": "A string that indicates the name of the file on the USB flash drive in which to save the reading buffer",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "timeFormat",
                    "description": "How date and time information from the buffer is saved in the file on the USB flash drive; the values are",
                    "enum": "buffer.SAVE_FORMAT_TIME nil|buffer.SAVE_RELATIVE_TIME nil|buffer.SAVE_RAW_TIME nil|buffer.SAVE_TIMESTAMP_TIME nil",
                    "type": "dmmsavebuffertimeFormat",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.savebuffer(bufferVar, fileName)",
                "dmm.savebuffer(bufferVar, fileName, timeFormat)"
            ],
            "overloads": [
                "dmm.savebuffer(bufferVar, fileName)"
            ],
            "examples": [
                {
                    "example": "dmm.savebuffer(\"bufferVar\", \"/usb1/myData.csv\");",
                    "description": "Saves readings from a DMM buffer named bufferVar with default time information to a file named myData.csv on the USB flash drive.\n"
                }
            ],
            "related_commands": [
                "dmm.appendbuffer()",
                "dmm.makebuffer()"
            ]
        },
        {
            "name": "dmm.setconfig()",
            "webhelpfile": "16067.htm",
            "signature": "dmm.setconfig(channelList, dmmConfiguration)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\"nofunction\"\n",
            "tsp_link": "Yes\n",
            "description": "Associates a DMM configuration with items specified in parameter channel list.",
            "details": "dmmConfiguration can be the name of a configuration that was saved with dmm.configure.set(). If you use a saved configuration, the function of the configuration and the supporting DMM attributes for that function are associated with the channelList parameter items. These supporting DMM attributes may have user-defined or default values associated with them.dmmConfiguration can also be a DMM configuration name that matches the DMM function name. If you use a default DMM configuration name, be aware that the supporting function attribute settings are the default values and not user-specified (as they may be in a user-defined saved configuration). The DMM function names are:To use a channel with the dmm.close() function, dmm.setconfig() cannot be set to \"nofunction\".The configuration being assigned determines whether analog backplane relay 1 or 2 get used, based on the function associated with the configuration when being assigned to a channel. For channel patterns, the pattern image must include the analog backplane relays and the channels. This command has no effect on the poles setting for a channel (channel.setpole()) or analog backplane relays specified by channel.setbackplane() function.An error is generated if:Once an error is detected, the command stops processing and no channels or channel patterns are modified.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the channels and channel patterns to change",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "dmmConfiguration",
                    "description": "A string with the name of the DMM configuration that will be assigned to items in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "dmm.setconfig(channelList, dmmConfiguration)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.setconfig(\"1001:3100\", \"myDcv\");",
                    "description": "Assigns myDcv to all the channels on slots\u00a01 and 2 and channels 1 to 100 on slot 3.\n"
                }
            ],
            "related_commands": [
                "channel.setbackplane()",
                "channel.setpole()",
                "dmm.close()",
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.getconfig()"
            ]
        },
        {
            "name": "dmm.simreftemperature",
            "webhelpfile": "16068.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "Celsius: 23Kelvin: 296.15Fahrenheit: 73.4\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the simulated reference temperature of the thermocouple reference junction.",
            "details": "This attribute applies to the temperature function when the transducer type is set to thermocouple and the reference junction is set to simulated. It allows you to set the simulated reference temperature value.This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried.The simulated reference temperature is only used when the transducer type is thermocouple, as set by dmm.transducer. For all other transducer types, the value is set but not used until the transducer type is set for thermocouple.The simulated reference temperature setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\" with the transducer type set to thermocouple, the simulated reference temperature setting you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The simulated reference temperature",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.simreftemperature",
                "dmm.simreftemperature = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THERMOCOUPLE;dmm.units = dmm.UNITS_CELSIUS;dmm.simreftemperature = 30;",
                    "description": "Sets 30 degrees Celsius as the simulated reference temperature for thermocouples.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.transducer",
                "dmm.units"
            ]
        },
        {
            "name": "dmm.thermistor",
            "webhelpfile": "16069.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "5000\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the type of thermistor.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried. If you use a parameter outside of the ranges listed in the usage table, a parameter out of range error message is generated.The thermistor attribute is only used when the transducer type is set for thermistor. For all other transducer types, the setting is set but not used until thermistor is selected for the transducer type (see dmm.transducer).The thermistor setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the thermistor setting you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The thermistor type in ohms, 2252, 5000 or 10000; if you enter any other value, it is converted as shown in the following table",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "Parameter",
                    "description": "Converted value ",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": ">= 1950 and < 3500",
                    "description": "2252",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": ">= 3500 and < 7500",
                    "description": "5000",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": ">= 7500 and <= 10050",
                    "description": "10000",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.thermistor",
                "dmm.thermistor = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THERMISTOR;dmm.thermistor = 3000;",
                    "description": "Sets thermistor type to 2252. Note that the original value is set to 3000, but is automatically converted to 2252.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.transducer"
            ]
        },
        {
            "name": "dmm.thermocouple",
            "webhelpfile": "16070.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1 (dmm.THERMOCOUPLE_K)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates the thermocouple type.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried. An illegal parameter value error message is generated if the value specified is not a supported thermocouple type value listed in the usage table.The thermocouple attribute is only used when the transducer type is thermocouple. For all other transducer types, the value is set but not used until the transducer type is set for thermocouple.The thermocouple setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the thermocouple value you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The thermocouple type",
                    "enum": "dmm.THERMOCOUPLE_J 0|dmm.THERMOCOUPLE_K 1|dmm.THERMOCOUPLE_T 2|dmm.THERMOCOUPLE_E 3|dmm.THERMOCOUPLE_R 4|dmm.THERMOCOUPLE_S 5|dmm.THERMOCOUPLE_B 6|dmm.THERMOCOUPLE_N 7",
                    "type": "dmmthermocouplevalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.thermocouple",
                "dmm.thermocouple = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THERMOCOUPLE;dmm.thermocouple = dmm.THERMOCOUPLE_J;",
                    "description": "Sets the thermocouple type to J.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.transducer"
            ]
        },
        {
            "name": "dmm.threertd",
            "webhelpfile": "16071.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0 (dmm.RTD_PT100)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the type of three-wire RTD that is being used.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\" and dmm.transducer is set to dmm.TEMP_THREERTD. For all other transducer types, the attribute is set but is not used until the transducer type is set for three-wire RTD. All other functions generate an error and return nil when queried.An illegal parameter value error message is generated if the value specified is not a supported RTD type value as listed in the usage table.The three-wire RTD setting is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the three-wire RTD setting you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The type for 3-wire RTD",
                    "enum": "dmm.RTD_PT100 3|dmm.RTD_D100 0|dmm.RTD_F100 1|dmm.RTD_PT385 2|dmm.RTD_PT3916 3|dmm.RTD_USER 4",
                    "type": "dmmthreertdvalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.threertd",
                "dmm.threertd = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THREERTD;dmm.threertd = dmm.RTD_PT3916;",
                    "description": "Sets the type of three-wire RTD to PT3916.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func",
                "dmm.transducer"
            ]
        },
        {
            "name": "dmm.threshold",
            "webhelpfile": "16072.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1.000000E+01\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines the signal level where the instrument makes frequency or period measurements.",
            "details": "This attribute is only valid when dmm.func is set to \"frequency\", \"period\", or \"continuity\". All other functions generate an error and return nil when queried.The range setting conditions the signal. The instrument automatically selects the most sensitive threshold range for the value you enter. For example, if you specify the expected input voltage to be 90\u00a0mV, the instrument automatically selects the\u00a0100 mV threshold range.Errors are generated if the parameter value does not make sense for selected function.The threshold value is saved with the dmm.func function setting, so if you use another function, then return to \"frequency\", \"period\", or \"continuity\", the threshold value you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The threshold setting. The range for",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.threshold",
                "dmm.threshold = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"frequency\";dmm.threshold = 30;",
                    "description": "Sets the threshold range for frequency to 30.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.transducer",
            "webhelpfile": "16073.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "1 (dmm.TEMP_THERMOCOUPLE)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the transducer type.",
            "details": "This attribute is only valid when dmm.func is set to \"temperature\". All other functions generate an error and return nil when queried.The transducer value is saved with the dmm.func function setting, so if you use another function, then return to \"temperature\", the transducer value you set previously is retained.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The transducer type",
                    "enum": "dmm.TEMP_THERMOCOUPLE 1|dmm.TEMP_THERMISTOR 2|dmm.TEMP_THREERTD 3|dmm.TEMP_FOURRTD 4",
                    "type": "dmmtransducervalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = dmm.transducer",
                "dmm.transducer = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.transducer = dmm.TEMP_THERMISTOR;",
                    "description": "Sets transducer to thermistor type.\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.fourrtd",
                "dmm.func"
            ]
        },
        {
            "name": "dmm.units",
            "webhelpfile": "16074.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0  (dmm.UNITS_VOLTS) for \"acvolts\" and \"dcvolts\"\n2 (dmm.UNITS_CELSIUS) for \"temperature\"\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the units that are used for voltage and temperature measurements.",
            "details": "This attribute is only valid when dmm.func is set to \"dcvolts\", \"acvolts\", or \"temperature\". All other functions generate an error and return nil when queried.The units value is saved with the dmm.func function setting, so if you use another function, then return to \"dcvolts\", \"acvolts\", or \"temperature\", the units setting you set previously is retained.Errors are generated if the parameter value does not make sense for the selected function.",
            "param_info": [
                {
                    "name": "value",
                    "description": "For DC volts and AC volts, select from the following units",
                    "enum": "dmm.UNITS_VOLTS 0|dmm.UNITS_DECIBELS 1|dmm.UNITS_CELSIUS 2|dmm.UNITS_KELVIN 3|dmm.UNITS_FAHRENHEIT 4",
                    "type": "dmmunitsvalue",
                    "range": ""
                }
            ],
            "usage": [
                "state = dmm.units",
                "dmm.units = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "dmm.func = \"temperature\";dmm.units = dmm.UNITS_FAHRENHEIT;",
                    "description": "Sets units for temperature measurements to Fahrenheit (\u00b0F).\n"
                }
            ],
            "related_commands": [
                "dmm.configure.recall()",
                "dmm.configure.set()",
                "dmm.func"
            ]
        },
        {
            "name": "channel.getstatelatch()",
            "webhelpfile": "16200.htm",
            "signature": "channel.getstatelatch(channelList)",
            "command_return": "state",
            "type": "Function\n",
            "default_value": "14 for overload, match, and overflow\n",
            "tsp_link": "Yes\n",
            "description": "This function gets the mask representing the states that would be latched if they occurred.",
            "details": "Applicable to digital I/O, totalizer, and DAC channels only.Each indicator is represented by a bit in the mask.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Return string listing the comma-delimited latch states for channels in channelList",
                    "enum": "",
                    "type": "channelsetstatelatchstateLatchMask",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String specifying the channels to query, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "state = channel.getstatelatch(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "myState = channel.getstatelatch(\"1001\");print(myState);",
                    "description": "Queries the state event latch on digital I/O channel 1 in slot 1 assuming a Model 3750.\n"
                },
                {
                    "example": "channel.setstatelatch(\"6010\", bit.bitor(channel.IND_OVERFLOW, channel.IND_OVERLOAD));print(channel.getstatelatch(\"6010\"));",
                    "description": "Generate either an overflow or overload event on DAC channel 10 in slot 6, assuming a Model\u00a03750.\n--- --Query for the state latch for channel 10 on slot 6.\n--- --Output:\n--- --10\n"
                }
            ],
            "related_commands": [
                "channel.setstatelatch()"
            ]
        },
        {
            "name": "ptp.enable",
            "webhelpfile": "16215.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (ptp.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables the precision time protocol (PTP) described in IEEE\u20111588 on the Series 3700A.",
            "details": "From the factory, this attribute is disabled (ptp.OFF). After setting this attribute, it is saved in nonvolatile memory, and that setting value is recalled the next time the instrument is powered on.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Disable the ptp protocol",
                    "enum": "ptp.OFF 0|ptp.ON 1",
                    "type": "ptpenablestate",
                    "range": ""
                }
            ],
            "usage": [
                "state = ptp.enable",
                "ptp.enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "ptp.enable=1;print(ptp.enable);",
                    "description": "Output:\n--- --1.000000000e+00\n"
                }
            ],
            "related_commands": [
                "Not applicable"
            ]
        },
        {
            "name": "ptp.portstate",
            "webhelpfile": "16216.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute is a read-only value that indicates the state of the IEEE\u20111588 precision time protocol (PTP).",
            "details": "",
            "param_info": [
                {
                    "name": "state",
                    "description": "ptp.INITIALIZING (0)ptp.FAULTY (1)ptp.DISABLE (2)ptp.LISTENING (3)ptp.PRE_MASTER (4)ptp.MASTER (5)ptp.PASSIVE (6)ptp.UNCALIBRATED (7)ptp.SLAVE (8)ptp.UNKNOWN (9)",
                    "enum": "ptp.INITIALIZING nil|ptp.FAULTY nil|ptp.DISABLE nil|ptp.LISTENING nil|ptp.PRE_MASTER nil|ptp.MASTER nil|ptp.PASSIVE nil|ptp.UNCALIBRATED nil|ptp.SLAVE nil|ptp.UNKNOWN nil",
                    "type": "ptpportstatestate",
                    "range": "(0)"
                }
            ],
            "usage": [
                "state = ptp.portstate"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(ptp.portstate);",
                    "description": "Output (this output indicates that PTP is disabled):\n--- --2.000000000e+00\n"
                }
            ],
            "related_commands": [
                "ptp.enable"
            ]
        },
        {
            "name": "ptp.time()",
            "webhelpfile": "16221.htm",
            "signature": "ptp.time()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function is a read-only string that returns the PTP time in seconds and fractional seconds.",
            "details": "",
            "param_info": [
                {
                    "name": "sec,fraction=ptp.time()print(sec+fraction)",
                    "description": "Output",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "ptp.time()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "sec,fraction=ptp.time();print(sec+fraction);",
                    "description": "Output:\n--- --1.306440045e+09\n"
                }
            ],
            "related_commands": [
                "Not applicable"
            ]
        },
        {
            "name": "ptp.utcoffset",
            "webhelpfile": "16222.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "See Details\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the offset, in seconds, between UTC and PTP.",
            "details": "If the instrument is a subordinate, the ptp.utcoffset value is from the master. If the value is from the master, the setting is overwritten on the next synchronization. The Series 3700A does not keep track of this value through a power cycle (that is, it defaults to 0 if the 3700 is the master). The ptp.utcoffset is only nonzero if the Series 3700A communicates to a master clock that is aware of the difference between PTP and UTC time.You can only write to this command if the Series 3700A is the master. If the Series 3700A is not the master, an error is generated when you try to write to the Series 3700A.The Series 3700A is not time-zone aware, so UTC time is presented as the local time.UTC Time = PTP Time \u2013 UTC Offset",
            "param_info": [
                {
                    "name": "value",
                    "description": "The offset in seconds",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = ptp.utcoffset",
                "ptp.utcoffset = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "ptp.utcoffset=33;print(ptp.utcoffset);",
                    "description": "Sets the UTC offset to 33 seconds.\n--- --Output:\n--- --3.300000000e+01\n"
                }
            ],
            "related_commands": [
                "Not applicable"
            ]
        },
        {
            "name": "scan.abort()",
            "webhelpfile": "16240.htm",
            "signature": "scan.abort()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function aborts a running background scan.",
            "details": "If no scan is running, the call to this function is ignored.",
            "param_info": [],
            "usage": [
                "scan.abort()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.background();scan.abort();",
                    "description": "Starts background scan, and then aborts the scan.\n"
                }
            ],
            "related_commands": [
                "scan.background()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.addwrite()",
            "webhelpfile": "16242.htm",
            "signature": "scan.addwrite(channelList, writeValue, width)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function writes a specified value to a channel at the added step in the scan.",
            "details": "This command is similar to issuing channel.write() at the scan step. Specifying multiple channels in channelList causes multiple steps to be added to the scan. For digital I/O channels, only a width of 1, 2, 3, or 4 is supported. Any information (bits) greater than the specified width are ignored. Values written to inputs are ignored. If no specified channel is set for output, an error is generated. If a width crosses channels, only the channels set to output are affected.This is not available for backplane and switch channels.For DAC channels, if the channel mode is changed after the scan is created, the scan is rebuilt. If the write value is no longer compatible with the new mode, an error is generated and the scan becomes invalid.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying channels to add using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "writeValue",
                    "description": "The value to write to the channel for this scan step",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "width",
                    "description": "Specifies the width of the channel write to use with items in channelList",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scan.addwrite(channelList, writeValue)",
                "scan.addwrite(channelList, writeValue, width)"
            ],
            "overloads": [
                "scan.addwrite(channelList, writeValue)"
            ],
            "examples": [
                {
                    "example": "scan.addwrite(\"6001, 6003, 6005\", 21845, 2);",
                    "description": "Assume a 3750 in slot 6. Add to existing scan list channels 1, 3 and 5 on slot 6 to write a 16-bit hex value of hexadecimal 5555 (decimal 21845).\n"
                }
            ],
            "related_commands": [
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.measurecount",
            "webhelpfile": "16248.htm",
            "signature": "",
            "command_return": "count",
            "type": "Attribute (RW)\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the number of iterations performed when a scanning measurement is requested.",
            "details": "Use this attribute to indicate how many measurements to make on a step when measurements are needed. This sets the measurement count in the trigger model. During a scan, the Series 3700A iterates through the sequence event detector and measurement action of the trigger model count times. After performing count iterations, the Series 3700A returns to check the scan count.This must be set before the scan is started. Once set, it applies to all scan steps in the list, including scan steps that exist in the list and any that are added before the scan is started.All steps take the same number of measurements. When taking multiple measurements, the measurements may be taken as quickly as possible based on the configuration (scan.trigger.measure.stimulus = 0) or they may be paced by a trigger (scan.trigger.measure.stimulus is nonzero).",
            "param_info": [
                {
                    "name": "count",
                    "description": "The count value being used or read; valid range is 1 to 450000",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "count = scan.measurecount",
                "scan.measurecount = count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.measurecount = 5;",
                    "description": "Sets the measurement count to 5.\n"
                }
            ],
            "related_commands": [
                "scan.create()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.nobufferbackground()",
            "webhelpfile": "16250.htm",
            "signature": "scan.nobufferbackground()",
            "command_return": "state, scancount, stepcount",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function starts a scan in background mode and specifies that no reading buffer is used during scanning.",
            "details": "Before using this command, use scan.create(), scan.add(), and scan.addimagestep() to set up scan elements. If a reading buffer is specified, an error is generated.To view the scan status, use scan.state().To run a scan in the background with a reading buffer, see scan.background().",
            "param_info": [
                {
                    "name": "state",
                    "description": "The result of scanning",
                    "enum": "scan.EMPTY 0|scan.BUILDING 1|scan.RUNNING 2|scan.ABORTED 3|scan.FAILED 4|scan.FAILED_INIT 5|scan.SUCCESS 6",
                    "type": "scannobufferbackgroundstate",
                    "range": ""
                },
                {
                    "name": "scancount",
                    "description": "The present number of scans completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "stepcount",
                    "description": "The present number of steps completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "state, scancount, stepcount = scan.nobufferbackground()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.nobufferbackground();",
                    "description": "Run the scan in the background with no reading buffer.\n"
                }
            ],
            "related_commands": [
                "scan.add()",
                "scan.background()",
                "scan.create()",
                "scan.execute()",
                "scan.list()",
                "scan.nobufferexecute()",
                "scan.state()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.nobufferexecute()",
            "webhelpfile": "16251.htm",
            "signature": "scan.nobufferbackground()",
            "command_return": "state, scanCount, stepCount",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function starts a scan immediately and specifies that no reading buffer is used during scanning.",
            "details": "Before using this command, use scan.create(), scan.add(), and scan.addimagestep() to set up scan elements. If a reading buffer is specified, an error is generated.The command continues execution until scanning completes or is aborted by the user.To run a scan immediately with a reading buffer, see scan.execute().",
            "param_info": [
                {
                    "name": "state",
                    "description": "The result of scanning",
                    "enum": "scan.EMPTY 0|scan.BUILDING 1|scan.RUNNING 2|scan.ABORTED 3|scan.FAILED 4|scan.FAILED_INIT 5|scan.SUCCESS 6",
                    "type": "scannobufferexecutestate",
                    "range": ""
                },
                {
                    "name": "scanCount",
                    "description": "The present number of scans that have completed",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "stepCount",
                    "description": "The present number of steps have completed",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "state, scanCount, stepCount = scan.nobufferbackground()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.nobufferexecute();",
                    "description": "Runs the scan immediately with no reading buffer.\n"
                }
            ],
            "related_commands": [
                "scan.add()",
                "scan.background()",
                "scan.create()",
                "scan.execute()",
                "scan.list()",
                "scan.nobufferbackground()",
                "scan.state()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.state()",
            "webhelpfile": "16254.htm",
            "signature": "scan.state()",
            "command_return": "scanState, scanCount, stepCount, reading",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function provides the present state of a running background scan.",
            "details": "Returns the state of the present scan, the scan count, and the step count.The scan count is the number of the present iteration through the scan portion of the trigger model. This number does not increment until the scan begins. Therefore, if the instrument is waiting for an input to trigger a scan start, the scan count represents the previous number of scan iterations. If no scan has begun, the scan count is zero.The step count is the number of times the scan has completed a pass through the channel action portion of the trigger model. This number does not increment until after the action completes. Therefore, if the instrument is waiting for an input to trigger a channel action, the step count represents the previous step. If no step has yet completed, the step count is zero. If the step count has yet to complete the first step in a subsequent pass through a scan, the scan count represents the last step in the previous scan pass.",
            "param_info": [
                {
                    "name": "scanState",
                    "description": "The present state of the scan running in the background. Possible states include",
                    "enum": "scan.EMPTY 0|scan.BUILDING 1|scan.RUNNING 2|scan.ABORTED 3|scan.FAILED 4|scan.FAILED_INIT 5|scan.SUCCESS 6",
                    "type": "scanstatescanState",
                    "range": ""
                },
                {
                    "name": "scanCount",
                    "description": "The number of scans that have completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "stepCount",
                    "description": "The number of steps that have completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "reading",
                    "description": "If measurements are made during the scan, this parameter contains the last scan reading completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "scanState, scanCount, stepCount, reading = scan.state()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.background();scanState, scanCount, stepCount = scan.state();print(scanState, scanCount, stepCount);",
                    "description": "Runs a scan in the background.\n--- --Check the present scan state.\n--- --View returned values.\n--- --Output shows that scan is running:\n--- --2.00000e+00\n"
                }
            ],
            "related_commands": [
                "scan.background()",
                "scan.mode",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.stepcount",
            "webhelpfile": "16255.htm",
            "signature": "",
            "command_return": "scanStepCount",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the number of steps in the present scan.",
            "details": "This is set by the number of steps in the active scan list. The value of this attribute is initially determined when the scan is created. When you add steps with the scan.create(), scan.addimagestep(), and scan.add() functions, the value of this attribute is updated.",
            "param_info": [
                {
                    "name": "scanStepCount",
                    "description": "The present step count value",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "scanStepCount = scan.stepcount"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(scan.stepcount);",
                    "description": "Responds with the present step count.\n--- --Output assuming there are five steps in the scan list:\n--- --5.00000e+00\n"
                }
            ],
            "related_commands": [
                "scan.add()",
                "scan.addimagestep()",
                "scan.create()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.arm.clear()",
            "webhelpfile": "16256.htm",
            "signature": "scan.trigger.arm.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the arm event detector.",
            "details": "This function sets the arm event detector of the trigger model to the undetected state.",
            "param_info": [],
            "usage": [
                "scan.trigger.arm.clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.arm.clear();",
                    "description": "Clears the arm event detector.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.arm.set()",
                "scan.trigger.arm.stimulus",
                "Trigger model",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.arm.set()",
            "webhelpfile": "16257.htm",
            "signature": "scan.trigger.arm.set()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the arm event detector to the detected state.",
            "details": "This function sets the arm event detector of the trigger model to the detected state.",
            "param_info": [],
            "usage": [
                "scan.trigger.arm.set()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.arm.set();",
                    "description": "Sets the arm event detector to the detected state.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.arm.clear()",
                "scan.trigger.arm.stimulus",
                "Trigger model",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.arm.stimulus",
            "webhelpfile": "16258.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines which event starts the scan.",
            "details": "This attribute selects which events cause the arm event detector to enter the detected state.Set this attribute to 0 to start the scan without waiting for an event.eventID may be one of the following trigger event IDs.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "Trigger stimulus used for the channel action (arm layer); see Details",
                    "enum": "",
                    "type": "any",
                    "range": "(arm layer)"
                }
            ],
            "usage": [
                "eventID = scan.trigger.arm.stimulus",
                "scan.trigger.arm.stimulus = eventID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.arm.stimulus = scan.trigger.EVENT_SCAN_READY;",
                    "description": "Sets trigger stimulus of the arm event detector to scan ready event.\n"
                },
                {
                    "example": "scan.trigger.arm.stimulus = 0;",
                    "description": "The scan begins immediately.\n"
                },
                {
                    "example": "scan.trigger.arm.stimulus = digio.trigger[3].EVENT_ID;",
                    "description": "The scan begins when the instrument receives a signal from digital I/O line 3.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.arm.clear()",
                "scan.trigger.arm.set()",
                "Trigger model",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.channel.clear()",
            "webhelpfile": "16259.htm",
            "signature": "scan.trigger.channel.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the channel event detector.",
            "details": "This function clears the channel event detector of the trigger model (sets it to the undetected state).",
            "param_info": [],
            "usage": [
                "scan.trigger.channel.clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.channel.clear();",
                    "description": "Clears the channel event detector.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.channel.set()",
                "scan.trigger.channel.stimulus",
                "Trigger model",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.channel.set()",
            "webhelpfile": "16260.htm",
            "signature": "scan.trigger.channel.set()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the channel event detector to the detected state.",
            "details": "This function sets the channel event detector of the trigger model to the detected state.",
            "param_info": [],
            "usage": [
                "scan.trigger.channel.set()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.channel.set();",
                    "description": "Sets the channel event detector of the trigger model to the detected state.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.channel.clear()",
                "scan.trigger.channel.stimulus",
                "Trigger model",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.measure.clear()",
            "webhelpfile": "16263.htm",
            "signature": "scan.trigger.measure.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the measure event detector.",
            "details": "This function sets the measurement event detector of the trigger model to the undetected state.",
            "param_info": [
                {
                    "name": "scan.trigger.measure.clear()",
                    "description": "Clears the measurement event detector.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scan.trigger.measure.clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.measure.clear();",
                    "description": "Clears the measurement event detector.\n"
                }
            ],
            "related_commands": [
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.measure.set()",
            "webhelpfile": "16264.htm",
            "signature": "scan.trigger.measure.set()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the measurement event detector to the detected state.",
            "details": "This function sets the measurement event detector of the trigger model to the detected state.",
            "param_info": [
                {
                    "name": "scan.trigger.measure.set()",
                    "description": "Sets the measurement event detector to the detected state.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scan.trigger.measure.set()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.measure.set();",
                    "description": "Sets the measurement event detector to the detected state.\n"
                }
            ],
            "related_commands": [
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.measure.stimulus",
            "webhelpfile": "16265.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute selects the trigger stimulus of the event detector trigger.",
            "details": "This attribute selects the events that cause the measurement event detector to enter the detected state. You can use this to pace each one of the measurement count readings with an event.To pace all readings by a single event, use scan.trigger.sequence.stimulus.To bypass waiting for an event, set this to 0.eventID can be set to one of the existing trigger event IDs, shown in the following table.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The trigger stimulus that is used for the measurement event",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "eventID = scan.trigger.measure.stimulus",
                "scan.trigger.measure.stimulus = eventID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.measure.stimulus = scan.trigger.EVENT_CHANNEL_READY;",
                    "description": "Sets the trigger stimulus of the measurement event detector to the channel ready event.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.sequence.stimulus",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.sequence.clear()",
            "webhelpfile": "16266.htm",
            "signature": "scan.trigger.sequence.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the sequence event detector.",
            "details": "This function sets the sequence event detector to the undetected state.",
            "param_info": [
                {
                    "name": "scan.trigger.sequence.clear()",
                    "description": "Clears the sequence event detector.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scan.trigger.sequence.clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.sequence.clear();",
                    "description": "Clears the sequence event detector.\n"
                }
            ],
            "related_commands": [
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.sequence.set()",
            "webhelpfile": "16267.htm",
            "signature": "scan.trigger.sequence.set()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the sequence even detector to the detected state.",
            "details": "This function sets the sequence event detector to the detected state.",
            "param_info": [
                {
                    "name": "scan.trigger.sequence.set()",
                    "description": "Sets the sequence event detector to the detected state.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scan.trigger.sequence.set()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.sequence.set();",
                    "description": "Sets the sequence event detector to the detected state.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.sequence.clear()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.trigger.sequence.stimulus",
            "webhelpfile": "16268.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Attribute (RW)\n",
            "default_value": "28 (scan.trigger.EVENT_CHANNEL_READY)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute selects the trigger stimulus for the sequence event detector.",
            "details": "This attribute selects the events that cause the sequence event detector to enter the detected state.Use this to start a set of measurement count readings that are triggered by a single event.To pace each reading by an event, use scan.trigger.measure.stimulus.To bypass pacing the readings, set this to 0.Set eventID to one of the existing trigger event IDs shown in the following table.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The trigger stimulus that is used for the sequence event",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "eventID = scan.trigger.sequence.stimulus",
                "scan.trigger.sequence.stimulus = eventID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.sequence.stimulus = scan.trigger.EVENT_CHANNEL_READY;",
                    "description": "Sets the trigger stimulus of the sequence event detector to the channel ready event.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.measure.stimulus",
                "Scanning and triggering"
            ]
        },
        {
            "name": "schedule.alarm[N].enable",
            "webhelpfile": "16299.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "0 (schedule.OFF)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables an alarm.",
            "details": "If you enable an alarm that has a start time that is in the past, the alarm executes immediately.If an alarm time in the past is used to start a scan, the alarm time may be missed by the scan start. This can occur because the scan clears any pending triggers before it begins, so it will miss any trigger generated from the alarm enable. To prevent a missed alarm, start the scan in the background, then enable the alarm.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Disable the alarm(schedule.OFF or 0)Enable the alarm (schedule.ON or 1)",
                    "enum": "schedule.OFF 0|schedule.ON 1",
                    "type": "schedulealarmenablestate",
                    "range": "(schedule.OFF or 0)"
                },
                {
                    "name": "N",
                    "description": "Alarm number (1 or 2)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 or 2)"
                }
            ],
            "usage": [
                "state = schedule.alarm[N].enable",
                "schedule.alarm[N].enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "schedule.alarm[1].enable = 1;",
                    "description": "Enables alarm 1.\n"
                }
            ],
            "related_commands": [
                "schedule.alarm[N].EVENT_ID",
                "schedule.alarm[N].fractionalseconds",
                "schedule.alarm[N].period",
                "schedule.alarm[N].ptpseconds",
                "schedule.alarm[N].repetition",
                "schedule.alarm[N].seconds",
                "schedule.disable()"
            ]
        },
        {
            "name": "schedule.alarm[N].EVENT_ID",
            "webhelpfile": "16300.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Constant\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This constant describes the trigger event generated by the alarm N.",
            "details": "To have another trigger object respond to trigger events generated by the schedule alarm, set the other object's stimulus attribute to the value of this constant.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The trigger event number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Alarm number (1 or 2)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 or 2)"
                }
            ],
            "usage": [
                "eventID = schedule.alarm[N].EVENT_ID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.arm.stimulus = schedule.alarm[1].EVENT_ID;",
                    "description": "Uses a trigger event on alarm 1 to be the stimulus for the trigger arm.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "schedule.alarm[N].fractionalseconds",
            "webhelpfile": "16301.htm",
            "signature": "",
            "command_return": "fraction",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the fractional seconds portion of the alarm time.",
            "details": "1588 has too much resolution to represent in a single floating-point value so the alarm times are split into two values (seconds and fractional seconds).",
            "param_info": [
                {
                    "name": "N",
                    "description": "Alarm number (1 or 2)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 or 2)"
                },
                {
                    "name": "fraction",
                    "description": "The fractional seconds portion of the alarm time",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "schedule.alarm[N].fractionalseconds = fraction",
                "fraction = schedule.alarm[N].fractionalseconds "
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "-- get current time and store in variable sec;sec = os.time();-- set alarm 1 seconds to be 1 minute after current time                               ;schedule.alarm[1].seconds = sec + 60;-- set alarm 1 fractional seconds to be 0.5;schedule.alarm[1].fractionalseconds = 0.5;print(\"value of sec is \", sec) ;print(\"value of alarm 1 seconds is \",  schedule.alarm[1].seconds) ;print(\"value of alarm 1 fractional seconds is \", schedule.alarm[1].fractionalseconds);",
                    "description": "Create an alarm to occur 60.5 seconds from current time in UTC seconds.\n--- --Output:\n--- --value of sec is \t1.306405866e+009\n--- --value of alarm 1 seconds is \t1.306405926e+009\n--- --value of alarm 1 fractional seconds is \t5.000000000e-001\n"
                }
            ],
            "related_commands": [
                "schedule.alarm[N].seconds"
            ]
        },
        {
            "name": "schedule.alarm[N].period",
            "webhelpfile": "16302.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the time, in seconds, between adjacent firings of the alarm.",
            "details": "",
            "param_info": [
                {
                    "name": "N",
                    "description": "Alarm number (1 or 2)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 or 2)"
                },
                {
                    "name": "value",
                    "description": "The time in seconds",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = schedule.alarm[N].period",
                "schedule.alarm[N].period = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "0.5schedule.alarm[1].period = 0.5;",
                    "description": "Set a period of 0.5 seconds between firings of alarms after the initial alarm.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "schedule.alarm[N].ptpseconds",
            "webhelpfile": "16303.htm",
            "signature": "",
            "command_return": "seconds",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "The seconds portion of the alarm time in PTP seconds.",
            "details": "1588 has too much resolution to represent in a single floating-point value, so the alarm times are split into two values (seconds and fractional seconds).",
            "param_info": [
                {
                    "name": "N",
                    "description": "Alarm (1 or 2)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 or 2)"
                },
                {
                    "name": "seconds",
                    "description": "The seconds portion of the alarm time in PTP seconds",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "schedule.alarm[N].ptpseconds = seconds",
                "seconds = schedule.alarm[N].ptpseconds"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "sec,ns = ptp.time();schedule.alarm[1].ptpseconds = sec + 30;",
                    "description": "Create an alarm to occur 30 seconds from current time in PTP seconds.\n"
                }
            ],
            "related_commands": [
                "ptp.utcoffset"
            ]
        },
        {
            "name": "schedule.alarm[N].repetition",
            "webhelpfile": "16304.htm",
            "signature": "",
            "command_return": "count",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the number of times an alarm repeats after the first alarm firing.",
            "details": "The alarm will fire a total of count+1 times. If 0 and period is nonzero, the alarm fires forever.Once an alarm begins, the repetition counts down for each trigger generated. It ends at zero (0). You must set this repetition back to some value if you intend to reissue the alarm. Otherwise, the alarm will either not fire (if the period is zero) or fire forever (if period is nonzero).",
            "param_info": [
                {
                    "name": "count",
                    "description": "The number of repetitions",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Alarm 1 or 2",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "count = schedule.alarm[N].repetition",
                "schedule.alarm[N].repetition = count"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "schedule.alarm[1].repetition = 10;",
                    "description": "Set the alarm to fire 10 times.\n"
                }
            ],
            "related_commands": [
                "schedule.alarm[N].enable"
            ]
        },
        {
            "name": "schedule.alarm[N].seconds",
            "webhelpfile": "16305.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "The seconds portion of the alarm time in UTC seconds.",
            "details": "1588 has too much resolution to represent in a single floating-point value, so the alarm times are split into two values (seconds and fractional seconds).",
            "param_info": [
                {
                    "name": "value",
                    "description": "Seconds portion of the alarm time in UTC seconds",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Alarm number (1 or 2)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 or 2)"
                }
            ],
            "usage": [
                "value = schedule.alarm[N].seconds",
                "schedule.alarm[N].seconds = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "local l_myTime;l_myTime = os.time{year = 2008, month = 3, day = 15, hour = 10};schedule.alarm[1].seconds = l_myTime;",
                    "description": "Create an alarm to occur on March 15, 2008 at 10 am in UTC seconds.\n"
                }
            ],
            "related_commands": [
                "ptp.utcoffset"
            ]
        },
        {
            "name": "schedule.disable()",
            "webhelpfile": "16306.htm",
            "signature": "schedule.disable()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function disables all alarms.",
            "details": "This command sets the schedule.alarm[N].enable attribute to 0 (schedule.OFF) for each schedule alarm N.",
            "param_info": [],
            "usage": [
                "schedule.disable()"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "schedule.alarm[N].enable"
            ]
        },
        {
            "name": "setup.cards()",
            "webhelpfile": "16315.htm",
            "signature": "setup.cards(pathfilename)",
            "command_return": "CardModels",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the card model numbers that are defined for each slot in a saved setup.",
            "details": "This function returns a comma-delimited string that lists the card model for each slot in the instrument (from 1 to 6) for the specified saved setup. If no card was installed in the slot when the setup was saved, a 0 is returned as the card model number.Use CardModels = setup.cards() to return cards associated with the internally saved setup.Use CardModels = setup.cards(\"/path/filename.set\") to return cards associated with the setup saved on the USB flash drive.",
            "param_info": [
                {
                    "name": "CardModels",
                    "description": "A comma-delimited string listing the card model numbers for each slot",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "path/filename",
                    "description": "The path and name of the file on the flash drive; the path may be absolute or relative to the current working directory; the .set extension must be on the filename",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "CardModels = setup.cards() ",
                "CardModels = setup.cards(pathfilename) "
            ],
            "overloads": [
                "CardModels = setup.cards() "
            ],
            "examples": [
                {
                    "example": "CardModels = setup.cards();print(CardModels);",
                    "description": "Query the cards associated with the internal saved setup.\n--- --Output, assuming a 3722 card in slot\u00a01:\n--- --3722,0,0,0,0,0\n"
                },
                {
                    "example": "print(setup.card(\"/usb1/mysetup.set\"));",
                    "description": "Query the cards associated with setup saved as JulySetup.set on the thumb drive.\n--- --The following example of output shows that slots 1, 5, and 6 are empty, slot 2 has a 3723 installed, slot\u00a03 has a 3722 installed and slot 4 has a 3720 installed:\n--- --0,3723,3722,3720,0,0\n"
                }
            ],
            "related_commands": [
                "setup.recall()",
                "setup.save()"
            ]
        },
        {
            "name": "slot[slot].commonsideohms",
            "webhelpfile": "16320.htm",
            "signature": "",
            "command_return": "commonside",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates whether a card in the specified slot supports commonside channels for 4\u2011wire resistance measurements.",
            "details": "If commonside 4-wire resistance channels are supported, the returned value is 1.If commonside 4\u2011wire resistance channels are not supported, the return value is nil.",
            "param_info": [
                {
                    "name": "commonside",
                    "description": "Indication of whether or not commonside 4-wire ohm channels are supported",
                    "enum": "",
                    "type": "1|nil",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "commonside = slot[slot].commonsideohms"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[1].commonsideohms);",
                    "description": "Query if slot 1 supports commonside 4-wire\u00a0ohms channels.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "slot[slot].idn",
            "webhelpfile": "16328.htm",
            "signature": "",
            "command_return": "idnString",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns a string that contains information about the plug-in card.",
            "details": "The information that is returned depends on whether the plug-in card in the slot is a physical card or pseudocard.For physical cards, this returns a comma\u2011separated string that contains the model number, description, firmware revision, and serial number of the plug-in card installed in the specified slot.For pseudocards, the response is Pseudo, followed by the model number, description, and ??? for the firmware revision and serial number.",
            "param_info": [
                {
                    "name": "idnString",
                    "description": "The return string",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number(1 to 6)",
                    "enum": "",
                    "type": "1|2",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "idnString = slot[slot].idn"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[3].idn);",
                    "description": "If a 3723 is installed in slot 3, the response is:\n--- --3723,Dual 1x30 Reed Multiplexer,01.40e,1243657\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "slot[slot].interlock.override",
            "webhelpfile": "16329.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute suppresses or permits interlock errors to be generated.",
            "details": "This command suppresses errors that would otherwise be generated when the interlock is not closed. If the interlock is not physically connected, channels will still not close.This attribute exists only for installed cards that support detecting an interlock break. Otherwise, the return value is nil. If the card supports detecting an interlock break, set this attribute to the appropriate response. To enable interlock override on the card, set to slot.ON. To disable it, set to slot.OFF. This setting applies to all interlocks on the card.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Indicates the state of the interlock override",
                    "enum": "slot.ON nil|slot.OFF nil",
                    "type": "slotinterlockoverridevalue",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "The slot (1 to 6) containing the card to which the interlock state is applied",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].interlock.override",
                "slot[slot].interlock.override = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "slot[3].interlock.override = slot.ON;",
                    "description": "Suppresses interlock errors.\n"
                }
            ],
            "related_commands": [
                "slot[slot].interlock.state"
            ]
        },
        {
            "name": "slot[slot].interlock.state",
            "webhelpfile": "16330.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates the interlock state of a card.",
            "details": "This attribute will not exist for a slot if a card is not installed or the card installed does not support detecting an interlock break. In these cases, the return value is nil. Use this attribute to query the interlock state for cards that support detecting interlock break. ",
            "param_info": [
                {
                    "name": "value",
                    "description": "Indicates whether the interlocks are engaged or not; see table below for possible return values",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "The slot (1 to 6) containing the card to which the interlock state is applied",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].interlock.state"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "slot[slot].interlock.override"
            ]
        },
        {
            "name": "slot[slot].isolated",
            "webhelpfile": "16331.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if the card in the specified slot supports isolated channels.",
            "details": "This attribute is only available for a slot if the installed card supports the isolated channels. If isolated channels are not available, the return value is nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "1 if isolated channels are supported",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].isolated"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "IsolatedChan1 = slot[1].isolated;print(IsolatedChan1);",
                    "description": "Query if slot 1 supports isolated channels. If it does support isolated channels, the output is:\n--- --1.000000000e+00\n"
                }
            ],
            "related_commands": [
                "slot[X].idn"
            ]
        },
        {
            "name": "slot[slot].matrix",
            "webhelpfile": "16332.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if the card in the specified slot supports matrix channels.",
            "details": "This attribute is only available for a slot if a card is installed and if the installed card supports matrix channels. If matrix channels are not available, the return value is nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "1 if matrix channels are supported",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].matrix"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "Matrix1 = slot[1].matrix;print(Matrix1);",
                    "description": "Query if slot 1 supports matrix channels. If it does support matrix channels, the output is:\n--- --1.000000000e+00\n"
                }
            ],
            "related_commands": [
                "slot[slot].idn"
            ]
        },
        {
            "name": "slot[slot].maxvoltage",
            "webhelpfile": "16333.htm",
            "signature": "",
            "command_return": "maximumVolts",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the maximum voltage of all channels on a plug-in card in the specified slot.",
            "details": "This command is only available for a slot if the installed plug-in card supports voltage settings.",
            "param_info": [
                {
                    "name": "maximumVolts",
                    "description": "The maximum voltage",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "maximumVolts = slot[slot].maxvoltage"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxVolts2 = slot[2].maxvoltage;print(maxVolts2);",
                    "description": "Query the maximum voltage on slot 2. The output is similar to:\n--- --300 \n"
                }
            ],
            "related_commands": [
                "slot[slot].idn"
            ]
        },
        {
            "name": "slot[slot].multiplexer",
            "webhelpfile": "16334.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if the card in the specified slot supports multiplexer channels.",
            "details": "This attribute is only available for a slot if the installed card supports multiplexer channels. If multiplexer channels are not available, the return value is nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "1 if multiplexer channels are supported",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].multiplexer"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "MuxChan1 = slot[1].multiplexer;print(MuxChan1);",
                    "description": "Query if slot 1 supports multiplexer channels. If it does support multiplexer channels, the output is:\n--- --1.000000000e+00\n"
                }
            ],
            "related_commands": [
                "slot[slot].idn"
            ]
        },
        {
            "name": "slot[slot].poles.four",
            "webhelpfile": "16335.htm",
            "signature": "",
            "command_return": "fourPole",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if a four-pole setting is supported for the channels on the card.",
            "details": "This attribute only exists if a card is installed and if the card supports four\u2011pole settings for the channels on the card. If not, the value is nil. If supported, the value is 1.",
            "param_info": [
                {
                    "name": "fourPole",
                    "description": "The return value",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "fourPole = slot[slot].poles.four"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "fourPole3 = slot[3].poles.four;print(fourPole3);",
                    "description": "Queries if slot 3 supports four-pole settings for the channels on the card.\n--- --Output if card supports four pole:\n--- --1.000000000e+00\n--- --Output if card does not support four pole:\n--- --nil\n"
                }
            ],
            "related_commands": [
                "slot[slot].poles.one",
                "slot[slot].poles.two"
            ]
        },
        {
            "name": "slot[slot].poles.one",
            "webhelpfile": "16336.htm",
            "signature": "",
            "command_return": "onePole",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if a one-pole setting is supported for the channels on the specified card.",
            "details": "This attribute only exists if a card is installed and if the card supports one\u2011pole settings for the channels on the card. If not, the value is nil. If supported, the value is 1.",
            "param_info": [
                {
                    "name": "onePole",
                    "description": "The return value",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number  (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "onePole = slot[slot].poles.one"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[3].poles.one);",
                    "description": "Query to see if slot 3 supports one-pole settings for the channels on the card.\n--- --Output if card supports one pole:\n--- --1.000000000e+00\n--- --Output if card does not support one pole:\n--- --nil\n"
                }
            ],
            "related_commands": [
                "slot[slot].poles.four",
                "slot[slot].poles.two"
            ]
        },
        {
            "name": "slot[slot].poles.two",
            "webhelpfile": "16337.htm",
            "signature": "",
            "command_return": "twoPole",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if a two-pole setting is supported for the channels on the card.",
            "details": "This attribute only exists is a card is installed and if the card supports a two\u2011pole setting for the channels on the card.If not, the value is nil. If supported, the value is 1.",
            "param_info": [
                {
                    "name": "twoPole",
                    "description": "The return value",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "twoPole = slot[slot].poles.two"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "twoPole3 = slot[3].poles.two;print(twoPole3);",
                    "description": "Query to see if slot 3 supports two-pole settings for the channels on the card.\n--- --Output if card supports two pole:\n--- --1.000000000e+00\n--- --Output if card does not support two pole:\n--- --nil\n"
                }
            ],
            "related_commands": [
                "slot[slot].poles.one",
                "slot[slot].poles.four"
            ]
        },
        {
            "name": "slot[slot].tempsensor",
            "webhelpfile": "16345.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates if the module in the specified slot supports temperature sensor channels.",
            "details": "This command is only available for a slot if the installed module supports temperature sensor channels. If temperature sensor channels are not available, the return value is nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "If temperature sensor channels are supported, returns 1",
                    "enum": "",
                    "type": "1|nil",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].tempsensor"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "TempSensor = slot[1].tempsensor;print(TempSensor);",
                    "description": "Query to determine if slot 1 supports temperature sensor channels. If it does support temperature sensor channels, the output is:\n--- --1.000000000e+00\n"
                }
            ],
            "related_commands": [
                "slot[slot].idn"
            ]
        },
        {
            "name": "slot[slot].thermal.state",
            "webhelpfile": "16346.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates the thermal state of the card in the specified slot.",
            "details": "This attribute is only available for a slot if a card is installed and if the installed card supports thermal state detection. If thermal state detection is not available, the return value is nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "0 if thermal conditions will not affect specifications1 if  thermal conditions are getting warm enough to affect specifications",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].thermal.state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[3].thermal.state);",
                    "description": "Query the thermal state on slot 3. If specifications might be affected by the thermal state, the output is:\n--- --1.000000000e+00\n"
                }
            ],
            "related_commands": [
                "slot[slot].idn"
            ]
        },
        {
            "name": "scan.addimagestep()",
            "webhelpfile": "16633.htm",
            "signature": "scan.addimagestep(channelList, dmmConfig)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function allows you to include multiple channels in a single scan step.",
            "details": "This function adds a list of channels to be closed simultaneously in a single step of a scan. An optional DMM configuration can be added to force the scan to take a measurement during the same step.This function is an advanced command; the channelList parameter must specify appropriate relays to support the requested DMM configuration, or an invalid measurement will result.Unlike scan.add(), the paired channels and backplanes necessary for measurement are not automatically added to the step. Use the channel.setpole() command to indicate if the paired channel should be added or not. Backplanes assigned to channels by the channel.setbackplane() command are not added to the image step automatically. For example, if a measurement is taken on a 4-wire ohms configuration without designating 4-pole with the channel.setpole() command, the corresponding paired channels and backplanes will not be added, and the specified dmmConfig will not cause additional relay closures as it normally would.If you have changed the pole setting on any of the channels in the list (using channel.setpole()), an additional paired channel is added or removed, as appropriate. For example, to ensure that the proper channels close to enable a 4-wire measurement, set the pole setting in addition to using the 4-wire ohms DMM configuration.When a DMM configuration (other than \"nofunction\") is specified, the instrument will take the appropriate measurement based on the function set in the configuration; if no DMM configuration is specified with the command, no measurement will be taken.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying a list of channels",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "dmmConfig",
                    "description": "String specifying a DMM configuration",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "scan.addimagestep(channelList)",
                "scan.addimagestep(channelList, dmmConfig)"
            ],
            "overloads": [
                "scan.addimagestep(channelList)"
            ],
            "examples": [
                {
                    "example": "scan.addimagestep(\"1101, 2202, 1911\", \"dcvolts\") ;scan.addimagestep(\"1102, 2202, 1911\", \"dcvolts\") ;scan.addimagestep (\"1103, 2202, 1911\",\"dcvolts\");",
                    "description": "Adds three steps with the following actions:\n--- --Closes channels 1101, 2202, and 1911, and then makes a dc voltage measurement. Opens channel 1101, closes 1102 and maintains 1911 and 2202 closed, and then makes a dc voltage\u00a0measurement. Opens channel 1102, closes 1103 and maintains 1911 and 2202 closed, and then makes a dc voltage\u00a0measur"
                }
            ],
            "related_commands": [
                "channel.setbackplane()",
                "channel.setpole()",
                "scan.add()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "script.restore()",
            "webhelpfile": "16851.htm",
            "signature": "script.restore(name)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function restores a script that was removed from the runtime environment.",
            "details": "This command copies the script from nonvolatile memory into the runtime environment. It also creates a global variable with the same name as the name of the script.",
            "param_info": [
                {
                    "name": "name",
                    "description": "The name of the script to be restored",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "script.restore(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "script.restore(\"test9\");",
                    "description": "Restores a script named test9 from nonvolatile memory.\n"
                }
            ],
            "related_commands": [
                "script.delete()"
            ]
        },
        {
            "name": "scriptVar.autorun",
            "webhelpfile": "16852.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "See Details\n",
            "tsp_link": "No\n",
            "description": "This attribute controls the autorun state of a script.",
            "details": "Autorun scripts run automatically when the instrument is turned on. You can set any number of scripts to autorun.The run order for autorun scripts is arbitrary, so make sure the run order is not important.The default value for scriptVar.autorun depends on how the script was loaded. The default is no if the script was loaded with loadscript or script.new(). It is yes for scripts loaded with loadandrunscript or script.newautorun().",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of the variable that references the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "state",
                    "description": "String that indicates whether or not the script runs automatically when powered on",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar.autorun = state",
                "state = scriptVar.autorun"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "test5.autorun = \"yes\";test5.save();",
                    "description": "Assume a script named test5 is in the runtime environment.\n--- --The next time the instrument is turned on, test5 script automatically loads and runs.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "script.delete()",
            "webhelpfile": "16853.htm",
            "signature": "script.delete(scriptName)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function deletes a script from nonvolatile memory.",
            "details": "",
            "param_info": [
                {
                    "name": "scriptName",
                    "description": "The string that represents the name of the script",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "script.delete(scriptName)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "script.delete(\"test8\");",
                    "description": "Deletes a user script named test8 from nonvolatile memory.\n"
                }
            ],
            "related_commands": [
                "Delete user scripts from the instrument",
                "scriptVar.save()"
            ]
        },
        {
            "name": "scriptVar.run()",
            "webhelpfile": "16856.htm",
            "signature": "scriptVar.run()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function runs a script.",
            "details": "The scriptVar.run() function runs the script referenced by scriptVar. You can also run the script by using scriptVar().",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of the variable that references the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar.run()",
                "scriptVar()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "test8.run();",
                    "description": "Runs the script referenced by the variable test8.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "script.user.catalog()",
            "webhelpfile": "16862.htm",
            "signature": "for name in script.user.catalog() do body end",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function returns an iterator that can be used in a for loop to iterate over all the scripts stored in nonvolatile\u00a0memory.",
            "details": "This function accesses the catalog of scripts stored in nonvolatile memory, which allows you to process all scripts in nonvolatile memory. The entries are enumerated in no particular order.Each time the body of the function executes, name takes on the name of one of the scripts stored in nonvolatile memory. The for loop repeats until all scripts have been iterated.",
            "param_info": [
                {
                    "name": "name",
                    "description": "String representing the name of the script",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "body",
                    "description": "Code that implements the body of the for loop to process the names in the\u00a0catalog",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "for name in script.user.catalog() do body end"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "for name in script.user.catalog() do;   print(name);end;",
                    "description": "Retrieve the catalog listing for user scripts.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "scriptVar.save()",
            "webhelpfile": "16863.htm",
            "signature": "scriptVar.save(filename)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function saves the script to nonvolatile memory or to a USB flash drive.",
            "details": "The scriptVar.save() function saves a script to nonvolatile memory or a USB flash drive. The root folder of the USB flash drive has the absolute path /usb1/.If no filename is specified (the file name parameter is an empty string), the script is saved to internal nonvolatile memory. Only a script with filename defined can be saved to internal nonvolatile memory. If a filename is given, the script is saved to the USB flash drive.You can add the file extension, but it is not required. The only allowed extension is .tsp (see Example\u00a02).",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of variable that references the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "filename",
                    "description": "A string that contains the file name to use when saving the script to a USB\u00a0flash\u00a0drive",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar.save()",
                "scriptVar.save(filename)"
            ],
            "overloads": [
                "scriptVar.save()"
            ],
            "examples": [
                {
                    "example": "test8.save();",
                    "description": "Saves the script referenced by the variable test8 to nonvolatile memory.\n"
                },
                {
                    "example": "test8.save(\"/usb1/myScript.tsp\");",
                    "description": "Saves the script referenced by the variable test8 to a file named myScript.tsp on your USB flash drive.\n"
                }
            ],
            "related_commands": [
                "Save a user script"
            ]
        },
        {
            "name": "scriptVar.source",
            "webhelpfile": "16867.htm",
            "signature": "",
            "command_return": "code",
            "type": "Attribute (RW)(see Details)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "No\n",
            "description": "This attribute contains the source code of a script.",
            "details": "The loadscript or loadandrunscript and endscript keywords are not included in the source code. The body of the script is a single string with lines separated by the new line character.The instrument automatically stores the source for all scripts that are loaded on the instrument. To free up memory or to obfuscate the code, assign nil to the source attribute of the script. Although this attribute is writable, it can only be set to the nil value.",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of the variable that references the script that contains the source code",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "code",
                    "description": "A string that contains the body of the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "code = scriptVar.source",
                "scriptVar.source = nil"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "test7 = script.new(\"display.clear() display.settext('Hello\u00a0from\u00a0my\u00a0test')\", \"\");print(test7.source);",
                    "description": "This example creates a script called test7 that displays a message on the front panel and retrieves the source code.\n--- --Output:\n--- --display.clear() display.settext('Hello from my test')\n"
                }
            ],
            "related_commands": [
                "scriptVar.list()"
            ]
        },
        {
            "name": "scan.add()",
            "webhelpfile": "16890.htm",
            "signature": "scan.add(channelList, dmmConfig)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function adds channels to the scan list.",
            "details": "Use this function to add channels and channel patterns to the present scan list. If the scan list does not exist, it also creates a scan list. See scan.create() for information about creating a scan list.Channels and channel patterns added using this command are added to the end of the present list (appended) in the same order as specified in the channel list. In addition, the added channels are scanned in the order specified in channelList. Specifying multiple channels adds multiple steps to the scan.The configuration of each channel or channel pattern, which is associated with dmm.setconfig() and dmm.getconfig(), is used unless the optional dmmConfig parameter is specified. Specifying the dmmConfig parameter temporarily overrides the configuration associated with the channel or channel pattern. Specifying dmmConfig does not modify the assigned configuration of a channel or channel pattern.The scan list of channels (or channel patterns) is not updated if an error occurs during processing of the function. However, steps that were already added to the scan list are updated even if an error is detected, because each channel is added as a separate step when you add multiple channels to channelList.For digital I/O or totalizer channels, each created scan step instructs the scan to read the selected channel and then save the value into the specified reading buffer. If you do not specify a reading buffer, the channel is read but the value is not saved.The width parameter is valid for digital I/O type channels. Widths of 1, 2, 3, or 4 are supported. If specified, the scan can read up to four consecutive channels simultaneously, and then saves the resulting value into the specified reading buffer.DAC channels are not supported.Measurement timestamps may vary from channel read timestamps because of the way different channel types generate reading buffer timestamps.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying channels to add using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "dmmConfig",
                    "description": "String listing the DMM configuration to use with items in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "width",
                    "description": "Value that specifies the width of the channel read to use with items in channelList",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scan.add(channelList)",
                "scan.add(channelList, dmmConfig)",
                "scan.add(channelList, width)"
            ],
            "overloads": [
                "scan.add(channelList)",
                "scan.add(channelList, width)"
            ],
            "examples": [
                {
                    "example": "scan.create(\"3001:3010\", \"DCV\");",
                    "description": "For this example, assume DCV is a previously defined user configuration for dc volts. Clears the old scan list and creates a new scan list with each channel (1 to 10 on slot 3) using DCV as the overriding DMM configuration.\n"
                },
                {
                    "example": "scan.add(\"3001:3010\", \"2wire\");",
                    "description": "For this example, assume 2wire is a previously defined user configuration for 2-wire ohms. Uses 2wire for all 10 channels and adds them to the end of the existing scan list.\n"
                },
                {
                    "example": "scan.create(\"\");",
                    "description": "Clears the old scan list and creates a new empty scan list.\n"
                },
                {
                    "example": "for chan = 3001, 3010 do;   scan.add(\"\" .. chan, \"DCV\");   scan.add(\"\" .. chan, \"2wire\");end;",
                    "description": "For this example, assume DCV is a previously defined user dc volts configuration and 2wire is a previously defined user 2-wire ohms configuration. \n--- --Adds channels 3001 through 3010 to the end of the existing scan list. This loops through the channels twice, adding channels to the scan list twice. The first time, it adds DCV for a channel. The second time, it adds 2wire for that channel. The first parameter (\"\" .. chan) converts the chan number to a string.\n"
                }
            ],
            "related_commands": [
                "scan.create()",
                "dmm.getconfig()",
                "dmm.setconfig()",
                "Reading buffers",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.background()",
            "webhelpfile": "16891.htm",
            "signature": "scan.background(bufferVar)",
            "command_return": "state, scanCount, stepCount, reading",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function starts a scan and runs the scan in the background.",
            "details": "You can also use this function to specify the scanning reading buffer. This reading buffer, if specified, stores the readings and accompanying attributes as specified for the scan. An error is generated if the reading buffer does not exist or the parameter is not a reading buffer.Before using this command, use scan.create() and scan.add() or scan.addimagestep() to set up a scan list.When the scan is run in the background, you must use the scan.state() function to check the status of the scan.",
            "param_info": [
                {
                    "name": "state",
                    "description": "The result of scanning",
                    "enum": "scan.EMPTY 0|scan.BUILDING 1|scan.RUNNING 2|scan.ABORTED 3|scan.FAILED 4|scan.FAILED_INIT 5|scan.SUCCESS 6",
                    "type": "scanbackgroundstate",
                    "range": ""
                },
                {
                    "name": "scanCount",
                    "description": "This is current number scans completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "stepCount",
                    "description": "This is current number steps completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "reading",
                    "description": "If measurements are taken during the scan, this parameter contains the last scan reading completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "bufferVar",
                    "description": "The reading buffer used during scanning to store the readings; if a buffer is not specified, no readings are stored during the scan",
                    "enum": "",
                    "type": "bufferMethods",
                    "range": ""
                }
            ],
            "usage": [
                "state, scanCount, stepCount = scan.background()",
                "state, scanCount, stepCount, reading = scan.background()",
                "state, scanCount, stepCount, reading = scan.background(bufferVar)"
            ],
            "overloads": [
                "state, scanCount, stepCount = scan.background()",
                "state, scanCount, stepCount, reading = scan.background()"
            ],
            "examples": [
                {
                    "example": "scan.background(rbbuff1);",
                    "description": "Runs a scan in the background and stores readings in a buffer named rbbuff1.\n"
                }
            ],
            "related_commands": [
                "scan.add()",
                "scan.create()",
                "scan.execute()",
                "scan.list()",
                "scan.state()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.create()",
            "webhelpfile": "16892.htm",
            "signature": "scan.create(channelList, dmmConfig)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function deletes the existing scan list and creates a new list of channels and channel patterns to scan.",
            "details": "The existing scan list is lost after calling this function.The items in the channel list are scanned in the order listed.Each channel or channel pattern configuration is used unless the optional dmmConfig parameter is specified (see dmm.setconfig() and dmm.getconfig()). Specifying the dmmConfig parameter temporarily overrides the configuration associated with the channel or channel pattern. Specifying dmmConfig does not modify the assigned configuration of a channel or channel pattern.If a forbidden channel is included in a range of channels or slot parameter (such as slot 1), the forbidden channel is ignored and no error is generated. If a forbidden channel is individually specified in the channel list, an error is generated.If an error occurs, the scan list of channels or channel patterns is cleared, even though no new scan list is created.The function scan.reset() clears the list. To clear the scan list without performing a scan reset, send an empty string for the channelList parameter.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String specifying channels to add",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "dmmConfig",
                    "description": "The DMM configuration to use with items in the channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "scan.create(channelList)",
                "scan.create(channelList, dmmConfig)"
            ],
            "overloads": [
                "scan.create(channelList)"
            ],
            "examples": [
                {
                    "example": "scan.create(\"1001:1010\");",
                    "description": "Replaces the active scan list with an empty scan list.\n--- --Adds channels 1 through 10 on slot 1. Uses the existing DMM configuration (dmm.setconfig()).\n"
                },
                {
                    "example": "scan.create();for chan = 1001, 1010 do;   scan.add(\"\" .. chan);end;",
                    "description": "Replaces the active scan list with an empty scan list.\n--- --Loops through channels 1001 to 1010, and then adds 10 channels to the scan list. The parameter (\"\"\u00a0..\u00a0chan) converts the channel number to a string.\n--- --The scan list now has, in order, channels 1 through 10 on slot 1.\n--- --Uses the existing DMM configuration (dmm.setconfig()).\n"
                },
                {
                    "example": "scan.create(\"3001:3010\", \"testDCV\");",
                    "description": "For this example, assume testDCV is a previously defined user DC volts configuration.\n--- --Clears the old scan list and creates a new scan list with each channel (1 to 10 on slot\u00a03).\n--- --Each channel uses the DMM configuration associated with testDCV.\n"
                },
                {
                    "example": "scan.create(\"\");for chan = 3001, 3010 do;   scan.add(\"\" .. chan, \"testDCV\");   scan.add(\"\" .. chan, \"test2wire\");end;",
                    "description": "For this example, assume testDCV is a previously defined user DC volts configuration, and test2wire is a previously defined user 2-wire ohm configuration.\n--- --This loops through the channels, adding channels to the scan list. The first time, it adds \"testDCV\" for a channel. The second time, it adds \"test2wire\" for that channel. The first parameter (\"\" .. chan) converts the chan number to a string.\n--- --Clears the old scan list and creates a new scan list. \n--- --Loops through channels 3001 to 3010.\n--- --Adds channels 3001 through 3010 to the end of the existing scan list.\n"
                }
            ],
            "related_commands": [
                "dmm.getconfig()",
                "dmm.setconfig()",
                "scan.add()",
                "scan.reset()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.execute()",
            "webhelpfile": "16893.htm",
            "signature": "scan.execute(bufferVar)",
            "command_return": "state, scanCount, stepCount, reading",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function starts the scan immediately in the foreground with a configured scan list.",
            "details": "In addition to starting and running the scan in immediate mode (not in the background), you can use this function to specify the scanning reading buffer. This reading buffer stores the readings and accompanying attributes as specified for the scan. An error is generated if the reading buffer does not exist or if the parameter is not a reading buffer.Before using this command, use scan.create() and scan.add() or scan.addimagestep() to set up a scan list.Execution runs until the scan is complete or until the abort command is sent. Because this function waits for the scan to complete, the scan.state() function cannot be used to see the current status of scanning.",
            "param_info": [
                {
                    "name": "state",
                    "description": "The result of scanning",
                    "enum": "scan.EMPTY 0|scan.BUILDING 1|scan.RUNNING 2|scan.ABORTED 3|scan.FAILED 4|scan.FAILED_INIT 5|scan.SUCCESS 6",
                    "type": "scanexecutestate",
                    "range": ""
                },
                {
                    "name": "scanCount",
                    "description": "The present number of scans completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "stepCount",
                    "description": "The present number of steps completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "reading",
                    "description": "If measurements are taken during the scan, this parameter contains the last scan reading completed",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "bufferVar",
                    "description": "A reading buffer used during scanning to store the readings; if a buffer is not specified, no readings are stored during the scan",
                    "enum": "",
                    "type": "bufferMethods",
                    "range": ""
                }
            ],
            "usage": [
                "state, scanCount, stepCount, reading = scan.execute()",
                "state, scanCount, stepCount, reading = scan.execute(bufferVar)"
            ],
            "overloads": [
                "state, scanCount, stepCount, reading = scan.execute()"
            ],
            "examples": [
                {
                    "example": "scan.execute(rbBuff1);",
                    "description": "Runs a scan immediately and stores the readings in a reading buffer named rbbuff1.\n"
                }
            ],
            "related_commands": [
                "scan.add()",
                "scan.background()",
                "scan.create()",
                "scan.list()",
                "scan.state()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.list()",
            "webhelpfile": "16894.htm",
            "signature": "scan.list()",
            "command_return": "scanList",
            "type": "Function\n",
            "default_value": "Empty list\n",
            "tsp_link": "Yes\n",
            "description": "This function queries the active scan list.",
            "details": "When you change a channel or scan attribute for an existing scan list item, the scan list is recreated based on this change. If the scan list cannot be rebuilt, the scan list is lost.To avoid unintentional changes to an existing scan list, configure channel and scan settings before adding or creating a scan or step using the commands scan.add(), scan.addimagestep(), and scan.create().If the scan list is empty, the string \"Empty Scan\" is returned. Otherwise, the string lists each step in the scan along with its information for step, open, measure configuration, count, and close.",
            "param_info": [
                {
                    "name": "scanList",
                    "description": "A string that lists the existing scan step information",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "scanList = scan.list()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset();dmm.setconfig(\"2020, 2021\", \"dcvolts\");dmm.nplc = 0.5;dmm.range = 10;dmm.configure.set(\"DCVSlot2\");dmm.setconfig(\"2016,2017\", \"DCVSlot2\");scan.create(\"2007,2008,2020,2021,2016,2017\");print(scan.list());",
                    "description": "Assume a 3721 in slot 2.\n--- --Configure channels 20 and 21 for DC volts on slot 2.\n--- --Change the DMM settings for NPLC and range and save those DC volt settings as \"DCVSlot2\".\n--- --Configure channels 16 and 17 for \"DCVSlot2\" on slot 2.\n--- --Populate the scan list with the function scan.create(\"2007,2008,2020,2021,2016,2017\"), then initiate the scan list to be output.\n--- --Outputs the existing scan list. For example, an existing scan list may appear as follows:\n--- --Init) OPEN...\n--- --1) STEP: 2007\n--- --CLOSE: 2007\n--- --MEASURE: nofunction COUNT: 1\n--- --2) STEP: 2008\n--- --OPEN: 2007\n--- --CLOSE: 2008\n--- --MEASURE: nofunction COUNT: 1\n--- --3) STEP: 2020\n--- --OPEN: 2008\n--- --CLOSE: 2020 2911\n--- --MEASURE: dcvolts COUNT: 1\n--- --4) STEP: 2021\n--- --OPEN: 2020 2911\n--- --CLOSE: 2021 2921\n--- --MEASURE: dcvolts COUNT: 1\n--- --5) STEP: 2016\n--- --OPEN: 2021 2921\n--- --CLOSE: 2016 2911\n--- --MEASURE: DCVSlot2 COUNT: 1\n--- --6) STEP: 2017\n--- --OPEN: 2016\n--- --CLOSE: 2017\n--- --MEASURE: DCVSlot2 COUNT: 1\n"
                }
            ],
            "related_commands": [
                "scan.add()",
                "scan.addimagestep()",
                "scan.create()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.mode",
            "webhelpfile": "16895.htm",
            "signature": "",
            "command_return": "scanModeSetting",
            "type": "Attribute (RW)\n",
            "default_value": "0 (scan.MODE_OPEN_ALL)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the relay action when the scan starts.",
            "details": "When this attribute is set to open all, channels on all slots are opened before a scan starts. When this attribute is set to scan.MODE_OPEN_SELECTIVE, an intelligent open is performed. Assuming all steps being scanned have a function value of \"nofunction\" with their DMM configuration then:If any step has a DMM configuration with a function set to any other value than \"nofunction\":When this attribute is set to scan.MODE_FIXED_ABR, it is equivalent to setting MODE_OPEN_SELECTIVE, except:",
            "param_info": [
                {
                    "name": "scanModeSetting",
                    "description": "The present scan mode setting. Set to one of the following values",
                    "enum": "scan.MODE_OPEN_ALL 0|scan.MODE_OPEN_SELECTIVE 1|scan.MODE_FIXED_ABR 2",
                    "type": "scanmodescanModeSetting",
                    "range": ""
                }
            ],
            "usage": [
                "scanModeSetting = scan.mode",
                "scan.mode = scanModeSetting"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.mode = scan.MODE_OPEN_SELECTIVE;",
                    "description": "Sets the scan mode setting to open channels that are used in the scan.\n"
                }
            ],
            "related_commands": [
                "scan.reset()",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.reset()",
            "webhelpfile": "16896.htm",
            "signature": "scan.reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets the trigger model and scan list settings to their factory default settings.",
            "details": "When scan.reset() is sent, the trigger model and scan settings that are reset to the factory defaults are:In addition, the scan list is cleared.",
            "param_info": [],
            "usage": [
                "scan.reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.reset();",
                    "description": "Performs a reset on the trigger model and scan settings.\n"
                }
            ],
            "related_commands": [
                "channel.reset()",
                "dmm.reset()",
                "reset()",
                "scan.bypass",
                "scan.measurecount",
                "scan.mode",
                "scan.scancount",
                "scan.trigger.arm.stimulus",
                "scan.trigger.channel.stimulus",
                "scan.trigger.measure.stimulus",
                "scan.trigger.sequence.stimulus",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.bypass",
            "webhelpfile": "16973.htm",
            "signature": "",
            "command_return": "bypass",
            "type": "Attribute (RW)\n",
            "default_value": "1 (scan.ON)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates whether the first channel of the scan waits for the channel stimulus event to be satisfied before closing.",
            "details": "When bypass is set to on and the scan.trigger.arm.stimulus is set to a nonzero value, the first channel of the scan closes (the scan.trigger.channel.stimulus setting is ignored).For other channels (other than the first), the channel stimulus must be satisfied before the channel action takes place.When bypass is set to off, every channel (including the first) must satisfy the scan.trigger.channel.stimulus setting before the channel action occurs for that step.",
            "param_info": [
                {
                    "name": "bypass",
                    "description": "Enable or disable the bypass",
                    "enum": "scan.OFF 0|scan.ON 1",
                    "type": "scanbypassbypass",
                    "range": ""
                }
            ],
            "usage": [
                "bypass = scan.bypass",
                "scan.bypass = bypass"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.bypass = scan.OFF;print(scan.bypass);",
                    "description": "Disables the bypass option for scanning and displays the present bypass state.\n--- --Output:\n--- --0.000000000e+000\n"
                }
            ],
            "related_commands": [
                "scan.trigger.arm.stimulus",
                "scan.trigger.channel.stimulus",
                "Scanning and triggering"
            ]
        },
        {
            "name": "scan.scancount",
            "webhelpfile": "16974.htm",
            "signature": "",
            "command_return": "scanCount",
            "type": "Attribute (RW)\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the number of times the scan is repeated.",
            "details": "The scan count attribute setting indicates how many times the scan list is iterated through before the scan completes.During a scan, the instrument iterates through the arm layer of the trigger model the specified number of times. After performing the specified number of iterations, the instrument returns to an idle state.",
            "param_info": [
                {
                    "name": "scanCount",
                    "description": "The scan count value (1 to 2,000,000,000)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 2,000,000,000)"
                }
            ],
            "usage": [
                "scanCount = scan.scancount",
                "scan.scancount = scanCount"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.create(\"1001:1009\");scan.scancount = 100;scan.scaninterval = 1.0 -- delay between scans;",
                    "description": "Create a scan that includes channels 1 to 9 of slot 1.\n--- --Set the scan count to 100.\n--- --Set the delay between scans to 1\u00a0s.\n"
                }
            ],
            "related_commands": [
                "Scanning and triggering",
                "Trigger model"
            ]
        },
        {
            "name": "scan.trigger.channel.stimulus",
            "webhelpfile": "16976.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Attribute (RW)\n",
            "default_value": "50 (scan.trigger.EVENT_SEQUENCE_COMP)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute determines which trigger events cause the channel actions to occur.",
            "details": "This attribute selects which events cause the channel event detector to enter the detected state. Set this attribute to 0 to start the channel action immediately at the default setting.Set eventID to one of the existing trigger event IDs shown in the following table.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "Trigger stimulus used for the channel action; see Details for possible trigger event\u00a0IDs",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "eventID = scan.trigger.channel.stimulus",
                "scan.trigger.channel.stimulus = eventID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.channel.stimulus = scan.trigger.EVENT_SCAN_START;",
                    "description": "Sets the trigger stimulus of the channel event detector to scan start event.\n"
                },
                {
                    "example": "scan.trigger.channel.stimulus = 0;print(scan.trigger.channel.stimulus);",
                    "description": "Starts the channel action immediately after the Scan Start Event. This also resets the stimulus to the default.\n--- --Output:\n--- --5.000000000e+01\n"
                }
            ],
            "related_commands": [
                "scan.trigger.channel.clear()",
                "scan.trigger.channel.set()",
                "Scanning and triggering",
                "Trigger model",
                ""
            ]
        },
        {
            "name": "scan.trigger.clear()",
            "webhelpfile": "16977.htm",
            "signature": "scan.trigger.clear()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the trigger model.",
            "details": "This function sets the arm, channel, measurement, and sequence event detectors of the trigger model to the undetected state.",
            "param_info": [],
            "usage": [
                "scan.trigger.clear()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "scan.trigger.clear();",
                    "description": "Clears the trigger model.\n"
                }
            ],
            "related_commands": [
                "scan.trigger.channel.set()",
                "scan.trigger.channel.stimulus",
                "Scanning and triggering",
                "Trigger model"
            ]
        },
        {
            "name": "localnode.reset()",
            "webhelpfile": "16978.htm",
            "signature": "localnode.reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets the local node instrument.",
            "details": "If you want to reset a specific instrument or a subordinate node, use the node[X].reset() command.A local node reset includes a channel.reset(\"allslots\"), dmm.reset(\"all\") and a scan.reset(). In addition:A localnode.reset() is different than a reset() because reset() resets the entire system. When using this command from a remote node, localnode should be replaced with the node reference, for example node[5].reset().",
            "param_info": [],
            "usage": [
                "localnode.reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "localnode.reset();",
                    "description": "Resets the local node.\n"
                }
            ],
            "related_commands": [
                "channel.reset()",
                "dmm.reset()",
                "reset()",
                "scan.reset()"
            ]
        },
        {
            "name": "comm.lan.web.enable",
            "webhelpfile": "17009.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "true (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes whether or not communication using the web interface is enabled.",
            "details": "This performs the same function as the MENU > LAN > ENABLE > WEB option that is available through the front panel of the instrument.",
            "param_info": [
                {
                    "name": "state",
                    "description": "true",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "state = comm.lan.web.enable",
                "comm.lan.web.enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "comm.lan.enable = true;comm.lan.web.enable = false;",
                    "description": "Enable all LAN communication with instrument, then disable only web communication over the LAN.\n"
                }
            ],
            "related_commands": [
                "comm.lan.enable",
                "comm.lan.rawsockets.enable",
                "comm.lan.telnet.enable",
                "comm.lan.vxi11.enable"
            ]
        },
        {
            "name": "comm.lan.telnet.enable",
            "webhelpfile": "17011.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "true (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes whether or not communication using Telnet is enabled.",
            "details": "This performs the same function as the MENU > LAN > ENABLE > TELNET option that is available through the front panel of the instrument.",
            "param_info": [
                {
                    "name": "state",
                    "description": "true",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "state = comm.lan.telnet.enable",
                "comm.lan.telnet.enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "comm.lan.enable = true;comm.lan.telnet.enable = false;",
                    "description": "Enable all LAN communication with instrument, then disable only Telnet over the LAN.\n"
                }
            ],
            "related_commands": [
                "comm.lan.enable",
                "comm.lan.rawsockets.enable",
                "comm.lan.vxi11.enable",
                "comm.lan.web.enable",
                "lan.status.port.telnet",
                "Telnet connection"
            ]
        },
        {
            "name": "comm.lan.vxi11.enable",
            "webhelpfile": "17014.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "true (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes whether or not communication using a VXI-11 connection is enabled.",
            "details": "This performs the same function as the MENU > LAN > ENABLE > VXI11 option that is available through the front panel of the instrument.",
            "param_info": [
                {
                    "name": "state",
                    "description": "true",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "state = comm.vxi11.enable",
                "comm.vxi11.enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "comm.lan.enable = true;comm.lan.vxi11.enable = false;",
                    "description": "Enable all LAN communication with instrument, then disable only VXI\u201111 over the LAN.\n"
                }
            ],
            "related_commands": [
                "comm.lan.enable",
                "comm.lan.rawsockets.enable",
                "comm.lan.telnet.enable",
                "comm.lan.web.enable",
                "lan.status.port.vxi11",
                "VXI-11 connection"
            ]
        },
        {
            "name": "comm.lan.rawsockets.enable",
            "webhelpfile": "17016.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "true (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes whether or not communication using raw socket is enabled.",
            "details": "This performs the same function as the MENU > LAN > ENABLE > RAW option available through the front panel of the instrument.",
            "param_info": [
                {
                    "name": "state",
                    "description": "true",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "state = comm.lan.rawsockets.enable",
                "comm.lan.rawsockets.enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "comm.lan.enable = true;comm.lan.rawsockets.enable = false;",
                    "description": "Enable all LAN communication with instrument, then disable only raw sockets over the LAN.\n"
                }
            ],
            "related_commands": [
                "comm.lan.enable",
                "comm.lan.telnet.enable",
                "comm.lan.vxi11.enable",
                "comm.lan.web.enable",
                "lan.status.port.rawsocket",
                "Raw socket connection"
            ]
        },
        {
            "name": "comm.gpib.enable",
            "webhelpfile": "17023.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "true (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes whether or not communication using the GPIB connection is enabled.",
            "details": "This performs the same function as the MENU > GPIB > ENABLE option that is available through the front panel of the instrument.",
            "param_info": [
                {
                    "name": "state",
                    "description": "true",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "state = comm.gpib.enable",
                "comm.gpib.enable = state"
            ],
            "overloads": [],
            "examples": [],
            "related_commands": [
                "Set the GPIB address"
            ]
        },
        {
            "name": "script.anonymous",
            "webhelpfile": "17040.htm",
            "signature": "",
            "command_return": "scriptVar",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "No\n",
            "description": "This is a reference to the anonymous script.",
            "details": "You can use the script.anonymous script like any other script. Also, you can save the anonymous script as a user script by giving it a name.This script is replaced by loading a script with the loadscript or loadandrunscript commands when they are used without a name. ",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of the variable that references the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar = script.anonymous"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "script.anonymous.list();",
                    "description": "Displays the content of the anonymous\u00a0script.\n"
                },
                {
                    "example": "print(script.anonymous.source);",
                    "description": "Retrieves the source of the anonymous\u00a0script.\n"
                }
            ],
            "related_commands": [
                "Anonymous scripts",
                "scriptVar.autorun",
                "scriptVar.list()",
                "scriptVar.name",
                "scriptVar.run()",
                "scriptVar.save()",
                "scriptVar.source"
            ]
        },
        {
            "name": "display.getlastkey()",
            "webhelpfile": "17047.htm",
            "signature": "display.getlastkey()",
            "command_return": "keyCode",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function retrieves the key code for the last pressed key.",
            "details": "A history of the key code for the last pressed front\u2011panel key is maintained by the instrument. When the instrument is turned on, or when it is transitioning from local to remote operation, the key code is set to 0 (display.KEY_NONE).Pressing the EXIT (LOCAL) key normally aborts a script. To use this function with the EXIT (LOCAL) key, you must set display.locallockout to display.LOCK.The table below lists the keyCode value for each front\u2011panel action.",
            "param_info": [
                {
                    "name": "keyCode",
                    "description": "A returned value that represents the last front-panel key pressed; see Details for more information",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "keyCode = display.getlastkey()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "key = display.getlastkey();print(key);",
                    "description": "On the front panel, press the MENU key and then send the code shown here. This retrieves the key code for the last pressed key.\n--- --Output:\n--- --6.80000e+01\n"
                }
            ],
            "related_commands": [
                "display.locallockout",
                "display.sendkey()"
            ]
        },
        {
            "name": "display.sendkey()",
            "webhelpfile": "17055.htm",
            "signature": "display.sendkey(keyCode)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function sends a code that simulates the action of a front\u2011panel control.",
            "details": "This command simulates pressing a front\u2011panel key or navigation wheel, or turning the navigation wheel one click to the left or right.",
            "param_info": [
                {
                    "name": "keyCode",
                    "description": "A parameter that specifies the key press to simulate; see Details for more information",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "display.sendkey(keyCode)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "display.sendkey(display.KEY_RUN);",
                    "description": "Simulates pressing the RUN key.\n"
                }
            ],
            "related_commands": [
                "Front-panel operation"
            ]
        },
        {
            "name": "bufferVar.cachemode",
            "webhelpfile": "17109.htm",
            "signature": "",
            "command_return": "cacheMode",
            "type": "Attribute (RW)\n",
            "default_value": "1 (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute enables or disables the reading buffer cache (on or off).",
            "details": "Assigning a value to this attribute enables or disables the reading buffer cache. When enabled, the reading buffer cache improves access speed to reading buffer data. If you run successive operations that overwrite reading buffer data, the reading buffer may return stale cache data. To avoid this, make sure that you include commands that automatically invalidate the cache as needed (for example, explicit calls to the bufferVar.clearcache() function) or disable the cache using this attribute (bufferVar.cachemode).",
            "param_info": [],
            "usage": [
                "cacheMode = bufferVar.cachemode",
                "bufferVar.cachemode = cacheMode"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "buffer1.cachemode = 1;",
                    "description": "Enables reading buffer cache.\n"
                }
            ],
            "related_commands": [
                "bufferVar.clearcache()",
                "Reading buffers"
            ]
        },
        {
            "name": "channel.createspecifier()",
            "webhelpfile": "17222.htm",
            "signature": "channel.createspecifier(slotX, bank, row, column)",
            "command_return": "specifier",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function creates a string channel descriptor from a series of card-dependent integer arguments.",
            "details": "The arguments are dependent upon the card type in the specified slot. This command can only create valid channel descriptors; if an illegal argument is sent for the type of card in the specified slot, an error is generated.",
            "param_info": [
                {
                    "name": "X",
                    "description": "The slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                },
                {
                    "name": "bank",
                    "description": "The bank number (if applicable)",
                    "enum": "",
                    "type": "number",
                    "range": "(if applicable)"
                },
                {
                    "name": "row",
                    "description": "The row number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "column",
                    "description": "The column number",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "index",
                    "description": "The index",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "backplane",
                    "description": "The backplane",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "specifier = channel.createspecifier(slotX, bank, row, column)",
                "specifier = channel.createspecifier(slotX, bank, column)",
                "specifier = channel.createspecifier(slotX, bank, index)",
                "specifier = channel.createspecifier(slotX, index)",
                "specifier = channel.createspecifier(slotX, backplane)"
            ],
            "overloads": [
                "specifier = channel.createspecifier(slotX, index)",
                "specifier = channel.createspecifier(slotX, backplane)",
                "specifier = channel.createspecifier(slotX, bank, index)",
                "specifier = channel.createspecifier(slotX, bank, column)"
            ],
            "examples": [
                {
                    "example": "cd = channel.createspecifier(3, 1, 2, 101);print(cd);",
                    "description": "Creates a channel descriptor on the Model 3732 card configured as a single 4x112 matrix in slot 3, bank 1, row 2, column 101.\n--- --Output:\n--- --312A1\n"
                },
                {
                    "example": "for row = 1,8 do;   for col = 1,28 do;      ch = channel.createspecifier(1,1,row,col);      channel.setpole(ch, 2);   end;end;",
                    "description": "Sets the pole setting to 2 for all channels in bank 1 on a Model 3732 card configured as a dual 8x28 matrix in slot 1.\n"
                },
                {
                    "example": "cd = createspecifier(2, 2, 1);print(cd);",
                    "description": "Creates a channel descriptor on the Model 3724 multiplexer card in slot 2, bank 2, index 1.\n--- --Output:\n--- --2031\n"
                },
                {
                    "example": "cd = createspecifier(1, 911);print(cd);",
                    "description": "Creates a channel descriptor on the Model 3724 multiplexer card in slot 1, backplane 911.\n--- --Output:\n--- --1911\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "channel.close()",
            "webhelpfile": "17229.htm",
            "signature": "channel.close(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function closes the channels, analog backplane relays, and channel patterns that are specified by the channel list parameter. ",
            "details": "Channels closed with this command are appended to the already closed channels (no previously closed channels are opened by this command).The channelList parameter can include channels with analog backplane relays. If this is the case, channel.close closes the specified channels and any associated analog backplane relays. For channel patterns, the analog backplane relays that are closed are the ones that were specified when the pattern was created. However, for channels, they are the ones specified with the channel.setbackplane() function. Another option for closing analog backplane relays with this command is to include them in the channelList parameter.This command has no effect on how the DMM is configured.Actions associated with this function include:This command is not available for digital I/O, DAC, and totalizer channels. Calling on a specific channel generates an error. If the digital I/O, DAC, or totalizer channel is in the range of channels, the channel is ignored.An error is generated if:Once an error is detected, the command stops processing and no channels are closed.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "The channels, analog backplane relays, and channel patterns to close, using standard channel naming",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.close(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.close(\"1001:1005, 3003, Chans\");",
                    "description": "Close channels 1 to 5 on slot 1, channel 3 on slot 3, and the channel pattern or label Chans.\n"
                }
            ],
            "related_commands": [
                "channel.exclusiveclose()",
                "channel.exclusiveslotclose()",
                "channel.getclose()",
                "channel.open()",
                "channel.getimage()",
                "channel.getstate()",
                "channel.pattern.getimage()",
                "channel.pattern.snapshot()",
                "channel.pattern.setimage()",
                "channel.setbackplane()",
                "channel.setdelay()",
                "dmm.close()"
            ]
        },
        {
            "name": "errorqueue.next()",
            "webhelpfile": "17242.htm",
            "signature": "errorqueue.next()",
            "command_return": "errorCode, message, severity, errorNode",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function reads the oldest entry from the error queue and removes it from the queue.",
            "details": "Entries are stored in a first-in, first-out (FIFO) queue. This function reads the oldest entry and removes it from the queue.Error codes and messages are listed in the Error summary list.If there are no entries in the queue, code 0, Queue is Empty, is returned.In an expanded system, each TSP\u2011Link enabled instrument is assigned a node number. The variable errorNode stores the node number where the error originated. ",
            "param_info": [
                {
                    "name": "errorCode",
                    "description": "The error code number for the entry",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "message",
                    "description": "The message that describes the error code",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "severity",
                    "description": "The severity level (0, 10, 20, 30, or 40); see Details for more information",
                    "enum": "",
                    "type": "string",
                    "range": "(0, 10, 20, 30, or 40)"
                },
                {
                    "name": "errorNode",
                    "description": "The node number where the error originated",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "errorCode, message, severity, errorNode = errorqueue.next()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "errorcode, message = errorqueue.next();print(errorcode, message);",
                    "description": "Reads the oldest entry in the error queue. The output below indicates that the queue is empty.\n--- --Output:\n--- --0.00000e+00 Queue Is Empty\n"
                }
            ],
            "related_commands": [
                "Error Available Bit (Error or Event queue)",
                "errorqueue.clear()",
                "errorqueue.count",
                "Error summary list"
            ]
        },
        {
            "name": "channel.getclose()",
            "webhelpfile": "17247.htm",
            "signature": "channel.getclose(channelList)",
            "command_return": "closed",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function queries for the closed channels indicated by the channel list parameter.",
            "details": "Use this command to return a list of closed measurement channels, including the paired channel for 4-wire measurements. It does not return nonmeasurement channels.If more than one channel is closed, they are comma\u2011delimited in the string. If channelList equals \"slotX\" (where X is 1 to 6), the response indicates the channels and backplane relays that are closed on that slot. Similarly, if channelList equals \"allslots\", the response indicates all channels and analog backplane relays that are closed in the instrument. The format of each channel returned is slot, row, column (matrix channels) or slot, channel (MUX channels). When the channelList contains a channel pattern, only the closed channels in that image are returned.You can use \"allslots\" to query for all channels closed. The instrument returns only information for valid slots and channels.An error message is generated if an empty parameter string is specified or if the specified channel list contains no valid channels that can be closed.If none of the channels in the channel list is closed, nil is returned.",
            "param_info": [
                {
                    "name": "closed",
                    "description": "A string listing the channels that are presently closed in the specified channel list parameter",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "A string representing the channels, channel patterns, and backplane relays that will be queried",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "closed = channel.getclose(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setpole(\"slot5\", 4);channel.setbackplane(\"slot5\", \"5911, 5922\");channel.close(\"5003, 5005\");closedSlot5 = channel.getclose(\"slot5\");print(closedSlot5);",
                    "description": "Configure the channel on slot 5 to be four-pole.\n--- --Associate the slot 5 channels with analog backplane relays 911 and 922 on slot 5.\n--- --Close channels 3 and 5 on slot 5.\n--- --Gets the channels and analog backplane relays that are closed on slot 5 and output the closed channels on slot 5.\n--- --Output:\n--- --5003(5033);5055(5035);5911;5922\n"
                },
                {
                    "example": "allClosed = channel.getclose(\"allslots\");",
                    "description": "Gets all channels and analog backplane relays that are closed in the instrument.\n"
                },
                {
                    "example": "closedChans = channel.getclose(\"Chans\");",
                    "description": "Gets all channels closed in a pattern called \"Chans\".\n"
                },
                {
                    "example": "closedRange = channel.getclose(\"3001:3020\");",
                    "description": "Gets all channels that are closed on channels 1 to 20 on slot 3.\n"
                },
                {
                    "example": "closedOnes = channel.getclose(\"3001, 3002, ;3003, 3005, 3911, 3912\");",
                    "description": "Gets all channels that are closed on channels 1, 2, 3, 5 and analog backplane relay 1 and 2 in bank 1 on slot\u00a03.\n"
                }
            ],
            "related_commands": [
                "channel.close()",
                "channel.exclusiveclose()",
                "channel.getstate()",
                "channel.open()",
                "Data retrieval commands"
            ]
        },
        {
            "name": "channel.reset()",
            "webhelpfile": "17280.htm",
            "signature": "channel.reset(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets the specified channel list items to factory default settings.",
            "details": "For the items specified in channelList, the following actions occur:Using this function to reset a channel or backplane relay involved in scanning invalidates the existing scan list. The list has to be recreated before scanning again.For all channels, any trigger settings are removed.For digital I/O channels, operation is set to input, the match is set to zero (0), and auto\u2011protect is turned on.For totalizer channels, operation is set to falling edge and TTL level.For DAC channels, output is turned off and auto\u2011protect is turned on. Operation is set to \u201312\u00a0V to + 12\u00a0V.The rest of the instrument settings are unaffected. To reset the entire system to factory default settings, use the reset() command.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the items to reset; the string can include",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.reset(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.reset(\"allslots\");",
                    "description": "Performs a reset operation on all channels on the instrument.\n"
                },
                {
                    "example": "channel.reset(\"slot1\");",
                    "description": "Resets channels on slot 1 only.\n"
                },
                {
                    "example": "channel.reset(\"3001:3005\");",
                    "description": "Resets only channels 1 to 5 on slot 3.\n"
                },
                {
                    "example": "channel.reset(\"5005, 5915\");",
                    "description": "Resets only channel 5 and analog backplane relay 5 in bank 1 on slot 5.\n"
                }
            ],
            "related_commands": [
                "Channel",
                "channel.setbackplane()",
                "dmm.reset()",
                "reset()",
                "scan.reset()"
            ]
        },
        {
            "name": "channel.pattern.getimage()",
            "webhelpfile": "17284.htm",
            "signature": "channel.pattern.getimage(name)",
            "command_return": "channelList",
            "type": "Function\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This function queries a channel pattern for associated channels and analog backplane relays.",
            "details": "The returned string lists the channels in the slot, column or slot, row, column format, even if a channel pattern was used to create it. Results for multiple channel patterns are delimited by a semicolon (;). Commas delimit the specific channels and analog backplane relays in a single channel pattern in the string.If you change a pole setting for a channel that is associated with a channel pattern, the channel pattern is deleted. Be sure to configure the pole setting for channels (channel.setpole) before creating a channel pattern.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string specifying a list of channels and analog backplane relays that are represented by the name",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "A string representing the name of the channel pattern to query",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channelList = channel.pattern.getimage(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "-- Set up two patterns;channel.pattern.setimage(\"4001:4005\", \"myPattern\") ;channel.pattern.setimage(\"2001,2003,2005\", \"myRoute\") ;\u00a0;-- Print images;myImage = channel.pattern.getimage(\"myPattern\") ;print(myImage) ;print(channel.pattern.getimage(\"myRoute\"));print(channel.pattern.getimage(\"myRoute,;   myPattern\"));",
                    "description": "Using a Model 3721 (or similar model) card in slots 2 and 4, this example creates two channel patterns and then queries these patterns.\n--- --Output:\n--- --4001,4002,4003,4004,4005\n--- --2001,2003,2005\n--- --2001,2003,2005;4001,4002,4003,4004,4005\n"
                }
            ],
            "related_commands": [
                "channel.pattern.catalog()",
                "channel.pattern.delete()",
                "channel.pattern.setimage()",
                "channel.setpole()"
            ]
        },
        {
            "name": "channel.pattern.setimage()",
            "webhelpfile": "17296.htm",
            "signature": "channel.pattern.setimage(channelList, name)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This function creates a channel pattern and associates it with the specified name.",
            "details": "If name is used for an existing channel pattern, that pattern is overwritten with the new pattern channel image (if no errors occur). The previous image associated with the name is lost. The DMM configuration associated with the pattern remains unchanged in this scenario.The channel pattern is not created if an error is detected. You can create a channel pattern with an empty channelList parameter. This will create a pattern that has no channels or analog backplane relays associated with it. The behavior of using an empty pattern in a channel list parameter is dependent on the command. For example:A channel pattern must include the analog backplane relays and the channels. Once a channel pattern is created, the only way to add a channel or analog backplane relay to an existing pattern is to delete the old pattern and recreate the pattern with the new items.If you change a pole setting for a channel that is associated with a channel pattern, the channel pattern is deleted. Be sure to configure the pole setting for channels (channel.setpole) before creating a channel pattern.Channel patterns are stored when you run the createconfigscript() command or setup.save() command.Channel patterns are lost when power is cycled. Use setup.recall() or a script created with createconfigscript() to restore them.Including any channels of type digital I/O, DAC, and totalizer generates an error.The following restrictions exist when naming a channel pattern:Examples of valid names:Examples of invalid names:An error is generated if:",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string listing the channels, channel patterns, or analog backplane relays to use when creating the new channel\u00a0pattern",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "A string representing the name to associate with the new channel pattern",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.pattern.setimage(channelList, name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.pattern.setimage(\"3001:3010\", \"Channels\");oldList = channel.pattern.getimage(\"Channels\");newList = oldList .. \", 3911\";channel.pattern.delete(\"Channels\");channel.pattern.setimage(newList, \"Channels\");channel.open(\"slot3\");channel.close(\"Channels\");print(channel.getclose(\"slot3\"));",
                    "description": "For this example, assume there is a Keithley Model 3721 or similar card in slot\u00a03.\n--- --Create a pattern.\n--- --Append a channel to the pattern by retrieving the pattern and recreating it.\n--- --Recreate the pattern with the new image.\n--- --Open all channels on slot\u00a03 and close the pattern Channels.\n--- --Output:\n--- --3001;3002;3003;3004;3005;3006;3007;3008;3009;3010;3911\n"
                },
                {
                    "example": "channel.pattern.setimage(\"3001:3010\", \"Channels\");channel.open(\"slot3\");channel.close(\"Channels, 3911\");print(channel.getclose(\"slot3\"));",
                    "description": "An alternate solution to the example above is to create the pattern, then add the analog backplane relay when you close the channel. This eliminates the need to get the image, delete the image and recreate it.\n--- --Output:\n--- --3001;3002;3003;3004;3005;3006;\n--- --3007;3008;3009;3010;3911\n"
                }
            ],
            "related_commands": [
                "createconfigscript()",
                "channel.pattern.catalog()",
                "channel.pattern.delete()",
                "channel.pattern.getimage()",
                "channel.pattern.snapshot()",
                "channel.setpole()",
                "setup.save()",
                "setup.recall()"
            ]
        },
        {
            "name": "channel.pattern.snapshot()",
            "webhelpfile": "17299.htm",
            "signature": "channel.pattern.snapshot(name)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This function creates a channel pattern.",
            "details": "This command stores an image of presently closed channels and analog backplane relays and associates them with the name parameter.If name is already used for an existing channel pattern, that pattern is overwritten with the new pattern channel image (if no errors occur). The DMM configuration associated with the pattern remains unchanged.The following restrictions exist when naming a channel pattern:Examples of valid names:Examples of invalid names:An error is generated if:Issuing this function on an existing pattern invalidates the existing scan list (the pattern may or may not be used in the current scan list). Creating a new pattern does not invalidate the existing scan list.Channels of type DAC, totalizer, and digital I/O are ignored.Channel patterns are stored when you run the createconfigscript() command or setup.save() command.Channel patterns are lost when power is cycled. Use setup.recall() or a script created with createconfigscript() to restore them.If you change a pole setting for a channel that is associated with a channel pattern, the channel pattern is deleted. Be sure to configure the pole setting for channels (channel.setpole) before creating a channel pattern.",
            "param_info": [
                {
                    "name": "name",
                    "description": "A string representing the name to associate with the present state of channels and analog backplane relays",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.pattern.snapshot(name)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.pattern.snapshot(\"voltagePath\");",
                    "description": "Creates a pattern named voltagePath that contains the presently closed channels and analog backplane relays.\n"
                }
            ],
            "related_commands": [
                "createconfigscript()",
                "channel.pattern.catalog()",
                "channel.pattern.delete()",
                "channel.pattern.getimage()",
                "channel.pattern.setimage()",
                "channel.setpole()",
                "setup.save()",
                "setup.recall()"
            ]
        },
        {
            "name": "channel.getcount()",
            "webhelpfile": "17384.htm",
            "signature": "channel.getcount(channelList)",
            "command_return": "counts",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the number of times the relays have been closed for the specified channels.",
            "details": "The Series 3700A keeps an internal count of the number of times each relay has been closed. This count can help you determine when relays require replacement. Refer to the plug-in card documentation for the contact life specifications for the relays. The closure counts for an analog backplane relay can be included in the channelList parameter. If channelList includes a pattern, you can use channel.pattern.getimage() with the pattern name to see the channel order and the channels to which the close counts pertain.If channels are specified, the count values are returned in the order in which the channels are specified. If slots are specified, the response lists the channels starting from lowest to highest. Because each slot is processed completely before going to the next, all slot 1 channels and analog backplane relays are listed before slot 2 channels.Relay closures are counted only when a relay cycles from open to closed state.It is good practice to get the relay count at the end of a program. This saves the latest count to memory.An error is generated if:",
            "param_info": [
                {
                    "name": "counts",
                    "description": "A comma-delimited string that lists the number of times the channel has closed",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "A string listing the items to query, which can include",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "counts = channel.getcount(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "counts = channel.getcount(\"2001:2005\");print(counts);",
                    "description": "Gets the close counts for channels 1 to 5 on slot 2.\n--- --Example output for channels 2001, 2002, 2003, 2004, and 2005:\n--- --672,495,547,479,518\n"
                },
                {
                    "example": "counts = channel.getcount(\"slot2\");print(counts);",
                    "description": "Get the close counts for all channels and analog backplane relays on slot 2 assuming a 3721 card is installed in the slot.\n--- --Sample output that shows the counts for channels 1 to 41, analog backplane relays 911 to 917, analog backplane relays 921 to 928:\n--- --672,495,547,479,518,459,522,599,452,451,464,427,426,428,426,425,428,424,424,425,5,3,3,3,4,3,3,5,3,33,33,33,33,33,33,32,32,32,32,32,119,3,56,0,0,0,0,0,0,14,68,0,0,0,0,16,0\n"
                },
                {
                    "example": "channel.pattern.setimage(\"2003, 2005, 2023, 2915\", \"Path\");PathList = channel.pattern.getimage(\"Path\");print(PathList);print(channel.getcount(PathList));print(channel.getcount(\"Path\"));",
                    "description": "Create a pattern called Path, then get the close counts for channels and analog backplane relays in channel pattern called \"Path\"\n--- --Sample output:\n--- --2003, 2005,2023,2915\n--- --547,518,3,0\n--- --547,518,3,0\n"
                }
            ],
            "related_commands": [
                "channel.pattern.getimage()",
                "channel.pattern.setimage()",
                "Data retrieval commands"
            ]
        },
        {
            "name": "channel.setforbidden()",
            "webhelpfile": "17402.htm",
            "signature": "channel.setforbidden(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "Not forbidden\n",
            "tsp_link": "Yes\n",
            "description": "This function prevents the closing of specified channels and analog backplane relays.",
            "details": "The channelList parameter indicates the scope of channels affected and may include:This function prevents all items contained in the channel list parameter from closing. It applies the \"forbidden to close\" attribute to the specified channels. To remove the \"forbidden to close\" attribute, use channel.clearforbidden().If a channel that is being set to forbidden is used in a channel pattern, the channel pattern is deleted when the channel or analog backplane relay is set to forbidden. Note that if the channelList parameter includes a channel pattern, the channel pattern will be deleted when the channels in the patterns are successfully set to forbidden to close.The channels or analog backplane relays in the channelList parameter must be installed in the instrument.If the scan list contains a channel or analog backplane relay that is forbidden, the scan list is invalidated.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the channels and analog backplane relays to make forbidden to close",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setforbidden(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setforbidden(\"2002,2004,2006,2008\");",
                    "description": "Marks channels 2, 4, 6, and 8 of slot 2 as forbidden to close.\n"
                }
            ],
            "related_commands": [
                "channel.clearforbidden()",
                "channel.getforbidden()"
            ]
        },
        {
            "name": "channel.getforbidden()",
            "webhelpfile": "17404.htm",
            "signature": "channel.getforbidden(channelList)",
            "command_return": "forbiddenList",
            "type": "Function\n",
            "default_value": "Permitted to close\n",
            "tsp_link": "Yes\n",
            "description": "This function returns a string listing the channels and analog backplane relays in the channel list that are forbidden to close.",
            "details": "The channelList parameter indicates which channels to check, and may include:If there are no channels in the scope of the channelList that are on the forbidden list, the string returned is empty or nil. The format of the channels in the response string is slot, channel for multiplexer channels or slot, row, column for matrix channels.",
            "param_info": [
                {
                    "name": "forbiddenList",
                    "description": "Comma-delimited string listing the channels and analog backplane relays in the channel list that are forbidden to close",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "A string listing the channels, backplane relays, and channel patterns that are to be checked to see if they are forbidden to close",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "forbiddenList = channel.getforbidden(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "Forbidden = channel.getforbidden(\"allslots\");",
                    "description": "Query for the channels and analog backplane relays that are forbidden to close in the instrument.\n"
                },
                {
                    "example": "channel.setforbidden(\"3003, 3005, 3925\");Forbidden = channel.getforbidden(\"slot3\");print(Forbidden);",
                    "description": "Set channels 3 and 5 and analog backplane relay 5 in bank 2 to forbidden to close on slot\u00a03.\n--- --Query for the channels and analog backplane relays that are forbidden to close on slot 3.\n--- --Sample output:\n--- --3003,3005,3925\n"
                },
                {
                    "example": "Forbidden = channel.getforbidden(\"1911:1916\" .. \",2004,2008,2012\");",
                    "description": "Query for channels and analog backplane relays in a specified list. This list is only checking channels and analog backplane relays 1 to 6 on slot\u00a01 and channels 4, 8 and 12 on slot 2 and returning the channels and analog backplane relays that are forbidden to close.\n"
                }
            ],
            "related_commands": [
                "channel.clearforbidden()",
                "channel.setforbidden()",
                "Data retrieval commands"
            ]
        },
        {
            "name": "channel.clearforbidden()",
            "webhelpfile": "17406.htm",
            "signature": "channel.clearforbidden(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function clears the list of channels specified from being forbidden to close.",
            "details": "The channelList parameter indicates the channels that will no longer be forbidden to close, and may include:This function allows all items contained in the channelList parameter to be closed. It removes the \"forbidden to close\" attribute that can be applied to a channel using channel.setforbidden().Command processing stops as soon as an error is detected. If an error is found, the channels are not cleared from being forbidden to close.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "The channels to set, using standard channel naming",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.clearforbidden(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.clearforbidden(\"2002,2004,2006,2008\");",
                    "description": "Clears channels 2, 4, 6, and 8 on slot 2 from being forbidden to close.\n"
                }
            ],
            "related_commands": [
                "channel.getforbidden()",
                "channel.setforbidden()"
            ]
        },
        {
            "name": "channel.connectrule",
            "webhelpfile": "17407.htm",
            "signature": "",
            "command_return": "rule",
            "type": "Attribute (RW)\n",
            "default_value": "channel.BREAK_BEFORE_MAKE\n",
            "tsp_link": "Yes\n",
            "description": "This attribute controls the connection rule for closing and opening channels in the instrument.",
            "details": "The connection rule describes the order in which switch channels are opened and closed when using channel.exclusiveclose(), channel.exclusiveslotclose(), dmm.close(), and scanning commands like scan.execute() and scan.background(). These commands may both open and close switch channels in a single command. The connection rule dictates the algorithm used by the instrument to order the opening and closing of switches.The connection rule affects the operating time of these commands. These commands do not allow the instrument to continue execution until the settle time of the relays has expired.When the connection rule is set to break before make, the instrument ensures that all switch channels open before any switch channels close. When switch channels are both opened and closed, this command executes not less than the addition of both the open and close settle times of the indicated switch channels.When the connection rule is set to make before break, the instrument ensures that all switch channels close before any switch channels open. This behavior should be applied with caution because it will connect two test devices together for the duration of the switch close settle time. When switch channels are both opened and closed, the command executes not less than the addition of both the open and close settle times of the indicated switch channels.With no connection rule (set to channel.OFF), the instrument attempts to simultaneously open and close switch channels in order to minimize the command execution time. This results in faster performance at the expense of guaranteed switch position. During the operation, multiple switch channels may simultaneously be in the close position. Make sure your device under test can withstand this possible condition. When switch channels are both opened and closed, the command executes not less than the greater of either the open or close settle times of the indicated switch channels.In general, the settling time of single commands that open and close switch channels depends on several factors, such as card type and channel numbers. However, the opening and closing of two sequential channels including no others can be guaranteed as follows:This behavior is also affected by channel.connectsequential and any additional user delay times.",
            "param_info": [
                {
                    "name": "rule",
                    "description": "channel.BREAK_BEFORE_MAKE or 1",
                    "enum": "channel.BREAK_BEFORE_MAKE 1|channel.MAKE_BEFORE_BREAK 2|channel.OFF 0",
                    "type": "channelconnectrulerule",
                    "range": ""
                }
            ],
            "usage": [
                "rule = channel.connectrule",
                "channel.connectrule = rule"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.connectrule = channel.BREAK_BEFORE_MAKE;",
                    "description": "Sets the connect rule in the instrument to channel.BREAK_BEFORE_MAKE\n"
                }
            ],
            "related_commands": [
                "channel.connectsequential",
                "channel.exclusiveclose()",
                "channel.exclusiveslotclose()",
                "dmm.close()",
                "scan.background()",
                "scan.execute()"
            ]
        },
        {
            "name": "channel.exclusiveclose()",
            "webhelpfile": "17435.htm",
            "signature": "channel.exclusiveclose(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function closes the specified channels so that they are the only channels that are closed on the instrument.",
            "details": "This command allows you to close specific channels and open any other channels on the instrument. When you send this command, any presently closed channel opens if it is not specified to be closed in the parameter. For channel patterns, the analog backplane relays that are closed or opened are the ones that were specified when the pattern was created  with channel.pattern.setimage() or channel.pattern.snapshot(). For channels, the analog backplane relays that are closed or opened are the ones specified with channel.setbackplane(), or that are specified in channelList.When you send this command:If the channelList parameter is an empty string or a string of spaces, all channels and analog backplane relays are opened. Therefore, sending channel.exclusiveclose(\"\") is equivalent to channel.open(channel.getclose(\"allslots\")). However, sending the equivalent commands when nothing is closed generates an error because nil (the response of channel.getclose(\"allslots\")) is being sent to the open command.An error is generated if:Once an error is detected, the command stops processing. Channels open or close only if no errors are found.This command is not available for digital I/O, DAC, and totalizer channels. Calling on a specific channel for these channels generates an error. If the digital I/O, DAC, or totalizer channel is in the range of specified channels, the channel is ignored.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string listing the channels (including analog backplane relays) and channel patterns to exclusively close",
                    "enum": "",
                    "type": "string",
                    "range": "(including analog backplane relays)"
                }
            ],
            "usage": [
                "channel.exclusiveclose(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setbackplane(\"3003\",\"3913\");channel.exclusiveclose(\"3003\");",
                    "description": "Associate analog backplane relay 3 in bank 1 on slot 3 with channel 3 on slot 3.\n--- --Open all channels and close slot 3, channel 3 and its associated analog backplane relay (3 in bank 1 on slot 3), if it is not already closed.\n"
                },
                {
                    "example": "channel.exclusiveclose(\"3003, 3913\");",
                    "description": "Close channel 3 on slot 3 and its associated analog backplane relay 3 in bank 1 on slot 3. By specifying the backplane relay directly, you eliminate the need for associating the backplane with channel.setbackplane.\n"
                }
            ],
            "related_commands": [
                "channel.close()",
                "channel.connectrule",
                "channel.connectsequential",
                "channel.exclusiveslotclose()",
                "channel.getclose()",
                "channel.getimage()",
                "channel.getstate()",
                "channel.open()",
                "channel.pattern.getimage()",
                "channel.setbackplane()",
                "channel.pattern.setimage()",
                "channel.pattern.snapshot()",
                "channel.setdelay()",
                "dmm.close()"
            ]
        },
        {
            "name": "channel.exclusiveslotclose()",
            "webhelpfile": "17437.htm",
            "signature": "channel.exclusiveslotclose(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function closes the specified channels and channel patterns on the associated slots and opens any channels that are not specified.",
            "details": "This command allows you to bundle the closing of channels with the opening of channels. Any currently closed channels or analog backplane relays open if they are not specified to be closed on the slots related to the channels in channelList. Using this command guarantees that only the specified channels and channel patterns are closed on the slots associated with channels in the channelList.For channel patterns, the analog backplane relays that are closed or opened are the ones that were specified when the pattern was created (see channel.pattern.setimage() or channel.pattern.snapshot()). For channels, the analog backplane relays are the ones specified with the channel.setbackplane() command. If you do not want to use the channel.setbackplane() command, you can close the analog backplane relays by including them in the channelList parameter. When this command is sent:The command is not available for digital I/O, DAC, and totalizer channels. Calling on one of these channels generates an error. If the digital I/O, DAC, or totalizer channel is in the range of channels, the channel is ignored.An error is generated if:Once an error is detected, the command stops processing. Channels open or close only if no errors are found and remain unchanged with any parsing or syntax error.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string that lists the channels and channel patterns to exclusively close on the cards in associated slots (you can specify analog backplane relays)",
                    "enum": "",
                    "type": "string",
                    "range": "(you can specify analog backplane relays)"
                }
            ],
            "usage": [
                "channel.exclusiveslotclose(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.exclusiveslotclose(\"3003\");channel.exclusiveslotclose(\"1005, 2005\");channel.pattern.setimage(\"5007, 5017, 5027, 5915,\" \"RouteA\");channel.exclusiveslotclose(\"RouteA\");",
                    "description": "Close channel 3 on slot 3 and open all other channels on slot 3 without affecting any other slot.\n--- --Close channel 5 on slots 1 and 2 and open all other channels on slots 1 and 2 without affecting any other slots.\n--- --Create a channel pattern called RouteA that includes channels 7, 17, and 27 on slot 5. Analog backplane relay\u00a05 in bank 1 on slot 5 is also in the pattern. Have only the RouteA channels close on slot 5 (channels 7, 17, and 27, and analog backplane relay 5 in bank 1 on slot 5.\n"
                }
            ],
            "related_commands": [
                "channel.close()",
                "channel.connectrule",
                "channel.connectsequential",
                "channel.exclusiveclose()",
                "channel.getclose()",
                "channel.getimage()",
                "channel.open()",
                "channel.pattern.getimage()",
                "channel.setbackplane()",
                "channel.setdelay()"
            ]
        },
        {
            "name": "channel.getdelay()",
            "webhelpfile": "17521.htm",
            "signature": "channel.getdelay(channelList)",
            "command_return": "delayTimes",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function queries for the additional delay time for the specified channels.",
            "details": "The channelList parameter may contain slotX (where X equals 1 to 6) or allslots.A command, after closing the state of channels, incurs the delay time indicated in the response for a channel before it completes. However, the internal settling time must elapse before the user delay is incurred. Therefore, the sequence is:The delay times are comma-delimited in the same order that the items were specified in the channelList parameter. A value of zero (0) indicates that no additional delay time is incurred before a close command completes.An error message is generated for the following reasons:Command processing stops as soon as an error is detected and a nil response is generated.",
            "param_info": [
                {
                    "name": "delayTimes",
                    "description": "A comma-delimited string consisting of the delay times (in seconds) for channels specified in channelList",
                    "enum": "",
                    "type": "string",
                    "range": "(in seconds)"
                },
                {
                    "name": "channelList",
                    "description": "A string listing the channels to query for their delay times",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "delayTimes = channel.getdelay(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "delaytime = channel.getdelay(\"5001, 5003\");print(delaytime);",
                    "description": "Query channels 1 and 3 on slot 5 for their delay times.\n--- --Example output:\n--- --0.000e+00,0.000e+00\n"
                },
                {
                    "example": "patternChannels =    channel.pattern.get(\"chans\");DelayPatternTimes = ;   channel.getdelay(patternChannels);",
                    "description": "Gets the delay of the channels in the chans channel pattern if chans does not contain backplane relays. If it does contain backplane relays, you receive error code 1115, \"Parameter error invalid channel type in channel\u00a0list.\"\n"
                }
            ],
            "related_commands": [
                "channel.setdelay()",
                "Data retrieval commands"
            ]
        },
        {
            "name": "channel.setdelay()",
            "webhelpfile": "17522.htm",
            "signature": "channel.setdelay(channelList, delay)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets additional delay time for specified channels.",
            "details": "Setting a delay only applies to switch channels. An error occurs for a read/write channel such as digital input/output. The delay being specified by value may be updated based on a card's resolution for delay. To see if the delay value was modified after setting, use the channel.getdelay() command to query.Channel patterns get their delay from the channels that comprise the pattern. Therefore, specify the delay for a pattern through the channels. A pattern incurs the longest delay of all channels comprising that pattern.An error message is generated if:Command processing will stop as soon as an error is detected and no delay times will be modified.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "A string listing the channels for which to add delay time",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "delay",
                    "description": "Delay time for the selected channels; minimum is 0 seconds",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "channel.setdelay(channelList, delay)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setdelay(\"5001, 5003\" , 50e-6);",
                    "description": "Sets channels 1 and 3 on slot 5 for a delay time of 50\u00a0\u00b5s.\n"
                },
                {
                    "example": "channel.setdelay (\"slot3\", 0);",
                    "description": "Sets the channels on slot 3 for 0 delay time.\n"
                }
            ],
            "related_commands": [
                "channel.getdelay()"
            ]
        },
        {
            "name": "channel.getimage()",
            "webhelpfile": "17523.htm",
            "signature": "channel.getimage(channelList)",
            "command_return": "channels",
            "type": "Function\n",
            "default_value": "channel identifier\n",
            "tsp_link": "Yes\n",
            "description": "This function queries a channel for items associated with that channel when used in a switching operation.",
            "details": "The parameter string can contain \"slotX\"(where X equals 1 to 6) or \"allslots\".The returned string lists the channels in slot, channel format or slot, row, column format. A request for multiple channels is delimited by a semicolon. Note that commas delimit the specific channels and analog backplane relays for an individual channel in the string.If an error is detected, the response is nil. An error is generated if:",
            "param_info": [
                {
                    "name": "channels",
                    "description": "A string listing the channels and analog backplane relays associated with the specified items",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "A string representing the channels and analog backplane relays to query",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channels = channel.getimage(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.setpole(\"2005\", 2);channel.setbackplane(\"2005\", \"2911\")  ;channels = channel.getimage(\"2005\");print(channels);",
                    "description": "Set channel 5 on slot 2 for a 2-wire switch application.\n--- --Associate analog backplane relay 1 in bank 1 on slot 2 with channel 5 on slot 2.\n--- --Query channel 5 on slot 2. \n--- --Output:\n--- --2005,2911\n"
                },
                {
                    "example": "channel.setpole(\"2003\", 4);channel.setbackplane(\"2003\", \"2911,2922\");channels = channel.getimage(\"2003\");print(channels);",
                    "description": "Set channel 3 on slot 2 for a 4-wire switch application.\n--- --Associate analog backplane relays 1 in bank 1 and 2 in slot 2 with channel 3 on slot 2.\n--- --Query channel 3 on slot 2 (assuming channel 3 on slot 2 is on a 40-channel card).\n--- --Output:\n--- --2003(2023),2911,2922\n"
                },
                {
                    "example": "channels = channel.getimage(\"2003, 2005\");print(channels);",
                    "description": "Query for channels 2003 and 2005 in a single call (assuming they are configured as shown in examples 1 and 2).\n--- --Output:\n--- --2003(2023),2911,2922;2005,2911\n"
                },
                {
                    "example": "channels = channel.getimage(\"2023\");print(channels);",
                    "description": "Query channel 2023.\n--- --Query channel 3 on slot 2 (assuming channel 23 on slot 2 is on a 40-channel card).\n--- --Output:\n--- --nil\n--- --2023 is paired for 4-wire operation\n"
                }
            ],
            "related_commands": [
                "Channel",
                "channel.pattern.getimage()",
                "Data retrieval commands"
            ]
        },
        {
            "name": "channel.getlabel()",
            "webhelpfile": "17536.htm",
            "signature": "channel.getlabel(channelList)",
            "command_return": "label",
            "type": "Function\n",
            "default_value": "slot, row, column  or slot, channel identifier\n",
            "tsp_link": "Yes\n",
            "description": "This function retrieves the label associated with one or more channels.",
            "details": "The channelList parameter can contain more than one channel. If it does, a comma delimits the labels for the channels. The return string lists the labels in the same order that the channels were specified. The channelList parameter cannot be an empty string and must be a valid channel.The channelList parameter can contain slotX (where X equals 1 to 6) or allslots. In this case, the channels are listed before the analog backplane relays.An error is generated if:Command processing stops as soon as an error is detected, and then a nil response is generated. No partial list of labels is returned.Labels are also supported for digital I/O, DAC, and totalizer channels.",
            "param_info": [
                {
                    "name": "label",
                    "description": "A string listing the comma-delimited labels for items in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "A string listing the channels to query for the label associated with them",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "label = channel.getlabel(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.reset(\"5001\");print(channel.getlabel(\"5001\"));channel.setlabel(\"5001\", \"Device\");print(channel.getlabel(\"5001\"));",
                    "description": "Reset the channel.\n--- --Print the default label of the channel.\n--- --Set the label to Device.\n--- --Return the new label.\n--- --Output:\n--- --5001\n--- --Device\n"
                }
            ],
            "related_commands": [
                "channel.setlabel()",
                "Data retrieval commands"
            ]
        },
        {
            "name": "channel.getmatch()",
            "webhelpfile": "17540.htm",
            "signature": "channel.getmatch(channelList)",
            "command_return": "matchValue",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function gets the match value on a channel.",
            "details": "If a width greater than 1 is specified with channel.setmatch(), the matchValue contains the additional channel width specified at set time. For example, the value of 65535 with a width of 2 returns 65535. If the width is 1, 255 is returned.This command returns the match value that was set for the specified channels. DAC, backplane, and switch channels are not supported. If they are included in a range or slot specifier, they are ignored.",
            "param_info": [
                {
                    "name": "matchValue",
                    "description": "The match values set for the channels in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String specifying digital I/O or totalizer channels to query, using normal channel list\u00a0syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "matchValue = channel.getmatch(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(channel.getmatch(\"slot6\"));",
                    "description": "Query the match values set for digital I/O channels\u00a01 to 5 on slot 6 and totalizer channels 6 to 9 on slot 6, assuming a Model 3750 card.\n--- --Output (assuming defaults):\n--- --0,0,0,0,0,0,0,0,0\n"
                }
            ],
            "related_commands": [
                "channel.setmatch()"
            ]
        },
        {
            "name": "channel.setmatch()",
            "webhelpfile": "17541.htm",
            "signature": "channel.setmatch(channelList, matchValue, mask, width)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This function sets the match value on a digital input or totalizer channel.",
            "details": "You can use matching to set a state or generate an event when the digital I/O or totalizer count matches a value, instead of continually reading the digital input or totalizer.The default mask is all bits.For digital I/O channels, a width of 1, 2, 3, or 4 channels is supported. Any bits greater than the specified width are ignored. If a width crosses channels, the match status indicator is only on the channel specified in the match value. For example, setting a value with a 2 width on channel 3 drives the indicator on channel 3, not channel 4. Match values for output channels are ignored.Totalizer and DAC channels only support a width of 1, and mask is ignored.Switch and backplane channels are not supported. If they are included in a range or slot specifier, they are ignored. If they are specified directly, an error is generated.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String that specifies the channels to query, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "matchValue",
                    "description": "Channel value to compare on the specified channel",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "mask",
                    "description": "Value to specify the bits used to mask matchValue",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "width",
                    "description": "Value that specifies matches over multiple consecutive channels (default 1)",
                    "enum": "",
                    "type": "any",
                    "range": "(default 1)"
                }
            ],
            "usage": [
                "channel.setmatch(channelList, matchValue)",
                "channel.setmatch(channelList, matchValue, mask)",
                "channel.setmatch(channelList, matchValue, mask, width)"
            ],
            "overloads": [
                "channel.setmatch(channelList, matchValue)",
                "channel.setmatch(channelList, matchValue, mask)"
            ],
            "examples": [
                {
                    "example": "channel.setmatchtype(\"1001\", channel.MATCH_EXACT);channel.setmatch(\"1001\", 32);",
                    "description": "Generates a match state event on bit B6 of digital I/O channel 1, assuming a 3750.\n"
                },
                {
                    "example": "channel.setmatchtype(\"6007\", channel.MATCH_EXACT);channel.setmatch(\"6007\", 300);",
                    "description": "Assuming a 3750, configure the totalizer channel 7 on slot 6 to generate a match state event when it reaches\u00a0300.\n"
                }
            ],
            "related_commands": [
                "channel.getmatch()"
            ]
        },
        {
            "name": "channel.getstate()",
            "webhelpfile": "17546.htm",
            "signature": "channel.getstate(channelList, indicatorMask)",
            "command_return": "state",
            "type": "Function\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the state indicators of the channels in the instrument.",
            "details": "Each bit in the state represents a different indicator. Therefore, multiple indicators can be present (the OR operation is performed bitwise). All state or state latch commands behave in this manner.Different channel types support different state information (indicators). The optional state indicatorMask can be used to return only certain indicators. If there is no indicatorMask, then all indicators are returned.The following status indicators are defined:Indicators can be latched or unlatched, depending on other system settings. Latched indicators mean that the condition has occurred since the last reset command (or power cycle). Unlatched indicators mean that the condition occurred when the channel.getstate() command was issued. The overflow and overload indicators default to a latched condition.Although the channel.getstate() command returns a string representing a number, this can be easily changed to a number and then compared to one of the provided Lua constants.For switch channels, the only state information is an indicator of relay state (channel.IND_CLOSED).For digital I/O channels, the state information includes an indicator for the state of auto protection and whether the match value has been matched (channel.IND_OVERLOAD and channel.IND_MATCH).For totalizer channels, the state information includes an indicator for overflow and whether the match value has been matched (channel.IND_OVERFLOW and channel.IND_MATCH).For DAC channels, the state information includes an indicator for the state of auto protection (channel.IND_OVERLOAD).For more specific information about the overflow and overload indicators, refer to the documentation for the specific card on which the specified channel resides.",
            "param_info": [
                {
                    "name": "state",
                    "description": "Return string listing the comma-delimited states for the channels in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String specifying the channels to query, using normal channel list syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "indicatorMask",
                    "description": "Value to specify only certain indicators; if omitted, all indicators are returned",
                    "enum": "",
                    "type": "channelgetstateindicatorMask",
                    "range": ""
                }
            ],
            "usage": [
                "state = channel.getstate(channelList)",
                "state = channel.getstate(channelList, indicatorMask)"
            ],
            "overloads": [
                "state = channel.getstate(channelList)"
            ],
            "examples": [
                {
                    "example": "channel.close(\"4005, 4007, 4017, 4003\")  ;State = channel.getstate(\"4001:4020\");print(State);",
                    "description": "Close channels 5, 7, 17, and 3 on slot 4.\n--- --Query the state of the first 20 channels on slot 4.\n--- --View the response assigned to State.\n--- --Output (assuming a Model 3720):\n--- --0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0\n"
                },
                {
                    "example": "PathList = channel.pattern.getimage(\"Path\");print(Path);print(channel.getstate(Path));",
                    "description": "See the state of channels and analog backplane relays in the channel pattern called \"Path\".\n--- --Output:\n--- --4003,4005,4007,4017,4911,4922\n--- --1,1,1,1,1,1\n"
                },
                {
                    "example": "PathState = channel.getstate(\"Path\");print(PathState);",
                    "description": "Another way to see the state of channels and analog backplane relays in channel pattern \"Path\" in Example 2 without getting the channels and analog backplane relays first.\n--- --Output:\n--- --1,1,1,1,1,1\n"
                },
                {
                    "example": "if bit.bitand(channel.IND_OVERLOAD,;   tonumber(channel.getstate(\"4010\"))) == 1;then;   print(\"OVERLOAD\");end;",
                    "description": "Use the following command to check for an overload on a DAC channel.\n--- --In the previous example, channel.getstate() returns a string that is converted to a number using the Lua tonumber() command. channel.IND_OVERLOAD equates to the number 2. Because the state is a bit-oriented value, a logical AND operation must be performed on the state and the overload constant to isolate it from other indicators.\n--- --The tonumber() command only works with a single channel. When multiple channels are returned (for example, channel.getstate(\"slot4\")), this string must be parsed by the comma delimiter to find each value.\n"
                }
            ],
            "related_commands": [
                "channel.getclose()",
                "channel.setmatch()"
            ]
        },
        {
            "name": "channel.gettype()",
            "webhelpfile": "17547.htm",
            "signature": "channel.gettype(channelList)",
            "command_return": "type",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the type associated with a channel.",
            "details": "The channel type is defined by the physical hardware of the card on which the channel exists. The following are valid channel types:Refer to the card-specific documentation for more information about the channel types available for your card.",
            "param_info": [
                {
                    "name": "type",
                    "description": "Returns a comma-delimited list of the type of channels in channelList",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "channelList",
                    "description": "String specifying the channels to query, using normal channelList syntax",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "type = channel.gettype(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(channel.gettype(\"1001, 1911\"));",
                    "description": "Query the channel type of channel 1 and analog backplane relay 1 of bank 1 in slot 1, assuming a 3720.\n--- --Output:\n--- --1,2\n"
                },
                {
                    "example": "print(channel.gettype(\"slot6\"));",
                    "description": "Query the channel types on slot 6, assuming a 3750.\n--- --Output:\n--- --4,4,4,4,4,16,16,16,16,8,8\n--- --This shows that channels 1 to 5 are digital I/O types, channels 6 to 9 are totalizer types, and channels 10 and 11 are DAC types.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "channel.open()",
            "webhelpfile": "17548.htm",
            "signature": "channel.open(channelList)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function opens the specified channels, analog backplane relays, and channel patterns.",
            "details": "This function opens the specified channels based on the switching configuration of the channel.For the items specified to open, the channels associated with them open, as well as the associated analog backplane relays for each. For channel patterns, the analog backplane relays that get opened are the ones that are specified when the pattern is created (through channel.pattern.setimage() and channel.pattern.snapshot()). For channels, they are the ones specified with the channel.setbackplane() function. Another option for opening analog backplane relays with this command is to include them in the channelList parameter.This command has no effect on how the DMM is configured.The settling time associated with a channel must elapse before the command completes. User delay is not added when a relay opens.For digital I/O, DAC, and totalizer channels, there is no valid behavior; calling on a specific channel generates an error. If a digital I/O, DAC, or totalizer channel is in the range of channels, the channel is ignored.",
            "param_info": [
                {
                    "name": "channelList",
                    "description": "String listing the channels, analog backplane relays, and channel patterns to open",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "channel.open(channelList)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.open(\"1001:1005, 3003, Chans\");",
                    "description": "Opens channels 1 to 5 on slot 1, channel 3 on slot 3, and the channel pattern or label Chans.\n"
                },
                {
                    "example": "channel.open(\"slot3, slot5\");",
                    "description": "Opens all channels on slots 3 and 5.\n"
                },
                {
                    "example": "channel.open(\"allslots\");",
                    "description": "Opens all channels on all slots.\n"
                }
            ],
            "related_commands": [
                "channel.close()",
                "channel.exclusiveclose()",
                "channel.exclusiveslotclose()",
                "channel.getclose()",
                "channel.getdelay()",
                "channel.pattern.getimage()",
                "channel.pattern.setimage()",
                "channel.pattern.snapshot()",
                "channel.getstate()",
                "channel.setdelay() ",
                "channel.setforbidden() ",
                "channel.setbackplane()",
                "dmm.close()",
                "dmm.open()"
            ]
        },
        {
            "name": "status.request_enable",
            "webhelpfile": "17593.htm",
            "signature": "",
            "command_return": "requestSRQEnableRegister",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the service request (SRQ) enable register.",
            "details": "This attribute is used to read or write to the service request enable register. Reading the service request enable register returns a value. The binary equivalent of the value of this attribute indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B7. For example, if a value of 1.29000e+02 (which is 129) is read as the value of this register, the binary equivalent is 1000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitFor information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.As an example, to set bit B0 of the service request enable register, set status.request_enable = status.MSB.In addition to the above values, requestSRQEnableRegister can be set to the numeric equivalent of the bit to set. To set more than one bit of the register, set requestSRQEnableRegister to the sum of their decimal weights. For example, to set bits B0 and B7, set requestSRQEnableRegister to 129 (1 + 128).",
            "param_info": [
                {
                    "name": "requestSRQEnableRegister",
                    "description": "The status of the service request (SRQ) enable register; a zero (0) indicates no bits set (also send 0 to clear all bits); other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(SRQ)"
                }
            ],
            "usage": [
                "requestSRQEnableRegister = request_enable",
                "request_enable = requestSRQEnableRegister"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "requestSRQEnableRegister = status.MSB + status.OSB;status.request_enable = requestSRQEnableRegister;",
                    "description": "Uses constants to set the MSB and OSB bits of the service request (SRQ) enable register.\n"
                },
                {
                    "example": "-- decimal 129 = binary 10000001;requestSRQEnableRegister = 129;status.request_enable = requestSRQEnableRegister;",
                    "description": "Uses a decimal value to set the MSB and OSB bits of the service request (SRQ) enable register.\n"
                }
            ],
            "related_commands": [
                "Status byte and service request (SRQ)",
                "status.condition",
                "status.system.*"
            ]
        },
        {
            "name": "status.request_event",
            "webhelpfile": "17594.htm",
            "signature": "",
            "command_return": "requestSRQEventRegister",
            "type": "Attribute (R)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute stores the service request (SRQ) event register.",
            "details": "This attribute is used to read the service request event register, which is returned as a numeric value. Reading this register returns a value. The binary equivalent of the value of this attribute indicates which register bits are set. In the binary equivalent, the least significant bit is bit B0, and the most significant bit is bit B7. For example, if a value of 1.29000e+02 (which is 129) is read as the value of this register, the binary equivalent is 1000\u00a00001. This value indicates that bit B0 and bit B7 are set.* Least significant bit** Most significant bitThe returned value can indicate one or more status events occurred.For information about .condition, .enable, .event, .ntr, and .ptr registers, refer to Status register set contents and Enable and transition registers. The individual bits of this register are defined in the following table.In addition to the above constants, requestEventRegister can be set to the decimal equivalent of the bits set. When more than one bit of the register is set, requestEventRegister contains the sum of their decimal weights. For example, if 129 is returned, bits B0 and B7 are set (1 + 128).",
            "param_info": [
                {
                    "name": "requestSRQEventRegister",
                    "description": "The status of the request event register; a zero (0) indicates no bits set; other values indicate various bit settings",
                    "enum": "",
                    "type": "any",
                    "range": "(0)"
                }
            ],
            "usage": [
                "requestSRQEventRegister = request_event"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "requestEventRegister = status.request_event;print(requestEventRegister);",
                    "description": "Reads the status request event register.\n--- --Sample output:\n--- --1.29000e+02\n--- --Converting this output (129) to its binary equivalent yields 1000 0001.\n--- --Therefore, this output indicates that the set bits of the status request event register are presently B0 (MSB) and B7 (OSB).\n"
                }
            ],
            "related_commands": [
                "status.condition",
                "status.system.*",
                "Status byte and service request (SRQ)"
            ]
        },
        {
            "name": "tsplink.writeprotect",
            "webhelpfile": "17630.htm",
            "signature": "",
            "command_return": "mask",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the write\u2011protect mask that protects bits from changes by the tsplink.writebit() and tsplink.writeport() functions. ",
            "details": "The binary equivalent of mask indicates the mask to be set for the TSP-Link trigger line. For example, a mask value of 5 has a binary equivalent of 101. This mask write\u2011protects TSP-Link trigger lines 1 and 3.",
            "param_info": [
                {
                    "name": "mask",
                    "description": "An integer that specifies the value of the bit pattern for write\u2011protect; set bits to 1 to write\u2011protect the corresponding TSP-Link trigger line",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "mask = tsplink.writeprotect",
                "tsplink.writeprotect = mask"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.writeprotect = 5;",
                    "description": "Write\u2011protects TSP-Link trigger lines 1 and 3.\n"
                }
            ],
            "related_commands": [
                "tsplink.readbit()",
                "tsplink.readport()",
                "tsplink.writebit()",
                "tsplink.writeport()"
            ]
        },
        {
            "name": "print()",
            "webhelpfile": "17645.htm",
            "signature": "print(value1, value2)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function generates a response message.",
            "details": "TSP-enabled instruments do not have inherent query commands. Like other scripting environments, the print() command and other related print() commands generate output. The print() command creates one response message.The output from multiple arguments is separated with a tab character.Numbers are printed using the format.asciiprecision attribute. If you want use Lua formatting, print the return value from the tostring() function.",
            "param_info": [
                {
                    "name": "value1",
                    "description": "The first argument to output",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "value2",
                    "description": "The second argument to output",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "valueN",
                    "description": "The last argument to output",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "...",
                    "description": "One or more values separated with commas",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "print(value1)",
                "print(value1, value2)",
                "print(value1, ...)"
            ],
            "overloads": [
                "print(value1)",
                "print(value1, ...)"
            ],
            "examples": [
                {
                    "example": "x = 10;print(x);",
                    "description": "Example of an output response message:\n--- --10\n--- --Note that your output might be different if you set your ASCII precision setting to a different value.\n"
                },
                {
                    "example": "x = true;print(tostring(x));",
                    "description": "Example of an output response message:\n--- --true\n"
                }
            ],
            "related_commands": [
                "format.asciiprecision"
            ]
        },
        {
            "name": "createconfigscript()",
            "webhelpfile": "17655.htm",
            "signature": "createconfigscript(scriptName)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates a setup file that captures most of the present settings of the instrument.",
            "details": "If scriptName is set to autoexec, the autoexec script in the instrument is replaced by the new configuration script.If scriptName is set to the name of an existing script, the existing script is overwritten.Once created, the script that contains the settings can be run and edited like any other script.",
            "param_info": [
                {
                    "name": "scriptName",
                    "description": "A string that represents the name of the script that will be created",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "createconfigscript(scriptName)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "createconfigscript(\"August2013\");",
                    "description": "Captures the present settings of the instrument into a script named August2013.\n"
                }
            ],
            "related_commands": [
                "Create a configuration script",
                "Save the present configuration"
            ]
        },
        {
            "name": "channel.connectsequential",
            "webhelpfile": "17663.htm",
            "signature": "",
            "command_return": "sequential",
            "type": "Attribute (RW)\n",
            "default_value": "channel.OFF\n",
            "tsp_link": "Yes\n",
            "description": "This attribute controls whether or not channels are closed sequentially.",
            "details": "",
            "param_info": [
                {
                    "name": "sequential",
                    "description": "channel.OFF or 0",
                    "enum": "channel.OFF 0|channel.ON 1",
                    "type": "channelconnectsequentialsequential",
                    "range": ""
                }
            ],
            "usage": [
                "sequential = channel.connectsequential",
                "channel.connectsequential = sequential"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "channel.connectsequential = channel.ON;",
                    "description": "Specifies that channels close sequentially.\n"
                }
            ],
            "related_commands": [
                "channel.connectrule",
                "Switching and scanning"
            ]
        },
        {
            "name": "trigger.blender[N].reset()",
            "webhelpfile": "17666.htm",
            "signature": "trigger.blender[N].reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets some of the trigger blender settings to their factory defaults.",
            "details": "The trigger.blender[N].reset() function resets the following attributes to their factory defaults:It also clears trigger.blender[N].overrun.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The trigger event blender (up to two)",
                    "enum": "",
                    "type": "any",
                    "range": "(up to two)"
                }
            ],
            "usage": [
                "trigger.blender[N].reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.blender[1].reset();",
                    "description": "Resets the trigger blender\u00a01 settings to factory defaults.\n"
                }
            ],
            "related_commands": [
                "trigger.blender[N].orenable",
                "trigger.blender[N].overrun",
                "trigger.blender[N].stimulus[M]"
            ]
        },
        {
            "name": "trigger.timer[N].reset()",
            "webhelpfile": "17668.htm",
            "signature": "trigger.timer[N].reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets some of the trigger timer settings to their factory defaults.",
            "details": "The trigger.timer[N].reset() function resets the following attributes to their factory defaults:It also clears trigger.timer[N].overrun.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "trigger.timer[N].reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "trigger.timer[1].reset();",
                    "description": "Resets the attributes associated with timer 1 back to factory default values.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].count",
                "trigger.timer[N].delay",
                "trigger.timer[N].delaylist",
                "trigger.timer[N].overrun",
                "trigger.timer[N].passthrough",
                "trigger.timer[N].stimulus"
            ]
        },
        {
            "name": "tsplink.trigger[N].reset()",
            "webhelpfile": "17669.htm",
            "signature": "tsplink.trigger[N].reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets some of the TSP-Link trigger attributes to their factory defaults. ",
            "details": "The tsplink.trigger[N].reset() function resets the following attributes to their factory defaults:This also clears tsplink.trigger[N].overrun.",
            "param_info": [
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "tsplink.trigger[N].reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.trigger[3].reset();",
                    "description": "Resets TSP-Link trigger line\u00a03 attributes back to factory default values.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].mode",
                "tsplink.trigger[N].overrun",
                "tsplink.trigger[N].pulsewidth",
                "tsplink.trigger[N].stimulus"
            ]
        },
        {
            "name": "digio.trigger[N].pulsewidth",
            "webhelpfile": "17691.htm",
            "signature": "",
            "command_return": "width",
            "type": "Attribute (RW)\n",
            "default_value": "10e-6 (10\u00a0\u00b5s) digital I/O lines 1 through 920 \u00b5s digital I/O lines 10 through 14\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the length of time that the trigger line is asserted for output triggers. ",
            "details": "Setting the pulse width to zero (0) seconds asserts the trigger indefinitely. To release the trigger line, use digio.trigger[N].release().",
            "param_info": [
                {
                    "name": "width",
                    "description": "The pulse width (seconds)",
                    "enum": "",
                    "type": "any",
                    "range": "(seconds)"
                },
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "width = digio.trigger[N].pulsewidth",
                "digio.trigger[N].pulsewidth = width"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[4].pulsewidth = 20e-6;",
                    "description": "Sets the pulse width for trigger line 4 to 20\u00a0\u03bcs.\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].assert()",
                "digio.trigger[N].release()",
                "digio.trigger[N].reset()"
            ]
        },
        {
            "name": "localnode.define.MAX_TIMERS",
            "webhelpfile": "17697.htm",
            "signature": "",
            "command_return": "maxNumber",
            "type": "CONSTANT (R)\n",
            "default_value": "\u00a0\n",
            "tsp_link": "- -\n",
            "description": "These constants indicate the number of available features (of each feature type) for each local node instrument.",
            "details": "These read-only constants indicate the maximum number of each feature type that is available. Feature types are timers, digital input/output lines, triggers, and blenders.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].define.MAX_TIMERS.",
            "param_info": [
                {
                    "name": "maxNumber",
                    "description": "A variable assigned the value of the constant; the constant equals the maximum number available for the specified\u00a0feature on the local node instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maxNumber = localnode.MAX_TIMERS",
                "maxNumber = localnode.MAX_DIO_LINES",
                "maxNumber = localnode.MAX_TSPLINK_TRIGS",
                "maxNumber = localnode.MAX_BLENDERS",
                "maxNumber = localnode.MAX_BLENDER_INPUTS",
                "maxNumber = localnode.MAX_LAN_TRIGS",
                "maxNumber = localnode.MAX_CHANNEL_TRIGS"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxNumber = localnode.define.MAX_TIMERS;",
                    "description": "Reads the maximum number of timers that are available for the presently active instrument.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "localnode.define.MAX_DIO_LINES",
            "webhelpfile": "17697.htm",
            "signature": "",
            "command_return": "maxNumber",
            "type": "CONSTANT (R)\n",
            "default_value": "\u00a0\n",
            "tsp_link": "- -\n",
            "description": "These constants indicate the number of available features (of each feature type) for each local node instrument.",
            "details": "These read-only constants indicate the maximum number of each feature type that is available. Feature types are timers, digital input/output lines, triggers, and blenders.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].define.MAX_TIMERS.",
            "param_info": [
                {
                    "name": "maxNumber",
                    "description": "A variable assigned the value of the constant; the constant equals the maximum number available for the specified\u00a0feature on the local node instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maxNumber = localnode.MAX_TIMERS",
                "maxNumber = localnode.MAX_DIO_LINES",
                "maxNumber = localnode.MAX_TSPLINK_TRIGS",
                "maxNumber = localnode.MAX_BLENDERS",
                "maxNumber = localnode.MAX_BLENDER_INPUTS",
                "maxNumber = localnode.MAX_LAN_TRIGS",
                "maxNumber = localnode.MAX_CHANNEL_TRIGS"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxNumber = localnode.define.MAX_TIMERS;",
                    "description": "Reads the maximum number of timers that are available for the presently active instrument.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "localnode.define.MAX_TSPLINK_TRIGS",
            "webhelpfile": "17697.htm",
            "signature": "",
            "command_return": "maxNumber",
            "type": "CONSTANT (R)\n",
            "default_value": "\u00a0\n",
            "tsp_link": "- -\n",
            "description": "These constants indicate the number of available features (of each feature type) for each local node instrument.",
            "details": "These read-only constants indicate the maximum number of each feature type that is available. Feature types are timers, digital input/output lines, triggers, and blenders.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].define.MAX_TIMERS.",
            "param_info": [
                {
                    "name": "maxNumber",
                    "description": "A variable assigned the value of the constant; the constant equals the maximum number available for the specified\u00a0feature on the local node instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maxNumber = localnode.MAX_TIMERS",
                "maxNumber = localnode.MAX_DIO_LINES",
                "maxNumber = localnode.MAX_TSPLINK_TRIGS",
                "maxNumber = localnode.MAX_BLENDERS",
                "maxNumber = localnode.MAX_BLENDER_INPUTS",
                "maxNumber = localnode.MAX_LAN_TRIGS",
                "maxNumber = localnode.MAX_CHANNEL_TRIGS"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxNumber = localnode.define.MAX_TIMERS;",
                    "description": "Reads the maximum number of timers that are available for the presently active instrument.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "localnode.define.MAX_BLENDERS",
            "webhelpfile": "17697.htm",
            "signature": "",
            "command_return": "maxNumber",
            "type": "CONSTANT (R)\n",
            "default_value": "\u00a0\n",
            "tsp_link": "- -\n",
            "description": "These constants indicate the number of available features (of each feature type) for each local node instrument.",
            "details": "These read-only constants indicate the maximum number of each feature type that is available. Feature types are timers, digital input/output lines, triggers, and blenders.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].define.MAX_TIMERS.",
            "param_info": [
                {
                    "name": "maxNumber",
                    "description": "A variable assigned the value of the constant; the constant equals the maximum number available for the specified\u00a0feature on the local node instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maxNumber = localnode.MAX_TIMERS",
                "maxNumber = localnode.MAX_DIO_LINES",
                "maxNumber = localnode.MAX_TSPLINK_TRIGS",
                "maxNumber = localnode.MAX_BLENDERS",
                "maxNumber = localnode.MAX_BLENDER_INPUTS",
                "maxNumber = localnode.MAX_LAN_TRIGS",
                "maxNumber = localnode.MAX_CHANNEL_TRIGS"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxNumber = localnode.define.MAX_TIMERS;",
                    "description": "Reads the maximum number of timers that are available for the presently active instrument.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "localnode.define.MAX_BLENDER_INPUTS",
            "webhelpfile": "17697.htm",
            "signature": "",
            "command_return": "maxNumber",
            "type": "CONSTANT (R)\n",
            "default_value": "\u00a0\n",
            "tsp_link": "- -\n",
            "description": "These constants indicate the number of available features (of each feature type) for each local node instrument.",
            "details": "These read-only constants indicate the maximum number of each feature type that is available. Feature types are timers, digital input/output lines, triggers, and blenders.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].define.MAX_TIMERS.",
            "param_info": [
                {
                    "name": "maxNumber",
                    "description": "A variable assigned the value of the constant; the constant equals the maximum number available for the specified\u00a0feature on the local node instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maxNumber = localnode.MAX_TIMERS",
                "maxNumber = localnode.MAX_DIO_LINES",
                "maxNumber = localnode.MAX_TSPLINK_TRIGS",
                "maxNumber = localnode.MAX_BLENDERS",
                "maxNumber = localnode.MAX_BLENDER_INPUTS",
                "maxNumber = localnode.MAX_LAN_TRIGS",
                "maxNumber = localnode.MAX_CHANNEL_TRIGS"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxNumber = localnode.define.MAX_TIMERS;",
                    "description": "Reads the maximum number of timers that are available for the presently active instrument.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "localnode.define.MAX_LAN_TRIGS",
            "webhelpfile": "17697.htm",
            "signature": "",
            "command_return": "maxNumber",
            "type": "CONSTANT (R)\n",
            "default_value": "\u00a0\n",
            "tsp_link": "- -\n",
            "description": "These constants indicate the number of available features (of each feature type) for each local node instrument.",
            "details": "These read-only constants indicate the maximum number of each feature type that is available. Feature types are timers, digital input/output lines, triggers, and blenders.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].define.MAX_TIMERS.",
            "param_info": [
                {
                    "name": "maxNumber",
                    "description": "A variable assigned the value of the constant; the constant equals the maximum number available for the specified\u00a0feature on the local node instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maxNumber = localnode.MAX_TIMERS",
                "maxNumber = localnode.MAX_DIO_LINES",
                "maxNumber = localnode.MAX_TSPLINK_TRIGS",
                "maxNumber = localnode.MAX_BLENDERS",
                "maxNumber = localnode.MAX_BLENDER_INPUTS",
                "maxNumber = localnode.MAX_LAN_TRIGS",
                "maxNumber = localnode.MAX_CHANNEL_TRIGS"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxNumber = localnode.define.MAX_TIMERS;",
                    "description": "Reads the maximum number of timers that are available for the presently active instrument.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "localnode.define.MAX_CHANNEL_TRIGS",
            "webhelpfile": "17697.htm",
            "signature": "",
            "command_return": "maxNumber",
            "type": "CONSTANT (R)\n",
            "default_value": "\u00a0\n",
            "tsp_link": "- -\n",
            "description": "These constants indicate the number of available features (of each feature type) for each local node instrument.",
            "details": "These read-only constants indicate the maximum number of each feature type that is available. Feature types are timers, digital input/output lines, triggers, and blenders.When using this command from a remote node, localnode should be replaced with the node reference, for example, node[5].define.MAX_TIMERS.",
            "param_info": [
                {
                    "name": "maxNumber",
                    "description": "A variable assigned the value of the constant; the constant equals the maximum number available for the specified\u00a0feature on the local node instrument",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "maxNumber = localnode.MAX_TIMERS",
                "maxNumber = localnode.MAX_DIO_LINES",
                "maxNumber = localnode.MAX_TSPLINK_TRIGS",
                "maxNumber = localnode.MAX_BLENDERS",
                "maxNumber = localnode.MAX_BLENDER_INPUTS",
                "maxNumber = localnode.MAX_LAN_TRIGS",
                "maxNumber = localnode.MAX_CHANNEL_TRIGS"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "maxNumber = localnode.define.MAX_TIMERS;",
                    "description": "Reads the maximum number of timers that are available for the presently active instrument.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "digio.trigger[N].reset()",
            "webhelpfile": "17719.htm",
            "signature": "digio.trigger[N].reset()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function resets trigger values to their factory defaults. ",
            "details": "This function resets the following attributes to factory default settings:It also clears digio.trigger[N].overrun.",
            "param_info": [
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "number",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "digio.trigger[N].reset()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[3].mode = 2;digio.trigger[3].pulsewidth = 50e-6;digio.trigger[3].stimulus = digio.trigger[5].EVENT_ID;print(digio.trigger[3].mode, digio.trigger[3].pulsewidth, digio.trigger[3].stimulus);digio.trigger[3].reset();print(digio.trigger[3].mode, digio.trigger[3].pulsewidth, digio.trigger[3].stimulus);",
                    "description": "Set the digital I/O trigger line 3 for a falling edge with a pulsewidth of 50 \u00b5s.\n--- --Use digital I/O line 5 to trigger the event on line 3.\n--- --Reset the line back to factory default values.\n--- --Output before reset:\n--- --2.00000e+00        5.00000e-05        5.00000e+00\n--- --Output after reset:\n--- --0.00000e+00        1.00000e-05        0.00000e+00\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].mode",
                "digio.trigger[N].overrun",
                "digio.trigger[N].pulsewidth",
                "digio.trigger[N].stimulus"
            ]
        },
        {
            "name": "slot[slot].rows.matrix",
            "webhelpfile": "17756.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the number of rows in the matrix on the card in the specified slot.",
            "details": "This attribute is only available for a slot if the installed card supports matrix channels. If matrix channels are not available, the return value is nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Number of rows in the matrix card of the selected slot",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].rows.matrix"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[4].rows.matrix);",
                    "description": "Returns the number of rows in the matrix on the card in slot 4.\n--- --Example output:\n--- --1.2000000000e+01\n"
                }
            ],
            "related_commands": [
                "slot[slot].columns.matrix",
                "slot[slot].idn",
                "slot[slot].matrix"
            ]
        },
        {
            "name": "slot[slot].columns.matrix",
            "webhelpfile": "17757.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the number of columns in the matrix for the card in the specified slot.",
            "details": "This attribute is only available if the installed plug-in card supports matrix channels. If matrix channels are not available, the return value is nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The number of columns in the matrix",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "The slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].columns.matrix"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[4].columns.matrix);",
                    "description": "Returns the number of columns in the matrix on the card in slot 4 (28).\n--- --Example output:\n--- --2.800000000e+01\n"
                }
            ],
            "related_commands": [
                "slot[slot].banks.matrix",
                "slot[slot].rows.matrix"
            ]
        },
        {
            "name": "slot[slot].banks.matrix",
            "webhelpfile": "17758.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": " Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the number of banks in the matrix for a card.",
            "details": "Returns the number of banks in the matrix on the card in the specified slot. If no matrix or no card exists, it returns nil.",
            "param_info": [
                {
                    "name": "value",
                    "description": "The number of banks in the matrix",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "The slot number",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = slot[slot].banks.matrix"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[1].banks.matrix);",
                    "description": "Returns the number of banks in the matrix on the card in slot 1 (4 banks).\n--- --Output:\n--- --4.000000000e+000\n"
                }
            ],
            "related_commands": [
                "slot[slot].columns.matrix"
            ]
        },
        {
            "name": "scriptVar.list()",
            "webhelpfile": "17785.htm",
            "signature": "scriptVar.list()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function generates a script listing.",
            "details": "This function generates output in the form of a sequence of response messages (one message for each line of the script). It also generates output of the script control messages (loadscript or loadandrunscript and endscript).",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of the variable that references the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar.list()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "test7 = script.new(\"display.clear() display.settext('Hello\u00a0from\u00a0my\u00a0test')\",    \"test7\");test7();test7.save();test7.list();",
                    "description": "The above example code creates a script named test7 that displays text on the front panel and lists the script with the following output:\n--- --loadscript test7\n--- --display.clear() display.settext(\"Hello from my test\")\n--- --endscript\n"
                }
            ],
            "related_commands": [
                "Load a script by sending commands over the remote interface",
                "Retrieve source code one line at a time"
            ]
        },
        {
            "name": "script.newautorun()",
            "webhelpfile": "18832.htm",
            "signature": "script.newautorun(code, name)",
            "command_return": "scriptVar",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function creates a script and enables autorun.",
            "details": "The name parameter is the name that is added to the script.user.scripts table. If name is not provided, an empty string is used, and the script is unnamed. If the name already exists in script.user.scripts, the name attribute of the existing script is set to an empty string before it is replaced by the new script.Note that name is the value that is used for the instrument front\u2011panel display. If this value is not defined, the script is not available from the front panel.You must save the new script into nonvolatile memory to keep it when the instrument is turned off.The script is run automatically immediately after it is created.This command is the same as the script.new() function except that the script is automatically run.",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "The name of the variable that references the script",
                    "enum": "",
                    "type": "script_object",
                    "range": ""
                },
                {
                    "name": "code",
                    "description": "A string that contains the body of the script",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "name",
                    "description": "The name of the script",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar = script.newautorun(code)",
                "scriptVar = script.newautorun(code, name)"
            ],
            "overloads": [
                "scriptVar = script.newautorun(code)"
            ],
            "examples": [
                {
                    "example": "NewAuto = script.newautorun(\"print('Hello from new auto run command')\", 'NewAuto');print(NewAuto.autorun);print(NewAuto.name);",
                    "description": "Creates a new script called NewAuto that automatically has the autorun attribute set to yes after it is created. The name is set to NewAuto.\n--- --Output:\n--- --Hello from new auto run command\n--- --yes\n--- --NewAuto\n"
                }
            ],
            "related_commands": [
                "Create a script using the script.new() command",
                "Global variables and the script.user.scripts table",
                "Named scripts",
                "script.new()",
                "scriptVar.autorun",
                "scriptVar.save()"
            ]
        },
        {
            "name": "script.run()",
            "webhelpfile": "18833.htm",
            "signature": "script.run()",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "No\n",
            "description": "This function runs the anonymous script.",
            "details": "Each time the script.run() command is given, the anonymous script is executed. This script can be run using this command many times without having to re-send it. ",
            "param_info": [
                {
                    "name": "run()",
                    "description": "Runs the anonymous script.",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "script.run()",
                "run()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "run();",
                    "description": "Runs the anonymous script.\n"
                }
            ],
            "related_commands": [
                "script.anonymous"
            ]
        },
        {
            "name": "beeper.beep()",
            "webhelpfile": "18841.htm",
            "signature": "beeper.beep(duration, frequency)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function generates an audible tone.",
            "details": "You can use the beeper of the Series 3700A to provide an audible signal at a specified frequency and time duration. For example, you can use the beeper to signal the end of a lengthy sweep.The beeper does not sound if it is disabled. It can be disabled or enabled with the beeper enable command, or through the front panel.",
            "param_info": [
                {
                    "name": "duration",
                    "description": "The amount of time to play the tone (0.001\u00a0s to 100\u00a0s)",
                    "enum": "",
                    "type": "number",
                    "range": "(0.001\u00a0s to 100\u00a0s)"
                },
                {
                    "name": "frequency",
                    "description": "The frequency of the tone in Hertz\u00a0(Hz)",
                    "enum": "",
                    "type": "number",
                    "range": "(Hz)"
                }
            ],
            "usage": [
                "beeper.beep(duration, frequency)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "beeper.enable = beeper.ON;beeper.beep(2, 2400);",
                    "description": "Enables the beeper and generates a two\u2011second, 2400\u00a0Hz tone.\n"
                }
            ],
            "related_commands": [
                "beeper.enable"
            ]
        },
        {
            "name": "display.loadmenu.add()",
            "webhelpfile": "19382.htm",
            "signature": "display.loadmenu.add(displayName, code, memory)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function adds an entry to the USER TESTS menu, which can be accessed by pressing the LOAD key on the front\u00a0panel.",
            "details": "After adding code to the load menu, you can run it from the front panel by pressing the LOAD key, then selecting USER to select from the available code to load. Pressing the RUN key then runs the\u00a0script.You can add items in any order. They are always displayed in alphabetical order when the menu is\u00a0selected.Any Lua code can be included in the code parameter. If memory is set to display.SAVE, the entry (name and code) is saved in nonvolatile memory. Scripts, functions, and variables used in the code are not saved by display.SAVE. Functions and variables need to be saved with the code. If the code is not saved in nonvolatile memory, it is lost when the Series 3700A is turned off. See Example 2 below.If you do not make a selection for memory, the code is automatically saved to nonvolatile memory.",
            "param_info": [
                {
                    "name": "displayName",
                    "description": "The name that is added to the USER TESTS menu",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "code",
                    "description": "The code that is run from the USER TESTS menu",
                    "enum": "",
                    "type": "string",
                    "range": ""
                },
                {
                    "name": "memory",
                    "description": "Determines if code is saved to nonvolatile memory",
                    "enum": "display.DONT_SAVE nil|display.SAVE nil",
                    "type": "displayloadmenuaddmemory",
                    "range": ""
                }
            ],
            "usage": [
                "display.loadmenu.add(displayName, code)",
                "display.loadmenu.add(displayName, code, memory)"
            ],
            "overloads": [
                "display.loadmenu.add(displayName, code)"
            ],
            "examples": [
                {
                    "example": "display.loadmenu.add(\"Test9\", \"Test9()\");",
                    "description": "Assume a user script named Test9 is loaded into the runtime environment. Adds the menu entry to the USER TESTS menu to run the script after loading.\n"
                },
                {
                    "example": "display.loadmenu.add(\"Test\", \"DUT1() beeper.beep(2, 500)\", display.SAVE);",
                    "description": "Assume a script with a function named \u201cDUT1\u201d is loaded into the instrument, and the script has not been saved in nonvolatile memory.\n--- --Now assume you want to add a test named \u201cTest\u201d to the USER TESTS menu. You want the test to run the function named DUT1 and sound the beeper. This example adds Test to the menu, defines the code, and then saves the displayName and code in nonvolatile memory.\n--- --When Test is run from the front panel USER TESTS menu, the function named DUT1 executes and the beeper beeps for two seconds.\n--- --Now assume you turn off instrument power. Because the script was not saved in nonvolatile memory, the function named DUT1 is lost when you turn the instrument on. When Test is run again from the front panel, an error is generated because DUT1 no longer exists in the instrument as a function.\n"
                },
                {
                    "example": "display.loadmenu.add(\"Part1\", \"testpart([[Part1]], 5.0)\", display.SAVE);",
                    "description": "Adds an entry called Part1 to the front\u2011panel USER TESTS load menu for the code testpart([[Part1]], 5.0) and saves it in nonvolatile memory.\n"
                }
            ],
            "related_commands": [
                "display.loadmenu.delete()"
            ]
        },
        {
            "name": "bufferVar.readings",
            "webhelpfile": "19920.htm",
            "signature": "",
            "command_return": "reading",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the readings stored in a specified reading buffer.",
            "details": "The bufferVar.readings buffer recall attribute is like an array (a Lua table) of the readings stored in the reading buffer. This array holds the same data that is returned when the reading buffer is accessed directly; that is, rb[2] and rb.readings[2] access the same value.",
            "param_info": [],
            "usage": [
                "reading = bufferVar.readings[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collectchannels = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.readings[1]);\u00a0;\u00a0;\u00a0;printbuffer(1, 6, testData.readings);\u00a0;",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect channel data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --The print() command then outputs the first reading in the reading buffer. \n--- --Output:\n--- --6.239269805e-07\n--- --The printbuffer() command then outputs the readings for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --6.239269805e\u201107, 6.943093615e\u201107, 4.954026325e\u201107, 7.432710179e\u201107, 6.943093615e\u201107, 6.331072911e\u201107\n--- --\u00a0\n--- --NOTE: An alternative way to use the printbuffer() command for this example is printbuffer(1, 6, testData), because \"readings\" is an optional parameter and is assumed if it has not been specified.\n"
                }
            ],
            "related_commands": [
                "bufferVar.formattedreadings",
                "bufferVar.fractionalseconds",
                "bufferVar.relativetimestamps",
                "bufferVar.seconds",
                "bufferVar.statuses",
                "bufferVar.times",
                "bufferVar.units",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.statuses",
            "webhelpfile": "19921.htm",
            "signature": "",
            "command_return": "statusInformation",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the status values of readings in the reading buffer.",
            "details": "This read\u2011only buffer recall attribute is like an array (a Lua table) of the status values for all the readings in the buffer. The status values are floating-point numbers that encode the status value; see the following table for\u00a0values. ",
            "param_info": [],
            "usage": [
                "statusInformation = bufferVar.statuses[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collectchannels = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.statuses[1]);\u00a0;printbuffer(1, 6, testData.statuses);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect channel data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --The print() command then outputs the status value of the first measurement channel in the reading buffer. \n--- --Output:\n--- --0.000000000e+00\n--- --The printbuffer() command then outputs the status values for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --0.000000000e+00, 0.000000000e+00, 0.000000000e+00, 0.000000000e+00, 0.000000000e+00, 0.000000000e+00\n"
                }
            ],
            "related_commands": [
                "bufferVar.timestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.timestamps",
            "webhelpfile": "19922.htm",
            "signature": "",
            "command_return": "timestamp",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "When enabled by the bufferVar.collecttimestamps attribute, this attribute contains the timestamp when each reading saved in the specified reading buffer occurred.",
            "details": "The bufferVar.timestamps information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you cannot access any time information from a reading buffer. If enabled, this buffer recall attribute is like an array (a Lua table) that contains timestamps, in seconds, of when each reading occurred. These are relative to the bufferVar.basetimestamp for the buffer.",
            "param_info": [],
            "usage": [
                "timestamp = bufferVar.timestamps[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "printbuffer(1, 6, buffer1.timestamps);",
                    "description": "Print the timestamp of the first 6 readings stored in buffer\u00a01.\n--- --Example output:\n--- --07/11/2011 09:14:48.509762161, 07/11/2011 09:14:48.528708001, 07/11/2011 09:14:48.547659196, 07/11/2011 09:14:48.566612446, 07/11/2011 09:14:48.585565606, 07/11/2011 09:14:48.681325966\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "bufferVar.n",
                "bufferVar.readings",
                "bufferVar.statuses",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.basetimefractional",
            "webhelpfile": "20150.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "When enabled by the bufferVar.collecttimestamps attribute, this attribute contains the fractional portion of the timestamp (in seconds) for the first reading stored in the reading buffer.",
            "details": "The bufferVar.basetimefractional information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you will not be able to access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).A read-only attribute for each existing reading buffer in the instrument. The attribute represents the fractional seconds of the timestamp when reading 1 was stored in the buffer",
            "param_info": [],
            "usage": [
                "value = bufferVar.basetimefractional"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "baseFractional = buffer1.basetimefractional;",
                    "description": "Read the basetimefractional attribute for buffer1 and store it in a variable called baseFractional.\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.basetimeseconds",
            "webhelpfile": "20151.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "When enabled by the bufferVar.collecttimestamps attribute, this attribute represents the nonfractional seconds of the timestamp for the first reading stored in the reading buffer.",
            "details": "The basetime seconds information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you will not be able to access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).This attribute is a read\u2011only attribute for each existing reading buffer in the instrument. This attribute represents the nonfractional seconds of the timestamp when reading 1 was stored in the buffer.",
            "param_info": [],
            "usage": [
                "value = bufferVar.basetimeseconds"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "basedSeconds = buffer1.basetimeseconds;",
                    "description": "Read the basetimeseconds attribute for buffer1 and store in a variable called baseSeconds.\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.channels",
            "webhelpfile": "20152.htm",
            "signature": "",
            "command_return": "channels",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "When enabled by the bufferVar.collectchannels attribute, this buffer recall attribute gets the channel, backplane relay, or channel pattern information stored with readings in the buffer.",
            "details": "The channels information from a reading buffer is only available if the bufferVar.collectchannels attribute is set to 1 (default setting). If it is set to 0, you will not be able to access the channels information from a reading buffer. You may change the collect channels setting when the buffer is empty (bufferVar.clear()).This read\u2011only attribute is an array (a Lua table) of strings indicating the channel or channel pattern associated with the measurement. The returned value provides different information, based on what was opened or closed when the reading was acquired:",
            "param_info": [],
            "usage": [
                "channels = bufferVar.channels[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collectchannels = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.channels[1]);\u00a0;printbuffer(1, 6, testData.channels);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect channel data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --\u00a0\n--- --The print() command then outputs the first measurement channel. \n--- --Output:\n--- --2035+\n--- --The printbuffer() command then outputs the channels for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --2035+, 2036+, 2037+, 2038+, 2039+, 2040+\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collectchannels",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.collectchannels",
            "webhelpfile": "20153.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "1 (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute sets the storage state of channel information with the readings in the buffer.",
            "details": "Assigning a value to this attribute enables or disables the storage of channel information, which includes channel, backplane relay, or channel pattern information associated with the reading. Reading this attribute returns the state of channel information collection.When on, channel information is stored with readings in the buffer. This requires eight extra bytes of storage per reading. This value, off (0) or on (1), can only be changed when the buffer is empty. Empty the buffer using the bufferVar.clear() function.",
            "param_info": [],
            "usage": [
                "state = bufferVar.collectchannels",
                "bufferVar.collectchannels = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collectchannels = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.channels[1]);\u00a0;printbuffer(1, 6, testData.channels);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect channel data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --\u00a0\n--- --The print() command then outputs the first measurement channel. \n--- --Output:\n--- --2035+\n--- --The printbuffer() command then outputs the channels for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --2035+, 2036+, 2037+, 2038+, 2039+, 2040+\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.channels",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.dates",
            "webhelpfile": "20154.htm",
            "signature": "",
            "command_return": "dates",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "When enabled by the bufferVar.collecttimestamps attribute, this attribute contains the dates (month, day, and year) of readings stored in the reading buffer.",
            "details": "The bufferVar.dates information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you cannot access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).This read\u2011only attribute is an array (a Lua table) of strings indicating the date of the reading, formatted in month, day, and year format.",
            "param_info": [],
            "usage": [
                "dates = bufferVar.dates[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collecttimestamps = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.dates[1]);\u00a0;\u00a0;\u00a0;\u00a0;printbuffer(1, 6, testData.dates);\u00a0;\u00a0;",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect time and date data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --\u00a0\n--- --\u00a0\n--- --\u00a0\n--- --\u00a0\n--- --The print() command then outputs the first measurement date. \n--- --Output:\n--- --07/11/2011\n--- --\u00a0\n--- --The printbuffer() command then outputs the dates for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --07/11/2011, 07/11/2011, 07/11/2011, 07/11/2011, 07/11/2011, 07/11/2011\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.formattedreadings",
            "webhelpfile": "20155.htm",
            "signature": "",
            "command_return": "readings",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the stored readings shown as numbers with units and prefixes.",
            "details": "This read\u2011only attribute is an array that contains the stored readings. The readings are shown as numbers with prefixes before the units symbol.Use this attribute to access the reading elements N as they appear on the front panel.",
            "param_info": [],
            "usage": [
                "readings = bufferVar.formattedreadings[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.formattedreadings[1]);\u00a0;\u00a0;\u00a0;\u00a0;printbuffer(1, 6, testData.formattedreadings);",
                    "description": "This example creates a reading buffer named testData, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --\u00a0\n--- --\u00a0\n--- --\u00a0\n--- --\u00a0\n--- --\u00a0\n--- --The print() command outputs the first reading, formatted as it appears on the front\u2011panel display. \n--- --Output:\n--- --+000.0006e\u20113\n--- --The printbuffer() command then outputs readings 1 to 6 in the reading buffer as they appear on the front\u2011panel display.\n--- --Output:\n--- --6.000000000e\u201107, 7.000000000e\u201107, 5.000000000e\u201107, 7.000000000e\u201107, 7.000000000e\u201107, 6.000000000e\u201107\n"
                }
            ],
            "related_commands": [
                "bufferVar.readings",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.fractionalseconds",
            "webhelpfile": "20156.htm",
            "signature": "",
            "command_return": "fractionalseconds",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the fractional second portion of the timestamp of each reading in the reading buffer.",
            "details": "The bufferVar.fractionalseconds information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you will not be able to access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).This read\u2011only attribute is an array (a Lua table) of the fractional portion of the timestamps, in seconds, of when each reading occurred. These are absolute fractional times.",
            "param_info": [],
            "usage": [
                "fractionalseconds = bufferVar.fractionalseconds[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collecttimestamps = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.fractionalseconds[1]);\u00a0;\u00a0;\u00a0;\u00a0;\u00a0;printbuffer(1, 6, testData.fractionalseconds);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect time and date data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --\u00a0\n--- --\u00a0\n--- --\u00a0\n--- --\u00a0\n--- --The print() command outputs the fractional portion of the timestamp for the first measurement in the buffer. \n--- --Output:\n--- --5.097621610e-01\n--- --The printbuffer() command then outputs the fractional portion of the timestamp for the first six measurements in the buffer. \n--- --Output:\n--- --5.097621610e\u201101, 5.287080010e\u201101, 5.476591960e\u201101, 5.666124460e\u201101, 5.855656060e\u201101, 6.813259660e\u201101\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.ptpseconds",
            "webhelpfile": "20157.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "When enabled by the bufferVar.collecttimestamps attribute, this attribute contains the absolute seconds portion of the timestamp of when the reading was stored, in PTP format.",
            "details": "The ptp seconds information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you will not be able to access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).These seconds are absolute and in PTP format.",
            "param_info": [],
            "usage": [
                "value = bufferVar.ptpseconds[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collecttimestamps = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.ptpseconds[1]);\u00a0;\u00a0;\u00a0;\u00a0;printbuffer(1, 6, testData.ptpseconds);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect time and date data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --The print() command outputs the absolute seconds portion of the timestamp of first measurement in the buffer, in PTP format.\n--- --Output:\n--- --1.310375688e+09\n--- --The printbuffer() command outputs the absolute seconds portion of the timestamp for measurements 1 to 6 in the reading buffer, in PTP format. \n--- --Output:\n--- --1.310375688e+09, 1.310375688e+09, 1.310375688e+09, 1.310375688e+09, 1.310375688e+09, 1.310375688e+09\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.relativetimestamps",
            "webhelpfile": "20158.htm",
            "signature": "",
            "command_return": "timestamp",
            "type": "Attribute (R)\n",
            "default_value": "1\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the timestamps, in seconds, when each reading occurred, relative to the timestamp of the first entry in the reading buffer.",
            "details": "The relative timestamps information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you will not be able to access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).This read\u2011only attribute is an array of timestamps, in seconds, of when each reading occurred relative to the timestamp of the first entry in the reading buffer. These timestamps are equal to the time that has lapsed for each reading since the first reading was stored in the buffer. Therefore, the relative timestamp for the first entry number in the reading buffer equals 0.",
            "param_info": [],
            "usage": [
                "timestamp = bufferVar.relativetimestamps[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collecttimestamps = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.relativetimestamps[1]);\u00a0;printbuffer(1, 6, testData.relativetimestamps);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect time and date data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --The print() command then outputs the relative timestamp of the first measurement in the reading buffer. \n--- --Output:\n--- --0.000000000e+00\n--- --The printbuffer() command then outputs the relative timestamp for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --0.000000000e+00, 1.894584000e\u201102, 3.789703500e\u201102, 5.685028500e\u201102, 7.580344500e\u201102, 1.715638050e\u201101\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.seconds",
            "webhelpfile": "20159.htm",
            "signature": "",
            "command_return": "seconds",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the timestamp of a reading in seconds, in UTC format.",
            "details": "The bufferVar.seconds information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you will not be able to access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).This attribute contains the nonfractional seconds portion of the timestamp when the reading was stored in Coordinated Universal Time (UTC) format.The nonfractional seconds portion of the timestamp gives the lowest resolution down to 1 second. To access additional resolution of a timestamp, see bufferVar.fractionalseconds.",
            "param_info": [],
            "usage": [
                "seconds = bufferVar.seconds[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collecttimestamps = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);print(testData.seconds[1]);\u00a0;printbuffer(1, 6, testData.seconds);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect time and date data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --The print() command then outputs the seconds portion of the timestamp of the first reading in the reading buffer. \n--- --Output:\n--- --1.310375688e+09\n--- --The printbuffer() command then outputs the seconds portion of the timestamps for measurements 1 to 6 in the reading buffer. \n--- --Output:\n--- --1.310375688e+09, 1.310375688e+09, 1.310375688e+09, 1.310375688e+09, 1.310375688e+09, 1.310375688e+09\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.times",
            "webhelpfile": "20160.htm",
            "signature": "",
            "command_return": "readingtime",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "When enabled by the bufferVar.collecttimestamps attribute, this attribute contains the time of the readings (in hours, minutes, and seconds format) in the reading buffer.",
            "details": "The times information from a reading buffer is only available if the bufferVar.collecttimestamps attribute is set to 1 (default setting). If it is set to 0, you cannot access any time information from a reading buffer. You may change the collect timestamps setting when the buffer is empty (bufferVar.clear()).This read\u2011only attribute is an array (a Lua table) of strings indicating the time of the reading formatted in hours, minutes, and seconds. These seconds are absolute and in UTC format.",
            "param_info": [],
            "usage": [
                "readingtime = bufferVar.times[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);testData.collecttimestamps = 1;dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.times[1]);\u00a0;printbuffer(1, 6, testData.times);",
                    "description": "This example creates a reading buffer named testData, configures the buffer to collect time and date data, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --The print() command then outputs the time of the first reading in the reading buffer. \n--- --Output:\n--- --09:14:48\n--- --\u00a0\n--- --The printbuffer() command then outputs the time of readings 1 to 6 in the reading buffer. \n--- --Output:\n--- --09:14:48, 09:14:48, 09:14:48, 09:14:48, 09:14:48, 09:14:48\n"
                }
            ],
            "related_commands": [
                "bufferVar.clear()",
                "bufferVar.collecttimestamps",
                "Reading buffers"
            ]
        },
        {
            "name": "bufferVar.units",
            "webhelpfile": "20161.htm",
            "signature": "",
            "command_return": "unitsOfMeasure",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the unit of measure that is stored with readings in the reading buffer.",
            "details": "This attribute is an array (Lua table) of the strings that indicate the unit of measure that is stored with readings in the buffer. You can designate units as one of the following: Volts AC, Volts DC, Amps AC, Amps DC, dB\u00a0VAC, dB\u00a0VDC, Ohms 2wire, Ohms 4wire, Ohms ComSide, Fahrenheit, Kelvin, Celsius, Hertz, Seconds, and Continuity.",
            "param_info": [],
            "usage": [
                "unitsOfMeasure = bufferVar.units[N]"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "reset() ;testData = dmm.makebuffer(1000);dmm.nplc = 0.5;dmm.range = 0;dmm.configure.set(\"Dcv_100mV\");dmm.setconfig(\"slot2\", \"Dcv_100mV\");scan.create(\"2035:2040\");scan.execute(testData);\u00a0;print(testData.units[1]);\u00a0;printbuffer(1, 6, testData.units);",
                    "description": "This example creates a reading buffer named testData, sets and saves the DMM configuration, creates a scan list, and then runs the scan.\n--- --\u00a0\n--- --The print() command outputs the units of the first reading in the reading buffer. \n--- --Output:\n--- --Volts DC\n--- --The printbuffer() command outputs the units of readings 1 to 6 in the reading buffer. \n--- --Output:\n--- --Volts DC, Volts DC, Volts DC, Volts DC, Volts DC, Volts DC\n"
                }
            ],
            "related_commands": [
                "Reading buffers"
            ]
        },
        {
            "name": "comm.lan.enable",
            "webhelpfile": "20163.htm",
            "signature": "",
            "command_return": "state",
            "type": "Attribute (RW)\n",
            "default_value": "true (enabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute controls whether or not any communication using the LAN connection is enabled.",
            "details": "This is the master control setting. When this is true (enabled), you may individually control web, Telnet, VXI-11 and raw socket access to the instrument. However, when this is false (disabled), all LAN communication is disabled and this overrides the individual LAN enabled settings.To disable only certain LAN communication with the instrument, enable this attribute and set the specific LAN communication attribute to false for raw sockets, Telnet, VXI-11 or web.",
            "param_info": [
                {
                    "name": "state",
                    "description": "true",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "state = comm.lan.enable",
                "comm.lan.enable = state"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "comm.lan.enable = false;",
                    "description": "Disable all LAN communication with instrument.\n"
                }
            ],
            "related_commands": [
                "comm.lan.rawsockets.enable",
                "comm.lan.telnet.enable",
                "comm.lan.vxi11.enable",
                "comm.lan.web.enable"
            ]
        },
        {
            "name": "dmm.measurewithptp()",
            "webhelpfile": "20200.htm",
            "signature": "dmm.measurewithptp(bufferVar)",
            "command_return": "reading, seconds, fractional",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function returns the last actual measurement and time information in PTP format without using the trigger model. You can also use a reading buffer to store additional information that is acquired while making a measurement.",
            "details": "This is not available for \"nofunction\". If the command is queried when \"nofunction\" is selected, nil is returned. If it is written when \"nofunction\" is selected, an error is returned.When a reading buffer is used with a command or action that involves taking multiple readings, such as dmm.measure or scanning, all readings are available in the reading buffer. However, only the last reading and time information (seconds and fractional seconds) is returned as a reading with the command.You can also use a reading buffer to store additional information that is acquired while making a measurement.The dmm.measurecount attribute determines how many measurements are performed. When you use a buffer, it also determines if the reading buffer has enough room to store the requested readings. The amount of room is based on readings already stored in the buffer (bufferVar.n), the capacity of the buffer (bufferVar.capacity), and the append mode of the reading buffer (bufferVar.appendmode). If the append mode is set to 0, any stored readings in the buffer are cleared before new ones are stored. If append mode is set to 1, any stored readings remain in the buffer and new ones are added to the buffer after the stored ones.",
            "param_info": [
                {
                    "name": "reading",
                    "description": "The last reading of the measurement process",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "seconds",
                    "description": "Seconds in PTP format",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "fractional",
                    "description": "Fractional seconds",
                    "enum": "",
                    "type": "number",
                    "range": ""
                },
                {
                    "name": "bufferVar",
                    "description": "A previously created reading buffer variable in which all readings are stored",
                    "enum": "",
                    "type": "bufferMethods",
                    "range": ""
                }
            ],
            "usage": [
                "reading, seconds, fractional = dmm.measurewithptp()",
                "reading, seconds, fractional = dmm.measurewithptp(bufferVar)"
            ],
            "overloads": [
                "reading, seconds, fractional = dmm.measurewithptp()"
            ],
            "examples": [
                {
                    "example": "DCVbuffer = dmm.makebuffer(100);dmm.func = \"dcvolts\";dmm.measurecount = 100;reading, seconds, fractional = dmm.measurewithptp(DCVbuffer);print(reading, seconds, fractional);",
                    "description": "Create a reading buffer.\n--- --Perform 100 DC voltage measurements.\n--- --Store the measurements in a buffer called DCVbuffer.\n--- --Print the last measurement and time information in PTP format, which will look similar to:\n--- ---1.064005867e-02   1.779155900e+07\u00a0\u00a0\u00a01.245658350e-01\n"
                }
            ],
            "related_commands": [
                "Reading buffers",
                "dmm.makebuffer()",
                "dmm.measure()",
                "dmm.measurecount"
            ]
        },
        {
            "name": "ptp.ds.info",
            "webhelpfile": "20215.htm",
            "signature": "ptp.ds.info",
            "command_return": "",
            "type": "Attribute (R)",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function is a read-only string that returns the settings of the different data sets (DS) associated with the IEEE\u20111588 2008 specification.",
            "details": "",
            "param_info": [
                {
                    "name": "print(ptp.ds.info)",
                    "description": "Output",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "ptp.ds.info"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(ptp.ds.info);",
                    "description": "Output:\n--- --Current DS\n--- --         Steps removed:  0\n--- --    Offset from Master:  0.000000000\n--- --       Mean Path Delay:  0.000000000\n--- --Default DS\n--- --       Number of Ports:  1\n--- --        Two Step Clock:  T\n--- --            Priority 1:  128\n--- --            Priority 2:  128\n--- --                Domain:  0\n--- --        Clock Identity:  12 34 56 FF FE 65 43 21\n--- --    Clock Qual - Class:  248\n--- -- Clock Qual - Accuracy:  254\n--- -- Clock Qual - Variance:  0\n--- --            Slave Only:  F\n--- --Parent DS\n--- --           Parent Stats:  F\n--- --  Parent Clock Identify:  12 34 56 FF FE 65 43 21\n--- --   Parent Port Identify:  0\n--- --      Parent Offset Var:  65535\n--- --Parent Phase Chnge Rate:  2147483647\n--- --          GM Priority 1:  128\n--- --          GM Priority 2:  128\n--- --   GM Clck Qual - Class:  248\n--- --GM Clck Qual - Accuracy:  254\n--- --GM Clck Qual - Variance:  0\n--- --      GM Clock Identify:  12 34 56 FF FE 65 43 21\n--- --Time Properties DS\n--- --     Current UTC Offset:  0\n--- --                Leap 59:  F\n--- --                Leap 61:  F\n--- --Current UTC Offset Vald:  T\n--- --          PTP Timescale:  T\n--- --         Time Traceable:  F\n--- --    Frequency Traceable:  F\n--- --            Time Source:  Internal Oscillator\n--- --Port DS\n--- --         Clock Identify:  12 34 56 FF FE 65 43 21\n--- --          Port Identify:  1\n--- --             Port State:  6\n--- -- Log Mn Delay Req Intrvl: 4\n--- --   Peer mean Path Delay:  0\n--- --  Log Announce Interval:  1\n--- -- Announc Receipt Timeout: 3\n--- --      Log Sync Interval:  0\n--- --        Delay Mechanism:  E2E\n--- --Log Mn PDelay Rq Intrvl:  0\n--- --         Version Number:  2\n--- --Foreign Master DS 1\n--- --      Announce Messages:  2\n--- -- Frgn Mstr Clock Idntfy:  00 60 1A FF FE 01 54 29\n--- --  Frgn Mstr Port Idntfy:  1\n"
                }
            ],
            "related_commands": [
                "Not applicable"
            ]
        },
        {
            "name": "ptp.domain",
            "webhelpfile": "20216.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the IEEE Std 1588-2008 precision time protocol (PTP) domain.",
            "details": "Only instruments in the same domain will interact with each other in the IEEE\u20111588 PTP.",
            "param_info": [
                {
                    "name": "value",
                    "description": "0 = default domain1 = alternate domain 12 = alternate domain 23 = alternate domain 34 \u2013 127 = user-defined domains128 \u2013 255 = Reserved",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = ptp.domain",
                "ptp.domain = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "ptp.domain=1;print(ptp.domain);",
                    "description": "Sets the ptp domain to 1 (alternate domain 1) and prints the result.\n--- --Output:\n--- --1\n"
                }
            ],
            "related_commands": [
                "Not applicable"
            ]
        },
        {
            "name": "ptp.slavepreferred",
            "webhelpfile": "20217.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "false (disabled)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes whether you prefer to have the instrument be a subordinate clock or not.",
            "details": "From the factory, this attribute is 1. After you set this attribute, it is saved in nonvolatile memory. That setting is recalled the next time the instrument is powered up.",
            "param_info": [
                {
                    "name": "value",
                    "description": "0",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "value = ptp.slavepreferred",
                "ptp.slavepreferred = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "ptp.slavepreferred = 1;print(ptp.slavepreferred);\u00a0;",
                    "description": "Set the instrument to be a subordinate clock. Check to see if the instrument is a subordinate clock.\n--- --Output:\n--- --1\n"
                }
            ],
            "related_commands": [
                "Not applicable"
            ]
        },
        {
            "name": "localnode.emulation",
            "webhelpfile": "20571.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (RW)\n",
            "default_value": "localnode.OFF\n",
            "tsp_link": "No\n",
            "description": "This attribute sets the instrument to report the model number as 3706 instead of 3706A.",
            "details": "This command needs to be set if you replace a Model 3706 with a Model 3706A in a system where computer drivers may be querying the model. This can occur if you replace a Model 3706 with a Model 3706A in an existing system, or if you duplicate a system but use a Model 3706A instead of a Model 3706.When this command is set to localnode.EMULATION_3706, the model number is reported as a 3706 when you send a request with a command such as localnode.model or *idn?. This allows drivers that query the model number to continue to operate normally.This setting is preserved through a power cycle and instrument reset.",
            "param_info": [
                {
                    "name": "value",
                    "description": "0 or localnode.OFF",
                    "enum": "localnode.OFF nil|localnode.EMULATION_3706 nil",
                    "type": "localnodeemulationvalue",
                    "range": ""
                }
            ],
            "usage": [
                "value = localnode.emulation",
                "localnode.emulation = value"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "localnode.emulation = localnode.EMULATION_3706;",
                    "description": "Sets the Model 3706A for Model 3706 emulation.\n"
                }
            ],
            "related_commands": [
                "localnode.model"
            ]
        },
        {
            "name": "localnode.linefreq",
            "webhelpfile": "20578.htm",
            "signature": "",
            "command_return": "frequency",
            "type": "Attribute (R)\n",
            "default_value": "60\n",
            "tsp_link": "Yes\n",
            "description": "This attribute contains the power line frequency setting used for NPLC calculations.",
            "details": "When using this command from a remote node, localnode should be replaced with the node reference, for example node[5].linefreq.",
            "param_info": [
                {
                    "name": "frequency",
                    "description": "An integer representing the instrument's detected line frequency",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "frequency = localnode.linefreq"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "frequency = localnode.linefreq;",
                    "description": "Reads line frequency setting.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "trigger.blender[N].stimulus[M]",
            "webhelpfile": "20592.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the events that trigger the blender.",
            "details": "There are four acceptors that can each select a different event. The eventID parameter can be the event ID of any trigger event.The eventID parameter may be one of the existing trigger event IDs shown in the following table.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The event that triggers the blender action; see Details",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "An integer representing the trigger event blender (up to two)",
                    "enum": "",
                    "type": "any",
                    "range": "(up to two)"
                },
                {
                    "name": "M",
                    "description": "An integer representing the stimulus index (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "eventID = trigger.blender[N].stimulus[M]",
                "trigger.blender[N].stimulus[M] = eventID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[3].mode = digio.TRIG_FALLING;digio.trigger[5].mode = digio.TRIG_FALLING;trigger.blender[1].orenable = true;trigger.blender[1].stimulus[1] = digio.trigger[3].EVENT_ID;trigger.blender[1].stimulus[2] = digio.trigger[5].EVENT_ID;",
                    "description": "Generate a trigger blender 1 event when a digital I/O trigger happens on line 3 or 5.\n"
                }
            ],
            "related_commands": [
                "trigger.blender[N].reset()"
            ]
        },
        {
            "name": "tsplink.trigger[N].stimulus",
            "webhelpfile": "20594.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies the event that causes the synchronization line to assert a trigger.",
            "details": "To disable automatic trigger assertion on the synchronization line, set this attribute to zero (0).Do not use this attribute when triggering under script control. Use tsplink.trigger[N].assert() instead.The eventID parameter may be one of the existing trigger event IDs shown in the following table.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The event identifier for the triggering event",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "The trigger line (1 to 3)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 3)"
                }
            ],
            "usage": [
                "eventID = tsplink.trigger[N].stimulus",
                "tsplink.trigger[N].stimulus = eventID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "tsplink.trigger[3].stimulus = scan.trigger.EVENT_CHANNEL_READY;",
                    "description": "Sets the trigger stimulus of the TSP-Link trigger line 3 event detector to scan the trigger channel ready event.\n"
                }
            ],
            "related_commands": [
                "tsplink.trigger[N].assert()",
                "tsplink.trigger[N].reset()"
            ]
        },
        {
            "name": "lan.trigger[N].stimulus",
            "webhelpfile": "20595.htm",
            "signature": "",
            "command_return": "triggerStimulus",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute specifies events that cause this trigger to assert.",
            "details": "This attribute specifies which event causes a LAN trigger packet to be sent for this trigger. Set triggerStimulus to one of the existing trigger event IDs shown in the following table.Setting this attribute to zero disables automatic trigger generation.If any events are detected prior to calling lan.trigger[N].connect(), the event is ignored and the action overrun is set.",
            "param_info": [
                {
                    "name": "triggerStimulus",
                    "description": "The LAN event identifier used to trigger the event",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "A number specifying the trigger packet over the LAN for which to set or query the trigger source (1 to 8)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 8)"
                }
            ],
            "usage": [
                "triggerStimulus = lan.trigger[N].stimulus",
                "lan.trigger[N].stimulus = triggerStimulus"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "lan.trigger[5].stimulus = trigger.timer[1].EVENT_ID;",
                    "description": "Use timer 1 trigger event as the source for LAN packet 5 trigger stimulus.\n"
                }
            ],
            "related_commands": [
                "lan.trigger[N].assert()",
                "lan.trigger[N].clear()",
                "lan.trigger[N].connect()",
                "lan.trigger[N].overrun",
                "lan.trigger[N].wait()"
            ]
        },
        {
            "name": "digio.trigger[N].stimulus",
            "webhelpfile": "20596.htm",
            "signature": "",
            "command_return": "triggerStimulus",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute selects the event that causes a trigger to be asserted on the digital output line.",
            "details": "Set this attribute to zero (0) to disable the automatic trigger output.Do not use the stimulus attribute for generating output triggers under script control. Use digio.trigger[N].assert() instead.The trigger stimulus for a digital I/O line may be set to one of the trigger event IDs, described in the following table.",
            "param_info": [
                {
                    "name": "triggerStimulus",
                    "description": "The event identifier for the triggering event",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Digital I/O trigger line (1 to 14)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 14)"
                }
            ],
            "usage": [
                "triggerStimulus = digio.trigger[N].stimulus",
                "digio.trigger[N].stimulus = triggerStimulus"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "digio.trigger[3].stimulus = 0;",
                    "description": "Clear the trigger stimulus of digital I/O line 3.\n"
                },
                {
                    "example": "digio.trigger[3].stimulus = scan.trigger.EVENT_CHANNEL_READY;",
                    "description": "Set the trigger stimulus of digital I/O line 3 to be the channel ready event during a scan.\n"
                }
            ],
            "related_commands": [
                "digio.trigger[N].assert()",
                "digio.trigger[N].clear()",
                "digio.trigger[N].reset()"
            ]
        },
        {
            "name": "trigger.timer[N].stimulus",
            "webhelpfile": "20597.htm",
            "signature": "",
            "command_return": "eventID",
            "type": "Attribute (RW)\n",
            "default_value": "0\n",
            "tsp_link": "Yes\n",
            "description": "This attribute describes the event that starts the trigger timer.",
            "details": "The eventID parameter may be one of the trigger event IDs shown in the following table.Set this attribute to the eventID of any trigger event to wait for that event.Use zero (0) to disable event processing.",
            "param_info": [
                {
                    "name": "eventID",
                    "description": "The event that triggers the timer delay",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "N",
                    "description": "Trigger timer number (1 to 4)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 4)"
                }
            ],
            "usage": [
                "eventID = trigger.timer[N].stimulus",
                "trigger.timer[N].stimulus = eventID"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(trigger.timer[1].stimulus);",
                    "description": "Prints the event that will start a trigger 1 timer action.\n"
                }
            ],
            "related_commands": [
                "trigger.timer[N].reset()"
            ]
        },
        {
            "name": "scriptVar.name",
            "webhelpfile": "2589.htm",
            "signature": "",
            "command_return": "scriptName",
            "type": "Attribute (RW)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "No\n",
            "description": "This attribute contains the name of a script in the runtime environment.",
            "details": "When setting the script name, this attribute renames the script that the variable scriptVar references.This attribute must be either a valid Lua identifier or the empty string. Changing the name of a script changes the index that is used to access the script in the script.user.scripts table. Setting the attribute to an empty string removes the script from the table completely, and the script becomes an unnamed script.As long as there are variables referencing an unnamed script, the script can be accessed through those variables. When all variables that reference an unnamed script are removed, the script is removed from the runtime environment.If the new name is the same as a name that is already used for another script, the name of the other script is set to an empty string, and that script becomes unnamed. ",
            "param_info": [
                {
                    "name": "scriptVar",
                    "description": "Name of the variable that references the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "scriptName",
                    "description": "A string that represents the name of the script",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "scriptVar.name = scriptName",
                "scriptName = scriptVar.name"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "test7 = script.new(\"display.clear() display.settext('Hello\u00a0from\u00a0my\u00a0test')\", \"\");test7();print(test7.name);\u00a0;test7.name = \"test7\";print(test7.name);test7.save();",
                    "description": "This example calls the script.new() function to create a script with no name, runs the script, names the script test7, and then saves the script in nonvolatile memory.\n"
                }
            ],
            "related_commands": [
                "Rename a script",
                "script.new()",
                "scriptVar.save()"
            ]
        },
        {
            "name": "os.time()",
            "webhelpfile": "25959.htm",
            "signature": "os.time(timespec)",
            "command_return": "utcTime",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function generates a time value in UTC time.",
            "details": "The timespec is a table using the fields listed in the table below.If the time (hour, minute, and second) options are not used, they default to noon for that day. When called without a parameter (the first form), the function returns the current time.Set the time zone before calling the os.time() function.",
            "param_info": [
                {
                    "name": "utcTime",
                    "description": "Time value in UTC time",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "timespec",
                    "description": "The date and time (year, month, day, hour, and minute)",
                    "enum": "",
                    "type": "any",
                    "range": "(year, month, day, hour, and minute)"
                }
            ],
            "usage": [
                "utcTime = os.time()",
                "utcTime = os.time(timespec)"
            ],
            "overloads": [
                "utcTime = os.time()"
            ],
            "examples": [
                {
                    "example": "systemTime = os.time({year = 2019,;       month = 3,;       day = 31,;       hour = 14,;       min = 25});settime(systemTime);",
                    "description": "Sets the date and time to Mar 31, 2019 at\u00a02:25\u00a0pm.\n"
                }
            ],
            "related_commands": [
                "settime()",
                "settimezone()"
            ]
        },
        {
            "name": "display.waitkey()",
            "webhelpfile": "66558.htm",
            "signature": "display.waitkey()",
            "command_return": "keyCode",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function captures the key code value for the next front\u2011panel action.",
            "details": "After you send this function, script execution pauses until a front\u2011panel action (for example, pressing a key or the navigation wheel , or turning the navigation wheel ). After the action, the value of the key (or action) is returned.If the EXIT (LOCAL) key is pressed while this function is waiting for a front\u2011panel action, the script is not aborted.A typical use for this function is to prompt the user to press the EXIT (LOCAL) key to abort the script or press any other key to continue. For example, if the keyCode value 67 is returned (the EXIT (LOCAL) key was pressed), the exit() function can be called to abort the script.The table below lists the keyCode value for each front panel action.",
            "param_info": [
                {
                    "name": "keyCode",
                    "description": "See Details for more information",
                    "enum": "",
                    "type": "number",
                    "range": ""
                }
            ],
            "usage": [
                "keyCode = display.waitkey()"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "key = display.waitkey();print(key);",
                    "description": "Pause script execution until the operator presses a key or the navigation wheel , or rotates the navigation wheel.\n--- --If the output is:\n--- --8.600000000e+01\n--- --It indicates that the STEP key was pressed.\n"
                }
            ],
            "related_commands": [
                "Capturing key-press codes",
                "display.getlastkey()",
                "display.sendkey()",
                "display.settext()"
            ]
        },
        {
            "name": "lan.config.dns.hostname",
            "webhelpfile": "66559.htm",
            "signature": "",
            "command_return": "hostName",
            "type": "Attribute (RW)\n",
            "default_value": "Instrument specific (see Details)\n",
            "tsp_link": "Yes\n",
            "description": "This attribute defines the dynamic DNS host name.",
            "details": "This attribute holds the host name to request during dynamic DNS registration. Dynamic DNS registration works with DHCP to register the host name specified in this attribute with the DNS\u00a0server.The factory default value for hostName is \"K\u2011<model number>\u2011<serial number>\", where <model number> and <serial number> are replaced with the actual model number and serial number of the instrument (for example, \"K\u20113706A\u20111234567\"). Note that hyphens separate the characters of hostName. The length of the fully qualified host name (combined length of the domain and host name with separator characters) must be less than or equal to 255 characters. Although up to 15 characters can be entered here, you must make sure the combined length is no more than 255 characters.Setting this attribute to an empty string (in other words, setting this attribute to a string of length zero or a string that consists entirely of whitespace characters) reverts the host name to the factory default value.",
            "param_info": [
                {
                    "name": "hostName",
                    "description": "The host name to use for dynamic DNS registration; the host name must",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "hostName = lan.config.dns.hostname",
                "lan.config.dns.hostname = hostName"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(lan.config.dns.hostname);",
                    "description": "Outputs the present dynamic DNS host name.\n"
                }
            ],
            "related_commands": [
                "lan.config.dns.domain",
                "lan.config.dns.dynamic",
                "lan.restoredefaults()"
            ]
        },
        {
            "name": "io.input()",
            "webhelpfile": "66560.htm",
            "signature": "io.input(newfile)",
            "command_return": "fileVar",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes (see Details)\n",
            "description": "This function assigns a previously opened file, or opens a new file, as the default input file.",
            "details": "The newfile path may be absolute or relative to the current working directory.When using this function from a remote TSP-Link\u00ae node, this command does not accept a file descriptor and does not return a value.If the function fails, an error message is returned.",
            "param_info": [
                {
                    "name": "fileVar",
                    "description": "The descriptor of the input file or an error message (if the function fails)",
                    "enum": "",
                    "type": "io_object",
                    "range": "(if the function fails)"
                },
                {
                    "name": "newfile",
                    "description": "A string representing the path of a file to open as the default input file, or the file descriptor of an open file to use as the default input file",
                    "enum": "",
                    "type": "string",
                    "range": ""
                }
            ],
            "usage": [
                "fileVar = io.input()",
                "fileVar = io.input(newfile)"
            ],
            "overloads": [
                "fileVar = io.input()"
            ],
            "examples": [],
            "related_commands": [
                "Script examples",
                "io.open()",
                "io.output()"
            ]
        },
        {
            "name": "setup.recall()",
            "webhelpfile": "66566.htm",
            "signature": "setup.recall(id)",
            "command_return": "",
            "type": "Function\n",
            "default_value": "\u00a0\n",
            "tsp_link": "Yes\n",
            "description": "This function recalls settings from a saved setup.",
            "details": "If the id parameter is 1, the internal setup that was saved with setup.save() is recalled. If the id parameter is 0, the instrument recalls the factory default setup.When the id parameter is a string, it is interpreted as the path and file name of the setup to restore from a file on a USB flash drive. The path may be absolute or relative to the current working directory.Before a setup is recalled, an instrument reset is performed.",
            "param_info": [
                {
                    "name": "id",
                    "description": "An integer or string that specifies the location of the setup to recall",
                    "enum": "",
                    "type": "number|string",
                    "range": ""
                }
            ],
            "usage": [
                "setup.recall(id)"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "setup.recall(1);",
                    "description": "Recall the user-saved setup.\n"
                },
                {
                    "example": "setup.recall(\"/usb1/KEITHLEY_30730.set\");",
                    "description": "Recall a user-saved setup stored in a file named KEITHLEY_30730 on a USB flash\u00a0drive.\n"
                }
            ],
            "related_commands": [
                "Saved setups",
                "setup.save()"
            ]
        },
        {
            "name": "localnode.license",
            "webhelpfile": "92667.htm",
            "signature": "",
            "command_return": "license_agreement",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute returns the product license agreements.",
            "details": "",
            "param_info": [
                {
                    "name": "license_agreement",
                    "description": "The text of the license agreements",
                    "enum": "",
                    "type": "any",
                    "range": ""
                }
            ],
            "usage": [
                "license_agreement = localnode.license"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(localnode.license);",
                    "description": "Returns the license agreements for the Series 3700A.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        },
        {
            "name": "slot[slot].digio",
            "webhelpfile": "962.htm",
            "signature": "",
            "command_return": "value",
            "type": "Attribute (R)\n",
            "default_value": "Not applicable\n",
            "tsp_link": "Yes\n",
            "description": "This attribute indicates whether or not a card in the specified slot supports digital input and output channels.",
            "details": "This attribute is only available for a slot if the installed card supports digital I/O channels.If digital I/O channels are supported, the returned value is 1.",
            "param_info": [
                {
                    "name": "value",
                    "description": "Indicator for whether or not the card in the slot supports digital I/O channels",
                    "enum": "",
                    "type": "any",
                    "range": ""
                },
                {
                    "name": "slot",
                    "description": "Slot number (1 to 6)",
                    "enum": "",
                    "type": "any",
                    "range": "(1 to 6)"
                }
            ],
            "usage": [
                "value = slot[slot].digio"
            ],
            "overloads": [],
            "examples": [
                {
                    "example": "print(slot[1].digio);",
                    "description": "Query if slot 1 supports digital I/O channels.\n"
                }
            ],
            "related_commands": [
                "None"
            ]
        }
    ]
}